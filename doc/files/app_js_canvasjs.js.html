<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/js/canvasjs.js - dataexp</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0pr2/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1><a href="../index.html"><img src="../assets/css/logo.png" width="117" height="52">dataexp: app/js/canvasjs.js</a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div class="yui3-g">

        <div id="sidebar" class="yui3-u">
            <div id="modules" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Modules</h2>
                </div>
                <div class="bd">
                    <ul>
                    </ul>
                </div>
            </div>
            
            <div id="classes" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Classes</h2>
                </div>
                <div class="bd">
                    <ul>
                    </ul>
                </div>
            </div>
            
            
            
            
            
            <div id="fileTree" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Files</h2>
                </div>
                <div class="bd">
                    <ul><li>app/<ul><li>js/<ul><li><a href="../files/app_js_canvasjs.js.html">canvasjs.js</a></li><li>controllers/<ul><li><a href="../files/app_js_controllers_DialogCtrl.js.html">DialogCtrl.js</a></li><li><a href="../files/app_js_controllers_LeftNavCtrl.js.html">LeftNavCtrl.js</a></li></ul></li></ul></li></ul></li></ul>
                </div>
            </div>
            
        </div>

        <div id="main" class="yui3-u">
            <div class="content"><h4>app/js/canvasjs.js</h4>

<pre class="code prettyprint linenums">
ï»¿/**
* @preserve CanvasJS HTML5 &amp; JavaScript Charts - v1.8.1 GA - http://canvasjs.com/ 
* Copyright 2013 fenopix
*/

/*
* CanvasJS Charts follows Dual Licensing Model as mentioned below. 
* 
* ---------------------Free for Non-Commercial Use--------------------
* 
* For non-commercial purposes you can use the software for free under Creative Commons Attribution-NonCommercial 3.0 License. Refer to the following link for further details on the same.
*     http://creativecommons.org/licenses/by-nc/3.0/deed.en_US
* 
* ---------------------Commercial License--------------------
* Commercial use of CanvasJS requires you to purchase a license. Without a commercial license you can use it for evaluation purposes only. Please refer to the following link for further details.
*     http://canvasjs.com/
* 
*/


/* jshint -W099 */ //Ignore warning &quot;Mixed Spaces and Tabs&quot;

(function () {

	var isDebugMode = false;

	var isCanvasSupported = !!document.createElement(&quot;canvas&quot;).getContext;
	//isCanvasSupported = false;

	//Default values for all Chart Elements that can be set by the user. CanvasJSObject.setOptions looks into this while setting the default/user-defined values.
	var defaultOptions = {
		Chart: {
			width: 500,
			height: 400,
			zoomEnabled: false,
			zoomType: &quot;x&quot;,
			backgroundColor: &quot;white&quot;,
			theme: &quot;theme1&quot;,
			animationEnabled: false,
			animationDuration: 1200,

			dataPointWidth: null,
			dataPointMinWidth: null,
			dataPointMaxWidth: null,

			colorSet: &quot;colorSet1&quot;,
			culture: &quot;en&quot;,
			creditText: &quot;CanvasJS.com&quot;,
			interactivityEnabled: true,
			exportEnabled: false,
			exportFileName: &quot;Chart&quot;,

			rangeChanging: null,
			rangeChanged: null
		},

		Title: {
			padding: 0,
			text: null,
			verticalAlign: &quot;top&quot;,//top, center, bottom
			horizontalAlign: &quot;center&quot;,//left, center, right
			fontSize: 20,//in pixels
			fontFamily: &quot;Calibri&quot;,
			fontWeight: &quot;normal&quot;, //normal, bold, bolder, lighter,
			fontColor: &quot;black&quot;,
			fontStyle: &quot;normal&quot;, // normal, italic, oblique

			borderThickness: 0,
			borderColor: &quot;black&quot;,
			cornerRadius: 0,
			backgroundColor: null,
			margin: 5,
			wrap: true,
			maxWidth: null,

			dockInsidePlotArea: false
			//toolTipContent: null//string - To be implemented (TBI)
		},

		Subtitle: {
			padding: 0,
			text: null,
			verticalAlign: &quot;top&quot;,//top, center, bottom
			horizontalAlign: &quot;center&quot;,//left, center, right
			fontSize: 14,//in pixels
			fontFamily: &quot;Calibri&quot;,
			fontWeight: &quot;normal&quot;, //normal, bold, bolder, lighter,
			fontColor: &quot;black&quot;,
			fontStyle: &quot;normal&quot;, // normal, italic, oblique

			borderThickness: 0,
			borderColor: &quot;black&quot;,
			cornerRadius: 0,
			backgroundColor: null,
			margin: 2,
			wrap: true,
			maxWidth: null,

			dockInsidePlotArea: false
			//toolTipContent: null//string - To be implemented (TBI)
		},

		Legend: {
			name: null,
			verticalAlign: &quot;center&quot;,
			horizontalAlign: &quot;right&quot;,

			fontSize: 14,//in pixels
			fontFamily: &quot;calibri&quot;,
			fontWeight: &quot;normal&quot;, //normal, bold, bolder, lighter,
			fontColor: &quot;black&quot;,
			fontStyle: &quot;normal&quot;, // normal, italic, oblique

			cursor: null,
			itemmouseover: null,
			itemmouseout: null,
			itemmousemove: null,
			itemclick: null,

			dockInsidePlotArea: false,
			reversed: false,

			maxWidth: null,
			maxHeight: null,

			itemMaxWidth: null,
			itemWidth: null,
			itemWrap: true,
			itemTextFormatter: null
		},

		ToolTip: {
			enabled: true,
			shared: false,
			animationEnabled: true,
			content: null,
			contentFormatter: null,

			reversed: false,

			backgroundColor: null,

			borderColor: null,
			borderThickness: 2, //in pixels
			cornerRadius: 5, // in pixels

			fontSize: 14, // in pixels
			fontColor: null,
			fontFamily: &quot;Calibri, Arial, Georgia, serif;&quot;,
			fontWeight: &quot;normal&quot;, //normal, bold, bolder, lighter,
			fontStyle: &quot;italic&quot;  // normal, italic, oblique
		},

		Axis: {
			minimum: null, //Minimum value to be shown on the Axis
			maximum: null, //Minimum value to be shown on the Axis
			viewportMinimum: null,
			viewportMaximum: null,
			interval: null, // Interval for tick marks and grid lines
			intervalType: null, //number, millisecond, second, minute, hour, day, month, year
			//reversed: false,

			title: null, // string
			titleFontColor: &quot;black&quot;,
			titleFontSize: 20,
			titleFontFamily: &quot;arial&quot;,
			titleFontWeight: &quot;normal&quot;,
			titleFontStyle: &quot;normal&quot;,
			titleWrap: true,
			titleMaxWidth: null,

			labelAngle: 0,
			labelFontFamily: &quot;arial&quot;,
			labelFontColor: &quot;black&quot;,
			labelFontSize: 12,
			labelFontWeight: &quot;normal&quot;,
			labelFontStyle: &quot;normal&quot;,
			labelAutoFit: true,
			labelWrap: true,
			labelMaxWidth: null,//null for auto
			labelFormatter: null,

			prefix: &quot;&quot;,
			suffix: &quot;&quot;,

			includeZero: true, //Applies only for axisY. Ignored in axisX.

			tickLength: 5,
			tickColor: &quot;black&quot;,
			tickThickness: 1,

			lineColor: &quot;black&quot;,
			lineThickness: 1,
			lineDashType: &quot;solid&quot;,

			gridColor: &quot;A0A0A0&quot;,
			gridThickness: 0,
			gridDashType: &quot;solid&quot;,

			interlacedColor: null,

			valueFormatString: null,

			margin: 2,

			stripLines: [] // Just a placeholder. Does not have any effect on the actual number of striplines      
		},

		StripLine: {
			value: null,
			startValue: null,
			endValue: null,

			color: &quot;orange&quot;,
			opacity: null,
			thickness: 2,
			lineDashType: &quot;solid&quot;,
			label: &quot;&quot;,
			labelPlacement: &quot;inside&quot;,//&quot;outside&quot;
			labelAlign: &quot;far&quot;,//&quot;near&quot; , &quot;center&quot; , &quot;far&quot;
			labelWrap: true,
			labelMaxWidth: null,
			labelBackgroundColor: &quot;transparent&quot;,
			labelFontFamily: &quot;arial&quot;,
			labelFontColor: &quot;orange&quot;,
			labelFontSize: 12,
			labelFontWeight: &quot;normal&quot;,
			labelFontStyle: &quot;normal&quot;,
			labelFormatter: null,

			showOnTop: false
		},

		DataSeries: {
			name: null,
			dataPoints: null,
			label: &quot;&quot;,
			bevelEnabled: false,
			highlightEnabled: true,

			cursor: null,

			indexLabel: &quot;&quot;,
			indexLabelPlacement: &quot;auto&quot;,  //inside, outside, auto       
			indexLabelOrientation: &quot;horizontal&quot;,
			indexLabelFontColor: &quot;black&quot;,
			indexLabelFontSize: 12,
			indexLabelFontStyle: &quot;normal&quot;, //   italic ,oblique, normal 
			indexLabelFontFamily: &quot;Arial&quot;, 	// fx: Arial Verdana &quot;Courier New&quot; Serif 
			indexLabelFontWeight: &quot;normal&quot;, 	// bold ,bolder, lighter, normal 
			indexLabelBackgroundColor: null,
			indexLabelLineColor: null,
			indexLabelLineThickness: 1,
			indexLabelLineDashType: &quot;solid&quot;,
			indexLabelMaxWidth: null,
			indexLabelWrap: true,
			indexLabelFormatter: null,

			lineThickness: 2,
			lineDashType: &quot;solid&quot;,
			connectNullData: false,
			nullDataLineDashType: &quot;dash&quot;,

			color: null,
			lineColor: null,
			risingColor: &quot;white&quot;,
			fillOpacity: null,

			startAngle: 0,

			radius: null,
			innerRadius: null,

			type: &quot;column&quot;, //line, column, bar, area, scatter stackedColumn, stackedBar, stackedArea, stackedColumn100, stackedBar100, stackedArea100, pie, doughnut
			xValueType: &quot;number&quot;, //number, dateTime
			axisYType: &quot;primary&quot;,

			xValueFormatString: null,
			yValueFormatString: null,
			zValueFormatString: null,
			percentFormatString: null,

			showInLegend: null,
			legendMarkerType: null,
			legendMarkerColor: null,
			legendText: null,
			legendMarkerBorderColor: null,
			legendMarkerBorderThickness: null,

			markerType: &quot;circle&quot;, //none, circle, square, cross, triangle, line
			markerColor: null,
			markerSize: null,
			markerBorderColor: null,
			markerBorderThickness: null,
			//animationEnabled: true,
			mouseover: null,
			mouseout: null,
			mousemove: null,
			click: null,
			toolTipContent: null,

			visible: true
		},

		//Private
		TextBlock: {
			x: 0,
			y: 0,
			width: null,//read only
			height: null,//read only
			maxWidth: null,
			maxHeight: null,
			padding: 0,
			angle: 0,
			text: &quot;&quot;,
			horizontalAlign: &quot;center&quot;,//left, center, right
			fontSize: 12,//in pixels
			fontFamily: &quot;calibri&quot;,
			fontWeight: &quot;normal&quot;, //normal, bold, bolder, lighter,
			fontColor: &quot;black&quot;,
			fontStyle: &quot;normal&quot;, // normal, italic, oblique

			borderThickness: 0,
			borderColor: &quot;black&quot;,
			cornerRadius: 0,
			backgroundColor: null,
			textBaseline: &quot;top&quot;
		},

		CultureInfo: {
			decimalSeparator: &quot;.&quot;,
			digitGroupSeparator: &quot;,&quot;,
			zoomText: &quot;Zoom&quot;,
			panText: &quot;Pan&quot;,
			resetText: &quot;Reset&quot;,

			menuText: &quot;More Options&quot;,
			saveJPGText: &quot;Save as JPEG&quot;,
			savePNGText: &quot;Save as PNG&quot;,

			days: [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;],
			shortDays: [&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;],

			months: [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;],
			shortMonths: [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]
		}
	};

	//#region Cultures

	var cultures = {
		&quot;en&quot;: {
			//Derives from the default options
		}//,
		//&quot;es&quot;: {
		//    decimalSeparator: &quot;,&quot;,
		//    digitGroupSeparator: &quot;.&quot;,
		//    zoomText: &quot;zoom&quot;,
		//    panText: &quot;pan&quot;,
		//    resetText: &quot;reset&quot;,
		//    days: [&quot;domingo&quot;, &quot;lunes&quot;, &quot;martes&quot;, &quot;miÃ©rcoles&quot;, &quot;jueves&quot;, &quot;viernes&quot;, &quot;sÃ¡bado&quot;],
		//}
	};

	//#endregion Cultures

	//#region Themes

	var colorSets = {

		&quot;colorSet1&quot;: [
			&quot;#369EAD&quot;,
			&quot;#C24642&quot;,
			&quot;#7F6084&quot;,
			//&quot;#96C412&quot;,
			&quot;#86B402&quot;,
			&quot;#A2D1CF&quot;,
			//&quot;#D8C641&quot;,
			&quot;#C8B631&quot;,
			&quot;#6DBCEB&quot;,
			//&quot;#4A4946&quot;,
			&quot;#52514E&quot;,
			&quot;#4F81BC&quot;,
			&quot;#A064A1&quot;,
			&quot;#F79647&quot;
		],
		&quot;colorSet2&quot;: [
			&quot;#4F81BC&quot;,
			&quot;#C0504E&quot;,
			&quot;#9BBB58&quot;,
			&quot;#23BFAA&quot;,
			//&quot;#FAA586&quot;,
			&quot;#8064A1&quot;,
			&quot;#4AACC5&quot;,
			&quot;#F79647&quot;,
			//&quot;#77AA33&quot;,
			//&quot;#7F6084&quot;
			&quot;#33558B&quot;
		],
		&quot;colorSet3&quot;: [
			&quot;#8CA1BC&quot;,
			&quot;#36845C&quot;,
			&quot;#017E82&quot;,
			&quot;#8CB9D0&quot;,
			&quot;#708C98&quot;,
			&quot;#94838D&quot;,
			&quot;#F08891&quot;,
			&quot;#0366A7&quot;,
			&quot;#008276&quot;,
			&quot;#EE7757&quot;,
			&quot;#E5BA3A&quot;,
			&quot;#F2990B&quot;,
			&quot;#03557B&quot;,
			&quot;#782970&quot;
		]//,
		//&quot;colorSet4&quot;: [
		//    &quot;#3698C5&quot;,
		//    &quot;#009B8D&quot;,
		//    &quot;#F1D691&quot;,
		//    &quot;#F8B90C&quot;,
		//    &quot;#0081B8&quot;,
		//    &quot;#5B5A96&quot;,
		//    &quot;#ACBDD1&quot;,
		//    &quot;#88A891&quot;,
		//    &quot;#39969D&quot;,
		//    &quot;#AECEDD&quot;,
		//    &quot;#A0B2BC&quot;,
		//    &quot;#BBAEB7&quot;,
		//    &quot;#A0C65F&quot;,
		//    &quot;#EEA6AA&quot;,
		//    &quot;#3798C5&quot;
		//],
		//&quot;colorSet5&quot;: [
		//    &quot;#88ADBF&quot;,
		//    &quot;#84C336&quot;,
		//    &quot;#7B91C3&quot;,
		//    &quot;#4661EE&quot;,
		//    &quot;#EC5657&quot;,
		//    &quot;#1BCDD1&quot;,
		//    &quot;#8FAABB&quot;,
		//    &quot;#B08BEB&quot;,
		//    &quot;#3EA0DD&quot;,
		//    &quot;#F5A52A&quot;,
		//    &quot;#23BFAA&quot;,
		//    &quot;#FAA586&quot;,
		//    &quot;#EB8CC6&quot;
		//]

	};

	var themes =
		{
			&quot;theme1&quot;: {
				Chart:
					{
						colorSet: &quot;colorSet1&quot;
					},
				Title: {
					fontFamily: isCanvasSupported ? &quot;Calibri, Optima, Candara, Verdana, Geneva, sans-serif&quot; : &quot;calibri&quot;,
					fontSize: 33,
					fontColor: &quot;#3A3A3A&quot;,
					fontWeight: &quot;bold&quot;,
					verticalAlign: &quot;top&quot;,
					margin: 5
				},
				Subtitle: {
					fontFamily: isCanvasSupported ? &quot;Calibri, Optima, Candara, Verdana, Geneva, sans-serif&quot; : &quot;calibri&quot;,
					fontSize: 16,
					fontColor: &quot;#3A3A3A&quot;,
					fontWeight: &quot;bold&quot;,
					verticalAlign: &quot;top&quot;,
					margin: 5
				},
				Axis: {
					titleFontSize: 26,
					//titleFontColor: &quot;rgb(98,98,98)&quot;,
					titleFontColor: &quot;#666666&quot;,
					//titleFontFamily: &quot;arial black&quot;,
					//titleFontFamily: &quot;Verdana, Geneva, Calibri, sans-serif&quot;,
					titleFontFamily: isCanvasSupported ? &quot;Calibri, Optima, Candara, Verdana, Geneva, sans-serif&quot; : &quot;calibri&quot;,
					//titleFontWeight: &quot;bold&quot;,

					//labelFontFamily: &quot;Times New Roman, Times, serif&quot;,
					labelFontFamily: isCanvasSupported ? &quot;Calibri, Optima, Candara, Verdana, Geneva, sans-serif&quot; : &quot;calibri&quot;,
					//labelFontFamily: &quot;Helvetica Neue, Helvetica&quot;,
					labelFontSize: 18,
					labelFontColor: &quot;grey&quot;,
					//labelFontWeight: &quot;bold&quot;,
					tickColor: &quot;#BBBBBB&quot;,
					tickThickness: 2,
					gridThickness: 2,
					gridColor: &quot;#BBBBBB&quot;,
					lineThickness: 2,
					lineColor: &quot;#BBBBBB&quot;
				},
				Legend: {
					verticalAlign: &quot;bottom&quot;,
					horizontalAlign: &quot;center&quot;,
					fontFamily: isCanvasSupported ? &quot;monospace, sans-serif,arial black&quot; : &quot;calibri&quot;
				},
				DataSeries: {
					//bevelEnabled: true,
					indexLabelFontColor: &quot;grey&quot;,
					//indexLabelFontFamily: &quot;Trebuchet MS, monospace, Courier New, Courier&quot;,
					indexLabelFontFamily: isCanvasSupported ? &quot;Calibri, Optima, Candara, Verdana, Geneva, sans-serif&quot; : &quot;calibri&quot;,
					//indexLabelFontWeight: &quot;bold&quot;,
					indexLabelFontSize: 18,
					//indexLabelLineColor: &quot;lightgrey&quot;,
					indexLabelLineThickness: 1
				}
			},

			&quot;theme2&quot;: {
				Chart:
					{
						colorSet: &quot;colorSet2&quot;
					},
				Title: {
					fontFamily: &quot;impact, charcoal, arial black, sans-serif&quot;,
					fontSize: 32,//fontColor: &quot;rgb(58,58,58)&quot;,
					fontColor: &quot;#333333&quot;,
					verticalAlign: &quot;top&quot;,
					margin: 5
				},
				Subtitle: {
					fontFamily: &quot;impact, charcoal, arial black, sans-serif&quot;,
					fontSize: 14,//fontColor: &quot;rgb(58,58,58)&quot;,
					fontColor: &quot;#333333&quot;,
					verticalAlign: &quot;top&quot;,
					margin: 5
				},
				Axis: {
					titleFontSize: 22,
					titleFontColor: &quot;rgb(98,98,98)&quot;,
					//titleFontFamily: &quot;arial black&quot;,
					titleFontFamily: isCanvasSupported ? &quot;monospace, sans-serif,arial black&quot; : &quot;arial&quot;,
					titleFontWeight: &quot;bold&quot;,


					labelFontFamily: isCanvasSupported ? &quot;monospace, Courier New, Courier&quot; : &quot;arial&quot;,
					//labelFontFamily: &quot;Helvetica Neue, Helvetica&quot;,
					labelFontSize: 16,
					labelFontColor: &quot;grey&quot;,
					labelFontWeight: &quot;bold&quot;,
					tickColor: &quot;grey&quot;,
					tickThickness: 2,
					gridThickness: 2,
					gridColor: &quot;grey&quot;,
					lineColor: &quot;grey&quot;,
					lineThickness: 0
				},
				Legend: {
					verticalAlign: &quot;bottom&quot;,
					horizontalAlign: &quot;center&quot;,
					fontFamily: isCanvasSupported ? &quot;monospace, sans-serif,arial black&quot; : &quot;arial&quot;
				},
				DataSeries: {
					indexLabelFontColor: &quot;grey&quot;,
					//indexLabelFontFamily: &quot;Trebuchet MS, monospace, Courier New, Courier&quot;,
					indexLabelFontFamily: isCanvasSupported ? &quot;Courier New, Courier, monospace&quot; : &quot;arial&quot;,
					indexLabelFontWeight: &quot;bold&quot;,
					indexLabelFontSize: 18,
					//indexLabelLineColor: &quot;lightgrey&quot;,
					indexLabelLineThickness: 1
				}
			},

			&quot;theme3&quot;: {
				Chart:
					{
						colorSet: &quot;colorSet1&quot;
					},
				Title: {
					fontFamily: isCanvasSupported ? &quot;Candara, Optima, Trebuchet MS, Helvetica Neue, Helvetica, Trebuchet MS, serif&quot; : &quot;calibri&quot;,
					fontSize: 32,
					fontColor: &quot;#3A3A3A&quot;,
					fontWeight: &quot;bold&quot;,
					verticalAlign: &quot;top&quot;,
					margin: 5
				},
				Subtitle: {
					fontFamily: isCanvasSupported ? &quot;Candara, Optima, Trebuchet MS, Helvetica Neue, Helvetica, Trebuchet MS, serif&quot; : &quot;calibri&quot;,
					fontSize: 16,
					fontColor: &quot;#3A3A3A&quot;,
					fontWeight: &quot;bold&quot;,
					verticalAlign: &quot;top&quot;,
					margin: 5
				},
				Axis: {
					titleFontSize: 22,
					titleFontColor: &quot;rgb(98,98,98)&quot;,
					//titleFontFamily: &quot;arial black&quot;,
					titleFontFamily: isCanvasSupported ? &quot;Verdana, Geneva, Calibri, sans-serif&quot; : &quot;calibri&quot;,
					//titleFontWeight: &quot;bold&quot;,

					//labelFontFamily: &quot;Times New Roman, Times, serif&quot;,
					labelFontFamily: isCanvasSupported ? &quot;Calibri, Optima, Candara, Verdana, Geneva, sans-serif&quot; : &quot;calibri&quot;,
					//labelFontFamily: &quot;Helvetica Neue, Helvetica&quot;,
					labelFontSize: 18,
					labelFontColor: &quot;grey&quot;,
					//labelFontWeight: &quot;bold&quot;,
					tickColor: &quot;grey&quot;,
					tickThickness: 2,
					gridThickness: 2,
					gridColor: &quot;grey&quot;,
					lineThickness: 2,
					lineColor: &quot;grey&quot;
				},
				Legend: {
					verticalAlign: &quot;bottom&quot;,
					horizontalAlign: &quot;center&quot;,
					fontFamily: isCanvasSupported ? &quot;monospace, sans-serif,arial black&quot; : &quot;calibri&quot;
				},
				DataSeries: {
					bevelEnabled: true,
					indexLabelFontColor: &quot;grey&quot;,
					//indexLabelFontFamily: &quot;Trebuchet MS, monospace, Courier New, Courier&quot;,
					indexLabelFontFamily: isCanvasSupported ? &quot;Candara, Optima, Calibri, Verdana, Geneva, sans-serif&quot; : &quot;calibri&quot;,
					//indexLabelFontWeight: &quot;bold&quot;,
					indexLabelFontSize: 18,
					indexLabelLineColor: &quot;lightgrey&quot;,
					indexLabelLineThickness: 2
				}
			}
		};

	//#endregion Themes

	var constants = {
		numberDuration: 1,
		yearDuration: 1000 * 60 * 60 * 24 * 364,
		monthDuration: 1000 * 60 * 60 * 24 * 30,
		weekDuration: 1000 * 60 * 60 * 24 * 7,
		dayDuration: 1000 * 60 * 60 * 24,
		hourDuration: 1000 * 60 * 60,
		minuteDuration: 1000 * 60,
		secondDuration: 1000,
		millisecondDuration: 1,

		dayOfWeekFromInt: [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;]
	};

	//#region Static Methods &amp; variables

	function extend(derived, base) {
		derived.prototype = inherit(base.prototype);
		derived.prototype.constructor = derived;
		derived.base = base.prototype;
	}

	function inherit(proto) {
		function F() { }
		F.prototype = proto;
		return new F();
	}

	function addToDateTime(dateTime, num, type) {

		if (type === &quot;millisecond&quot;)
			dateTime.setMilliseconds(dateTime.getMilliseconds() + 1 * num);
		else if (type === &quot;second&quot;)
			dateTime.setSeconds(dateTime.getSeconds() + 1 * num);
		else if (type === &quot;minute&quot;)
			dateTime.setMinutes(dateTime.getMinutes() + 1 * num);
		else if (type === &quot;hour&quot;)
			dateTime.setHours(dateTime.getHours() + 1 * num);
		else if (type === &quot;day&quot;)
			dateTime.setDate(dateTime.getDate() + 1 * num);
		else if (type === &quot;week&quot;)
			dateTime.setDate(dateTime.getDate() + 7 * num);
		else if (type === &quot;month&quot;)
			dateTime.setMonth(dateTime.getMonth() + 1 * num);
		else if (type === &quot;year&quot;)
			dateTime.setFullYear(dateTime.getFullYear() + 1 * num);

		return dateTime;
	}

	function convertToNumber(num, type) {
		return constants[type + &quot;Duration&quot;] * num;
	}

	function pad(value, length) {
		var isNegative = false;
		if (value &lt; 0) {
			isNegative = true;
			value *= -1;
		}

		value = &quot;&quot; + value;
		length = !length ? 1 : length;

		while (value.length &lt; length) value = &quot;0&quot; + value;

		return isNegative ? &quot;-&quot; + value : value;
	}

	function trimString(str) {
		if (!str)
			return str;

		str = str.replace(/^\s\s*/, &#x27;&#x27;);
		var ws = /\s/;
		var i = str.length;
		while (ws.test(str.charAt(--i))) { }
		return str.slice(0, i + 1);
	}

	function extendCtx(context) {
		context.roundRect = function (x, y, width, height, radius, borderThickness, backgroundColor, borderColor) {
			///&lt;signature&gt;
			///&lt;summary&gt;Creates a rounded rectangle with given fill/stroke parameters&lt;/summary&gt;
			///&lt;param name=&quot;x&quot; type=&quot;number&quot;&gt;x value&lt;/param&gt;
			///&lt;param name=&quot;y&quot; type=&quot;number&quot;&gt;y value&lt;/param&gt;
			///&lt;param name=&quot;width&quot; type=&quot;number&quot;&gt;Border Width&lt;/param&gt;
			///&lt;param name=&quot;height&quot; type=&quot;number&quot;&gt;Border Height&lt;/param&gt;
			///&lt;param name=&quot;radius&quot; type=&quot;number&quot;&gt;Border CornerRadius&lt;/param&gt;
			///&lt;param name=&quot;borderThickness&quot; type=&quot;number&quot;&gt;Border Thickess&lt;/param&gt;
			///&lt;param name=&quot;backgroundColor&quot; type=&quot;number&quot;&gt;Background Color&lt;/param&gt;
			///&lt;param name=&quot;borderColor&quot; type=&quot;number&quot;&gt;Border Color&lt;/param&gt;
			///&lt;/signature&gt;

			if (backgroundColor) {
				this.fillStyle = backgroundColor;
			}

			if (borderColor) {
				this.strokeStyle = borderColor;
			}

			//if (typeof stroke == &quot;undefined&quot;) {
			//	stroke = true;
			//}

			if (typeof radius === &quot;undefined&quot;) {
				radius = 5;
			}

			this.lineWidth = borderThickness;

			this.beginPath();
			this.moveTo(x + radius, y);
			this.lineTo(x + width - radius, y);
			this.quadraticCurveTo(x + width, y, x + width, y + radius);
			this.lineTo(x + width, y + height - radius);
			this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
			this.lineTo(x + radius, y + height);
			this.quadraticCurveTo(x, y + height, x, y + height - radius);
			this.lineTo(x, y + radius);
			this.quadraticCurveTo(x, y, x + radius, y);
			this.closePath();

			if (backgroundColor) {
				this.fill();
			}

			if (borderColor &amp;&amp; borderThickness &gt; 0) {
				this.stroke();
			}
		};
	}

	function compareNumbers(a, b) {
		return a - b;
	}

	function compareDataPointX(dataPoint1, dataPoint2) {
		return dataPoint1.x - dataPoint2.x;
	}

	function intToHexColorString(num) {
		var r = ((num &amp; 0xFF0000) &gt;&gt; 16).toString(16);
		var g = ((num &amp; 0x00FF00) &gt;&gt; 8).toString(16);
		var b = ((num &amp; 0x0000FF) &gt;&gt; 0).toString(16);

		r = r.length &lt; 2 ? &quot;0&quot; + r : r;
		g = g.length &lt; 2 ? &quot;0&quot; + g : g;
		b = b.length &lt; 2 ? &quot;0&quot; + b : b;

		return &quot;#&quot; + r + g + b;
	}

	function RGBToInt(r, g, b) {
		var num = (r &lt;&lt; 16) | (g &lt;&lt; 8) | (b);

		return num;
	}

	function intToRGB(num) {
		var rgb = [];
		var r = ((num &amp; 0xFF0000) &gt;&gt; 16);
		var g = ((num &amp; 0x00FF00) &gt;&gt; 8);
		var b = ((num &amp; 0x0000FF) &gt;&gt; 0);

		//r = r.length &lt; 2 ? &quot;0&quot; + r : r;
		//g = g.length &lt; 2 ? &quot;0&quot; + g : g;
		//b = b.length &lt; 2 ? &quot;0&quot; + b : b;

		rgb[0] = r;
		rgb[1] = g;
		rgb[2] = b;

		return rgb;
	}

	function arrayIndexOf(elt /*, from*/) {
		var len = this.length &gt;&gt;&gt; 0;

		var from = Number(arguments[1]) || 0;
		from = (from &lt; 0)
			 ? Math.ceil(from)
			 : Math.floor(from);
		if (from &lt; 0)
			from += len;

		for (; from &lt; len; from++) {
			if (from in this &amp;&amp;
				this[from] === elt)
				return from;
		}
		return -1;
	};

	function isNullOrUndefined(value) {
		return value === null || typeof (value) === &quot;undefined&quot;;
	}

	//IE8- Fix: indexOf is not supported in IE8- for arrays
	function addArrayIndexOf(obj) {
		if (!obj.indexOf) {
			obj.indexOf = arrayIndexOf;
		}

		return obj;
	}

	var fontHeightInPixels = {};
	var textMeasureEl = null;
	function getFontHeightInPixels(fontFamily, fontSize, fontWeight) {

		//return fontSize;

		fontWeight = fontWeight || &quot;normal&quot;;

		var entry = fontFamily + &quot;_&quot; + fontSize + &quot;_&quot; + fontWeight;
		var height = fontHeightInPixels[entry];

		if (isNaN(height)) {
			try {
				var style = &quot;position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;&quot; + &quot;font-family:&quot; + fontFamily + &quot;; &quot; + &quot;font-size:&quot; + fontSize + &quot;px; font-weight:&quot; + fontWeight + &quot;;&quot;;
				//console.log(style);
				if (!textMeasureEl) {
					var body = document.body;
					textMeasureEl = document.createElement(&quot;span&quot;);
					textMeasureEl.innerHTML = &quot;&quot;;
					var textNode = document.createTextNode(&quot;Mpgyi&quot;);
					textMeasureEl.appendChild(textNode);
					body.appendChild(textMeasureEl);
				}

				textMeasureEl.style.display = &quot;&quot;;
				textMeasureEl.setAttribute(&quot;style&quot;, style);

				height = Math.round(textMeasureEl.offsetHeight);
				textMeasureEl.style.display = &quot;none&quot;;
				//body.removeChild(tempDiv);

				//if (window.console)
				//	window.console.log(fontSize + &quot;: &quot; + height);
			}
			catch (e) {
				height = Math.ceil(fontSize * 1.1);
			}

			height = Math.max(height, fontSize);

			fontHeightInPixels[entry] = height;
		}

		return height;
	}

	function getLineDashArray(lineDashType, lineThickness) {
		var lineDashArray = [];

		lineDashType = lineDashType || &quot;solid&quot;;

		var lineDashTypeMap = {
			&quot;solid&quot;: [],
			&quot;shortDash&quot;: [3, 1],
			&quot;shortDot&quot;: [1, 1],
			&quot;shortDashDot&quot;: [3, 1, 1, 1],
			&quot;shortDashDotDot&quot;: [3, 1, 1, 1, 1, 1],
			&quot;dot&quot;: [1, 2],
			&quot;dash&quot;: [4, 2],
			&quot;dashDot&quot;: [4, 2, 1, 2],
			&quot;longDash&quot;: [8, 2],
			&quot;longDashDot&quot;: [8, 2, 1, 2],
			&quot;longDashDotDot&quot;: [8, 2, 1, 2, 1, 2]
		};

		lineDashArray = lineDashTypeMap[lineDashType];

		if (lineDashArray) {

			for (var i = 0; i &lt; lineDashArray.length; i++) {
				lineDashArray[i] *= lineThickness;
			}
		} else
			lineDashArray = [];

		return lineDashArray;
	}

	//userCapture is optional. Defaults to false
	function addEvent(obj, eventType, fn, useCapture) {
		if (obj.addEventListener) {
			obj.addEventListener(eventType, fn, useCapture || false);
		}
		else if (obj.attachEvent) {
			obj.attachEvent(&quot;on&quot; + eventType, function (e) {
				e = e || window.event;
				e.preventDefault = e.preventDefault || function () { e.returnValue = false; };
				e.stopPropagation = e.stopPropagation || function () { e.cancelBubble = true; };
				fn.call(obj, e);
			});
		} else
			return false;
	}

	//#region formatting functions/methods
	var dateFormat = function () {
		var reg = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;/g;

		var defDays = [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;];
		var defShortDays = [&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;];

		var defMonths = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
		var defShortMonths = [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;];

		var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
		var timezoneClip = /[^-+\dA-Z]/g;

		return function (dt, formatString, cultureInfo) {

			var days = cultureInfo ? cultureInfo.days : defDays;
			var months = cultureInfo ? cultureInfo.months : defMonths;

			var shortDays = cultureInfo ? cultureInfo.shortDays : defShortDays;
			var shortMonths = cultureInfo ? cultureInfo.shortMonths : defShortMonths;

			var result = &quot;&quot;;
			var utc = false;

			dt = dt &amp;&amp; dt.getTime ? dt : dt ? new Date(dt) : new Date;
			if (isNaN(dt)) throw SyntaxError(&quot;invalid date&quot;);

			if (formatString.slice(0, 4) === &quot;UTC:&quot;) {
				formatString = formatString.slice(4);
				utc = true;
			}

			var pre = utc ? &quot;getUTC&quot; : &quot;get&quot;;
			var date = dt[pre + &quot;Date&quot;]();
			var day = dt[pre + &quot;Day&quot;]();
			var month = dt[pre + &quot;Month&quot;]();
			var year = dt[pre + &quot;FullYear&quot;]();
			var hours = dt[pre + &quot;Hours&quot;]();
			var minutes = dt[pre + &quot;Minutes&quot;]();
			var seconds = dt[pre + &quot;Seconds&quot;]();
			var milliseconds = dt[pre + &quot;Milliseconds&quot;]();
			var offset = utc ? 0 : dt.getTimezoneOffset();

			result = formatString.replace(reg, function (key) {

				switch (key) {

					case &quot;D&quot;:
						return date;
					case &quot;DD&quot;:
						return pad(date, 2);
					case &quot;DDD&quot;:
						return shortDays[day];
					case &quot;DDDD&quot;:
						return days[day];


					case &quot;M&quot;:
						return month + 1;
					case &quot;MM&quot;:
						return pad(month + 1, 2);
					case &quot;MMM&quot;:
						return shortMonths[month];
					case &quot;MMMM&quot;:
						return months[month];


					case &quot;Y&quot;:
						return parseInt(String(year).slice(-2));
					case &quot;YY&quot;:
						return pad(String(year).slice(-2), 2);
					case &quot;YYY&quot;:
						return pad(String(year).slice(-3), 3);
					case &quot;YYYY&quot;:
						return pad(year, 4);


					case &quot;h&quot;:
						return hours % 12 || 12;
					case &quot;hh&quot;:
						return pad(hours % 12 || 12, 2);


					case &quot;H&quot;:
						return hours;
					case &quot;HH&quot;:
						return pad(hours, 2);

					case &quot;m&quot;:
						return minutes;
					case &quot;mm&quot;:
						return pad(minutes, 2);


					case &quot;s&quot;:
						return seconds;
					case &quot;ss&quot;:
						return pad(seconds, 2);

					case &quot;f&quot;:
						return String(milliseconds).slice(0, 1);
					case &quot;ff&quot;:
						return pad(String(milliseconds).slice(0, 2), 2);
					case &quot;fff&quot;:
						return pad(String(milliseconds).slice(0, 3), 3);


					case &quot;t&quot;:
						return hours &lt; 12 ? &quot;a&quot; : &quot;p&quot;;
					case &quot;tt&quot;:
						return hours &lt; 12 ? &quot;am&quot; : &quot;pm&quot;;
					case &quot;T&quot;:
						return hours &lt; 12 ? &quot;A&quot; : &quot;P&quot;;
					case &quot;TT&quot;:
						return hours &lt; 12 ? &quot;AM&quot; : &quot;PM&quot;;


					case &quot;K&quot;:
						return utc ? &quot;UTC&quot; : (String(dt).match(timezone) || [&quot;&quot;]).pop().replace(timezoneClip, &quot;&quot;); // Time Zone;
					case &quot;z&quot;:
						return (offset &gt; 0 ? &quot;-&quot; : &quot;+&quot;) + Math.floor(Math.abs(offset) / 60); // Hour Offset from UTC without padding
					case &quot;zz&quot;:
						return (offset &gt; 0 ? &quot;-&quot; : &quot;+&quot;) + pad(Math.floor(Math.abs(offset) / 60), 2); // Hour Offset from UTC with padding
					case &quot;zzz&quot;:
						return (offset &gt; 0 ? &quot;-&quot; : &quot;+&quot;) + pad(Math.floor(Math.abs(offset) / 60), 2) + pad(Math.abs(offset) % 60, 2); // Hour and Minute Offset from UTC with padding

					default:
						return key.slice(1, key.length - 1);

				}
			});

			return result;
		};
	}();


	var numberFormat = function (v, fs, cultureInfo) {
		if (v === null)
			return &quot;&quot;;

		v = Number(v);
		var isNegative = v &lt; 0 ? true : false;
		if (isNegative) v *= -1;

		var decimalSeparator = cultureInfo ? cultureInfo.decimalSeparator : &quot;.&quot;;
		var digitGroupSeparator = cultureInfo ? cultureInfo.digitGroupSeparator : &quot;,&quot;;

		var vString = &quot;&quot;;
		fs = String(fs);
		var multiplier = 1;
		var temp;
		var result = &quot;&quot;;

		var matches = &quot;&quot;;
		var decimalPosition = -1;
		var fsBeforeDecimal = [];
		var fsAfterDecimal = [];
		var noPhBeforeDecimal = 0; // Number of Placeholders before Decimal
		var noPhAfterDecimal = 0; // Number of Placeholders after Decimal
		var noComma = 0;
		var isScientificNotation = false;
		var exponent = 0;

		matches = fs.match(/&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[eE][+-]*[0]+|[,]+[.]|â°|./g);
		//window.console.log(matches + &quot; = &quot; + matches.length);
		var match = null;

		for (var i = 0; matches &amp;&amp; i &lt; matches.length; i++) {
			match = matches[i];

			if (match === &quot;.&quot; &amp;&amp; decimalPosition &lt; 0) {
				decimalPosition = i;
				continue;
			} else if (match === &quot;%&quot;) {
				multiplier *= 100;
			} else if (match === &quot;â°&quot;) {
				multiplier *= 1000;
				continue;
			} else if (match[0] === &quot;,&quot; &amp;&amp; match[match.length - 1] === &quot;.&quot;) {
				multiplier /= Math.pow(1000, match.length - 1);
				decimalPosition = i + match.length - 1;
				continue;
			} else if ((match[0] === &quot;E&quot; || match[0] === &quot;e&quot;) &amp;&amp; match[match.length - 1] === &quot;0&quot;) {
				isScientificNotation = true;
			}

			if (decimalPosition &lt; 0) {
				fsBeforeDecimal.push(match);
				if (match === &quot;#&quot; || match === &quot;0&quot;)
					noPhBeforeDecimal++;
				else if (match === &quot;,&quot;)
					noComma++;
			}
			else {
				fsAfterDecimal.push(match);
				if (match === &quot;#&quot; || match === &quot;0&quot;)
					noPhAfterDecimal++;
			}
		}

		if (isScientificNotation) {
			var integer = Math.floor(v);
			exponent = (integer === 0 ? &quot;&quot; : String(integer)).length - noPhBeforeDecimal;
			multiplier /= Math.pow(10, exponent);
		}

		v *= multiplier;

		if (decimalPosition &lt; 0)
			decimalPosition = i;

		vString = v.toFixed(noPhAfterDecimal);
		var split = vString.split(&quot;.&quot;);
		//window.console.log(split);
		var vStringBeforeDecimal = (split[0] + &quot;&quot;).split(&quot;&quot;);
		var vStringAfterDecimal = (split[1] + &quot;&quot;).split(&quot;&quot;);

		if (vStringBeforeDecimal &amp;&amp; vStringBeforeDecimal[0] === &quot;0&quot;)
			vStringBeforeDecimal.shift();

		//window.console.log(fsBeforeDecimal + &quot;&lt;----------&gt;&quot; + fsAfterDecimal + &quot; &amp;        &quot; + vStringBeforeDecimal + &quot;&lt;----------&gt;&quot; + vStringAfterDecimal);

		var noPhProcessed = 0;
		var noDigitsAdded = 0;
		var noCommaAdded = 0;
		var commaDistance = 0;
		var distanceFromLastComma = 0;

		while (fsBeforeDecimal.length &gt; 0) {
			match = fsBeforeDecimal.pop();

			if (match === &quot;#&quot; || match === &quot;0&quot;) {
				noPhProcessed++;

				if (noPhProcessed === noPhBeforeDecimal) {
					var digits = vStringBeforeDecimal;
					vStringBeforeDecimal = [];

					if (match === &quot;0&quot;) {
						//var totalDigits = result.match(/[0-9]/g).length;
						var toPad = noPhBeforeDecimal - noDigitsAdded - (digits ? digits.length : 0);

						while (toPad &gt; 0) {
							digits.unshift(&quot;0&quot;);
							toPad--;
						}
					}

					while (digits.length &gt; 0) {
						result = digits.pop() + result;
						distanceFromLastComma++;

						if (distanceFromLastComma % commaDistance === 0 &amp;&amp; noCommaAdded === noComma &amp;&amp; digits.length &gt; 0)
							result = digitGroupSeparator + result;
					}

					if (isNegative)
						result = &quot;-&quot; + result;

				} else {
					if (vStringBeforeDecimal.length &gt; 0) {
						result = vStringBeforeDecimal.pop() + result;
						noDigitsAdded++;
						distanceFromLastComma++;
					}
					else if (match === &quot;0&quot;) {
						result = &quot;0&quot; + result;
						noDigitsAdded++;
						distanceFromLastComma++;
					}

					if (distanceFromLastComma % commaDistance === 0 &amp;&amp; noCommaAdded === noComma &amp;&amp; vStringBeforeDecimal.length &gt; 0)
						result = digitGroupSeparator + result;
				}


			} else if ((match[0] === &quot;E&quot; || match[0] === &quot;e&quot;) &amp;&amp; match[match.length - 1] === &quot;0&quot; &amp;&amp; /[eE][+-]*[0]+/.test(match)) {
				if (exponent &lt; 0)
					match = match.replace(&quot;+&quot;, &quot;&quot;).replace(&quot;-&quot;, &quot;&quot;);
				else
					match = match.replace(&quot;-&quot;, &quot;&quot;);

				result += match.replace(/[0]+/, function ($0) {
					return pad(exponent, $0.length);
				});


			} else {
				if (match === &quot;,&quot;) {
					noCommaAdded++;
					commaDistance = distanceFromLastComma;
					distanceFromLastComma = 0;

					if (vStringBeforeDecimal.length &gt; 0)
						result = digitGroupSeparator + result;
				} else if (match.length &gt; 1 &amp;&amp; ((match[0] === &quot;\&quot;&quot; &amp;&amp; match[match.length - 1] === &quot;\&quot;&quot;) || (match[0] === &quot;&#x27;&quot; &amp;&amp; match[match.length - 1] === &quot;&#x27;&quot;))) {
					result = match.slice(1, match.length - 1) + result;
				}
				else
					result = match + result;
			}
		}

		var charCount = 0;
		var resultAfterDecimal = &quot;&quot;;
		var addDecimalSeparator = false;

		while (fsAfterDecimal.length &gt; 0) {
			match = fsAfterDecimal.shift();

			if (match === &quot;#&quot; || match === &quot;0&quot;) {
				if (vStringAfterDecimal.length &gt; 0 &amp;&amp; Number(vStringAfterDecimal.join(&quot;&quot;)) !== 0) {
					resultAfterDecimal += vStringAfterDecimal.shift();
					addDecimalSeparator = true;
				}
				else if (match === &quot;0&quot;) {
					resultAfterDecimal += &quot;0&quot;;
					addDecimalSeparator = true;
				}
			} else if (match.length &gt; 1 &amp;&amp; ((match[0] === &quot;\&quot;&quot; &amp;&amp; match[match.length - 1] === &quot;\&quot;&quot;) || (match[0] === &quot;&#x27;&quot; &amp;&amp; match[match.length - 1] === &quot;&#x27;&quot;))) {
				resultAfterDecimal += match.slice(1, match.length - 1);
				//addDecimalSeparator = true;
			} else if ((match[0] === &quot;E&quot; || match[0] === &quot;e&quot;) &amp;&amp; match[match.length - 1] === &quot;0&quot; &amp;&amp; /[eE][+-]*[0]+/.test(match)) {
				if (exponent &lt; 0)
					match = match.replace(&quot;+&quot;, &quot;&quot;).replace(&quot;-&quot;, &quot;&quot;);
				else
					match = match.replace(&quot;-&quot;, &quot;&quot;);
				resultAfterDecimal += match.replace(/[0]+/, function ($0) {
					return pad(exponent, $0.length);
				});
			} else {
				resultAfterDecimal += match;
				//addDecimalSeparator = true;
			}
		}

		result += (addDecimalSeparator ? decimalSeparator : &quot;&quot;) + resultAfterDecimal;
		//window.console.log(result);
		return result;
	};

	//#endregion formatting functions/methods

	function getObjectId(x, y, ctx) {
		x *= devicePixelBackingStoreRatio;
		y *= devicePixelBackingStoreRatio;
		var pixels = ctx.getImageData(x, y, 2, 2).data;
		var isObject = true;

		for (var i = 0; i &lt; 4; i++) {

			if (pixels[i] !== pixels[i + 4] | pixels[i] !== pixels[i + 8] | pixels[i] !== pixels[i + 12]) {
				isObject = false;
				break;
			}
		}

		if (isObject) {
			return RGBToInt(pixels[0], pixels[1], pixels[2]);
		} else {
			return 0;
		}

		//window.console.log(pixels);
	}

	//extracts mouse coordinates from the event parameters
	var getMouseCoordinates = function (ev) {
		var x = 0;
		var y = 0;

		ev = ev || window.event;

		if (ev.offsetX || ev.offsetX === 0) {
			x = ev.offsetX;
			y = ev.offsetY;
		} else if (ev.layerX || ev.layerX == 0) { // Firefox
			x = ev.layerX;
			y = ev.layerY;
		}
		else {
			x = ev.pageX - ev.target.offsetLeft;
			y = ev.pageY - ev.target.offsetTop;
		}

		return { x: x, y: y };
	};

	function getFontString(prefix, object, fallbackObject) {
		var fontString = &quot;&quot;;

		var fontStyleString = prefix ? prefix + &quot;FontStyle&quot; : &quot;fontStyle&quot;;
		var fontWeightString = prefix ? prefix + &quot;FontWeight&quot; : &quot;fontWeight&quot;;
		var fontSizeString = prefix ? prefix + &quot;FontSize&quot; : &quot;fontSize&quot;;
		var fontFamilyString = prefix ? prefix + &quot;FontFamily&quot; : &quot;fontFamily&quot;;



		fontString += object[fontStyleString] ? object[fontStyleString] + &quot; &quot; : (fallbackObject &amp;&amp; fallbackObject[fontStyleString]) ? (fallbackObject[fontStyleString] + &quot; &quot;) : &quot;&quot;;
		fontString += object[fontWeightString] ? object[fontWeightString] + &quot; &quot; : (fallbackObject &amp;&amp; fallbackObject[fontWeightString]) ? (fallbackObject[fontWeightString] + &quot; &quot;) : &quot;&quot;;
		fontString += object[fontSizeString] ? object[fontSizeString] + &quot;px &quot; : (fallbackObject &amp;&amp; fallbackObject[fontSizeString]) ? (fallbackObject[fontSizeString] + &quot;px &quot;) : &quot;&quot;;


		var fontFamily = object[fontFamilyString] ? object[fontFamilyString] + &quot;&quot; : (fallbackObject &amp;&amp; fallbackObject[fontFamilyString]) ? (fallbackObject[fontFamilyString] + &quot;&quot;) : &quot;&quot;;

		if (!isCanvasSupported &amp;&amp; fontFamily) {
			var firstFontFamily = fontFamily.split(&quot;,&quot;)[0];

			if (firstFontFamily[0] !== &quot;&#x27;&quot; &amp;&amp; firstFontFamily[0] !== &quot;\&quot;&quot;)
				firstFontFamily = &quot;&#x27;&quot; + firstFontFamily + &quot;&#x27;&quot;;

			fontString += firstFontFamily;
		} else
			fontString += fontFamily;

		return fontString;
	}

	function getProperty(propertyName, object, fallbackObject) {

		var value = propertyName in object ? object[propertyName] : fallbackObject[propertyName];

		return value;
	}

	var optimizeForHiDPI = true;
	//optimizeForHiDPI = false;

	var devicePixelRatio = window.devicePixelRatio || 1;
	var backingStoreRatio = 1;
	var devicePixelBackingStoreRatio = optimizeForHiDPI ? devicePixelRatio / backingStoreRatio : 1;


	function setCanvasSize(canvas, width, height) {

		if (isCanvasSupported &amp;&amp; !!optimizeForHiDPI) {
			var ctx = canvas.getContext(&quot;2d&quot;);
			backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
								ctx.mozBackingStorePixelRatio ||
								ctx.msBackingStorePixelRatio ||
								ctx.oBackingStorePixelRatio ||
								ctx.backingStorePixelRatio || 1;


			devicePixelBackingStoreRatio = devicePixelRatio / backingStoreRatio;

			canvas.width = width * devicePixelBackingStoreRatio;
			canvas.height = height * devicePixelBackingStoreRatio;

			if (devicePixelRatio !== backingStoreRatio) {

				canvas.style.width = width + &#x27;px&#x27;;
				canvas.style.height = height + &#x27;px&#x27;;

				ctx.scale(devicePixelBackingStoreRatio, devicePixelBackingStoreRatio);

			}

			//window.alert(backingStoreRatio);
			//window.alert(devicePixelRatio);

		} else {
			canvas.width = width;
			canvas.height = height;
		}

	}


	function createCanvas(width, height) {
		var canvas = document.createElement(&quot;canvas&quot;);
		canvas.setAttribute(&quot;class&quot;, &quot;canvasjs-chart-canvas&quot;);

		setCanvasSize(canvas, width, height);

		if (!isCanvasSupported &amp;&amp; typeof (G_vmlCanvasManager) !== &quot;undefined&quot;) {
			G_vmlCanvasManager.initElement(canvas);
		}

		return canvas;
	}

	function exportCanvas(canvas, format, fileName) {
		if (!canvas || !format || !fileName)
			return;

		var fullFileName = fileName + &quot;.&quot; + format;
		var mimeType = &quot;image/&quot; + format;
		var img = canvas.toDataURL(mimeType);
		var saved = false;

		var downloadLink = document.createElement(&quot;a&quot;);
		downloadLink.download = fullFileName;
		downloadLink.href = img;
		downloadLink.target = &quot;_blank&quot;;
		var e;


		if (typeof (Blob) !== &quot;undefined&quot; &amp;&amp; !!new Blob()) {

			//alert(&quot;blob&quot;);
			var imgData = img.replace(/^data:[a-z/]*;base64,/, &#x27;&#x27;);

			var byteString = atob(imgData);
			var buffer = new ArrayBuffer(byteString.length);
			var intArray = new Uint8Array(buffer);
			for (var i = 0; i &lt; byteString.length; i++) {
				intArray[i] = byteString.charCodeAt(i);
			}

			var blob = new Blob([intArray.buffer], { type: &quot;image/&quot; + format });

			// Save the blob
			try {
				window.navigator.msSaveBlob(blob, fullFileName);
				saved = true;
			}
			catch (e) {
				downloadLink.dataset.downloadurl = [mimeType, downloadLink.download, downloadLink.href].join(&#x27;:&#x27;);
				downloadLink.href = window.URL.createObjectURL(blob);
			}
		}

		if (!saved) {

			try {

				event = document.createEvent(&quot;MouseEvents&quot;);

				event.initMouseEvent(&quot;click&quot;, true, false, window,
								 0, 0, 0, 0, 0, false, false, false,
								 false, 0, null);

				if (downloadLink.dispatchEvent) {
					//alert(&quot;dispatchEvent&quot;);
					downloadLink.dispatchEvent(event);
				}
				else if (downloadLink.fireEvent) {
					//alert(&quot;fireEvent&quot;);
					downloadLink.fireEvent(&quot;onclick&quot;);
				}

			} catch (e) {
				var win = window.open();
				//alert(&quot;&lt;IE10&quot;);
				//window.console.log(&quot;IE&quot;);
				win.document.write(&quot;&lt;img src=&#x27;&quot; + img + &quot;&#x27;&gt;&lt;/img&gt;&lt;div&gt;Please right click on the image and save it to your device&lt;/div&gt;&quot;);
				win.document.close();
			}
		}
	}

	var base64Images = {
		reset: {
			image: &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAcCAYAAAAAwr0iAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAKRSURBVEiJrdY/iF1FFMfxzwnZrGISUSR/JLGIhoh/QiRNBLWxMLIWEkwbgiAoFgoW2mhlY6dgpY2IlRBRxBSKhSAKIklWJRYuMZKAhiyopAiaTY7FvRtmZ+/ed9/zHRjezLw5v/O9d86cuZGZpmURAfdn5o9DfdZNLXpjz+LziPgyIl6MiG0jPTJzZBuyDrP4BVm0P/AKbljTb4ToY/gGewYA7KyCl+1b3DUYANvwbiHw0gCAGRzBOzjTAXEOu0cC4Ch+r5x/HrpdrcZmvIDFSucMtnYCYC++6HmNDw8FKDT34ETrf639/azOr5vwRk/g5fbeuABtgC04XWk9VQLciMP4EH/3AFzErRNC7MXlQmsesSoHsGPE23hmEoBW+61K66HMXFmIMvN8myilXS36R01ub+KfYvw43ZXwYDX+AHP4BAci4pFJomfmr/ihmNofESsBImJGk7mlncrM45n5JPbhz0kAWpsv+juxaX21YIPmVJS2uNzJMS6ZNexC0d+I7fUWXLFyz2kSZlpWPvASlmqAf/FXNXf3FAF2F/1LuFifAlionB6dRuSI2IwHi6lzmXmp6xR8XY0fiIh7psAwh+3FuDkRHQVjl+a8lkXjo0kLUKH7XaV5oO86PmZ1FTzyP4K/XGl9v/zwfbW7BriiuETGCP5ch9bc9f97HF/vcFzCa5gdEPgWq+t/4v0V63oE1uF4h0DiFJ7HnSWMppDdh1dxtsPvJ2wcBNAKbsJXa0Ck5opdaBPsRNu/usba09i1KsaAVzmLt3sghrRjuK1Tf4xkegInxwy8gKf7dKMVH2QRsV5zXR/Cftyu+aKaKbbkQrsdH+PTzLzcqzkOQAVzM+7FHdiqqe2/YT4zF/t8S/sPmawyvC974vcAAAAASUVORK5CYII=&quot;
		},
		pan: {
			image: &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAJVSURBVFiFvZe7a1RBGMV/x2hWI4JpfKCIiSBKOoOCkID/wP4BFqIIFkE02ChIiC8QDKlSiI3YqRBsBVGwUNAUdiIEUgjiAzQIIsuKJsfizsXr5t7d+8jmwLDfzHz3nLOzc7+ZxTZlGyDgZiWOCuJ9wH2gCUyuqQFgF/AGcKJNrYkBYBj40CIet+muGQi/96kM4WS7C/Tm5VUg7whJg8BkEGkCR4BDYfodsADUgP6wErO5iCtswsuJb32hdbXy8qzL5TIdmzJinHdZoZIBZcSFkGlAKs1Z3YCketZcBtouuaQNkrblMiBpBrhme7mAgU4wMCvpcFsDkq4C54DFVRTH9h+i6vlE0r5UA5ImgCuh28jB28iIs7BIVCOeStoZD64P4uPAjUTygKSx2FsK2TIwkugfk9Qkfd/E+yMWHQCeSRqx/R3gOp3LazfaS2C4B5gHDgD7U9x3E3uAH7KNpC3AHHAwTL4FHgM9GQ8vAaPA0dB/Abxqk2/gBLA9MXba9r1k/d4LfA3JtwueBeM58ucS+edXnAW23wP10N3advEi9CXizTnyN4bPS7Zn4sH/dq3t18AY4e1YLYSy3g/csj2VnFshZPuOpOeSKHCodUINuGj7YetE6je1PV9QoNPJ9StNHKodx7nRbiWrGHBGXAi5DUiqtQwtpcWK0Jubt8CltA5MEV1IfwO7+VffPwGfia5m34CT4bXujIIX0Qna1/cGMNqV/wUJE2czxD8CQ4X5Sl7Jz7SILwCDpbjKPBRMHAd+EtX4HWV5Spdc2w8kDQGPbH8py/MXMygM69/FKz4AAAAASUVORK5CYII=&quot;
		},
		zoom: {
			image: &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK6wAACusBgosNWgAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAMqSURBVFiFvdfbj91TFMDxz57U6GUEMS1aYzyMtCSSDhWjCZMInpAI3khE/QHtgzdRkXgSCS8SES9epKLi0oRKNETjRahREq2KS1stdRujtDPtbA97n5zdn9+5zJxTK9k5v3POXmt991p7r71+IcaoGwkhTOIebMRqzOBTvIG3Y4zTXRmqSoyx5cAKbMJOHMFJnMZ8/jyFaXyMR7G6nb1aH22cP4BvcBxziG3GKfyTIR9D6BYg1KUghPBCDveFlb/24Av8iuUYw41YVsz5G7uxKcZ4aMEpwGt5NY3V/YbHsQ6rcAHOw/kYxigewr5CZw4fYGxBKcCLOFEYehXrMdRhr5yLETxVScsOLOkKAPfn1TYMPIvLFrShUlS2FDZm8XRHACzFAWl3R2xbqPMCYhmeLCAOYEMngAczbcTvuHYxzguIy/FesR9e6gSwU/OoPYHBHgHgviIKX2Flq7k34KhmcVnbi/PC8JX4MgMcxb118wZwdz5aISscqx7VRcox7MrPQ7i+btIAJrAkf9+bI9EPmZY2IAxiTSuAldLq4Y9+AcSUh78KP0tbAcwU35cXMD1JCIFUoGiehlqAz6TNB1f1C0DK+0h+nsNPrQC2a4bqGmlD9kOGcWt+Po6pVgDvSxfJaSkFd4UQBvoAsBYbCoB3a2flM7slA0R8iyt6rAFDeDPbm8eOTpVwGD9qVq7nLbIaZnmksPU1JtsCZMXNmpdRxFasWITzh6Xj3LCzra1OxcD2QjHiGVzdpfORnMqZio2PcF23ABdJF1Np4BPptlyPi6WzPYBzpJZtHe7A6xW9cnyP8TqA//SEIYRL8Bxul7rihvwgtVn78WcGGZXa9HGd5TDujDHuOePXNiHdKjWgZX/YbsxLx/ktqbjVzTlcjUSnvI5JrdlUVp6WesZZ6R1hRrpq9+EVTGS9jTjYAuKIouGpbcurEkIYxC051KNSamazsc+xK8b4S0VnEi/j0hqTP+M27O258egQwZuzs7pI7Mf4WQXIEDc5s9sux+5+1Py2EmP8UOq6GvWhIScxfdYjUERiAt9Jd84J6a16zf8JEKT3yCm8g1UxRv8CC4pyRhzR1uUAAAAASUVORK5CYII=&quot;
		},
		menu: {
			image: &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAgCAYAAAAbifjMAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK6wAACusBgosNWgAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAAWdEVYdENyZWF0aW9uIFRpbWUAMDcvMTUvMTTPsvU0AAAAP0lEQVRIie2SMQoAIBDDUvH/X667g8sJJ9KOhYYOkW0qGaU1MPdC0vGSbV19EACo3YMPAFH5BUBUjsqfAPpVXtNgGDfxEDCtAAAAAElFTkSuQmCC&quot;
		}
	}

	function setButtonState(chart, button, state) {
		if (button.getAttribute(&quot;state&quot;) !== state) {

			button.setAttribute(&quot;state&quot;, state);
			button.setAttribute(&quot;type&quot;, &#x27;button&#x27;);
			button.style.position = &quot;relative&quot;;
			button.style.margin = &quot;0px 0px 0px 0px&quot;;
			button.style.padding = &quot;3px 4px 0px 4px&quot;;
			button.style.cssFloat = &quot;left&quot;;
			button.setAttribute(&quot;title&quot;, chart._cultureInfo[state + &quot;Text&quot;]);
			button.innerHTML = &quot;&lt;img style=&#x27;height:16px;&#x27; src=&#x27;&quot; + base64Images[state].image + &quot;&#x27; alt=&#x27;&quot; + chart._cultureInfo[state + &quot;Text&quot;] + &quot;&#x27; /&gt;&quot;;
		}
	}

	function show() {

		var element = null;

		for (var i = 0; i &lt; arguments.length; i++) {
			element = arguments[i];
			if (element.style)
				element.style.display = &quot;inline&quot;;
		}
	}

	function hide() {

		var element = null;

		for (var i = 0; i &lt; arguments.length; i++) {
			element = arguments[i];
			if (element &amp;&amp; element.style)
				element.style.display = &quot;none&quot;;
		}
	}

	//#endregion Static Methods &amp; variables

	//#region Class Definitions

	//#region Class CanvasJSObject
	function CanvasJSObject(defaultsKey, options, theme, parent) {
		this._defaultsKey = defaultsKey;

		this.parent = parent;

		this._eventListeners = [];//Multidimentional array with an array for each event type

		var currentThemeOptions = {};

		if (theme &amp;&amp; themes[theme] &amp;&amp; themes[theme][defaultsKey])
			currentThemeOptions = themes[theme][defaultsKey];

		this._options = options ? options : {};
		this.setOptions(this._options, currentThemeOptions);
	}

	CanvasJSObject.prototype.setOptions = function (options, currentThemeOptions) {

		if (!defaultOptions[this._defaultsKey]) {
			if (isDebugMode &amp;&amp; window.console)
				console.log(&quot;defaults not set&quot;);
		}
		else {
			var defaults = defaultOptions[this._defaultsKey];

			for (var prop in defaults) {

				if (defaults.hasOwnProperty(prop)) {
					if (options &amp;&amp; prop in options)
						this[prop] = options[prop];
					else if (currentThemeOptions &amp;&amp; prop in currentThemeOptions)
						this[prop] = currentThemeOptions[prop];
					else this[prop] = defaults[prop];

					//if (typeof this[prop] === &quot;function&quot;) {
					//    alert(&quot;function&quot;);
					//    this[prop] = this[prop]();
					//}
				}

			}
		}
	};

	// Update options. Returns true if changed or else false
	CanvasJSObject.prototype.updateOption = function (prop) {

		if (!defaultOptions[this._defaultsKey] &amp;&amp; isDebugMode &amp;&amp; window.console)
			console.log(&quot;defaults not set&quot;);

		var defaults = defaultOptions[this._defaultsKey];
		var theme = this._options.theme ? this._options.theme : (this.chart &amp;&amp; this.chart._options.theme) ? this.chart._options.theme : &quot;theme1&quot;;

		var currentThemeOptions = {};
		var newValue = this[prop];

		if (theme &amp;&amp; themes[theme] &amp;&amp; themes[theme][this._defaultsKey])
			currentThemeOptions = themes[theme][this._defaultsKey];

		if (prop in defaults) {
			if (prop in this._options)
				newValue = this._options[prop];
			else if (currentThemeOptions &amp;&amp; prop in currentThemeOptions)
				newValue = currentThemeOptions[prop];
			else newValue = defaults[prop];
		}

		if (newValue === this[prop])
			return false;

		this[prop] = newValue;
		return true;
	}

	//Stores values in _oldOptions so that it can be tracked for any changes
	CanvasJSObject.prototype.trackChanges = function (option) {
		if (!this.sessionVariables)
			throw &quot;Session Variable Store not set&quot;;

		this.sessionVariables[option] = this._options[option];
	};

	CanvasJSObject.prototype.isBeingTracked = function (option) {
		if (!this._options._oldOptions)
			this._options._oldOptions = {};

		if (this._options._oldOptions[option])
			return true;
		else
			return false;
	};

	CanvasJSObject.prototype.hasOptionChanged = function (option) {
		if (!this.sessionVariables)
			throw &quot;Session Variable Store not set&quot;;

		var hasChanged = !(this.sessionVariables[option] === this._options[option]);

		return hasChanged;
	};

	CanvasJSObject.prototype.addEventListener = function (eventName, eventHandler, context) {
		if (!eventName || !eventHandler)
			return;

		context = context || this;

		this._eventListeners[eventName] = this._eventListeners[eventName] || [];

		this._eventListeners[eventName].push({ context: context, eventHandler: eventHandler });
	}

	CanvasJSObject.prototype.removeEventListener = function (eventName, eventHandler) {
		if (!eventName || !eventHandler || !this._eventListeners[eventName])
			return;

		var listeners = this._eventListeners[eventName];
		for (var i = 0; i &lt; listeners.length; i++) {

			if (listeners[i].eventHandler === eventHandler) {
				listeners[i].splice(i, 1);
				break;
			}
		}
	}

	CanvasJSObject.prototype.removeAllEventListeners = function () {
		this._eventListeners = [];
	}

	CanvasJSObject.prototype.dispatchEvent = function (eventName, eventParameter, context) {

		//For Internal Events
		if (eventName &amp;&amp; this._eventListeners[eventName]) {

			eventParameter = eventParameter || {};

			var listeners = this._eventListeners[eventName];
			for (var i = 0; i &lt; listeners.length; i++) {

				listeners[i].eventHandler.call(listeners[i].context, eventParameter);
			}
		}

		//External Events do not require registering as the property name is suffient to fire the event.
		if (typeof (this[eventName]) === &quot;function&quot;) {
			this[eventName].call(context || this.chart._publicChartReference, eventParameter);
		}
	}

	//#endregion Class CanvasJSObject

	//#region Class Chart
	function Chart(containerId, options, publicChartReference) {

		this._publicChartReference = publicChartReference;

		options = options || {};

		Chart.base.constructor.call(this, &quot;Chart&quot;, options, options.theme ? options.theme : &quot;theme1&quot;);

		var _this = this;


		this._containerId = containerId;
		this._objectsInitialized = false;
		this.ctx = null;
		this.overlaidCanvasCtx = null;
		this._indexLabels = [];
		this._panTimerId = 0;
		this._lastTouchEventType = &quot;&quot;;
		this._lastTouchData = null;
		this.isAnimating = false;
		this.renderCount = 0;
		this.animatedRender = false;
		this.disableToolTip = false;


		this.panEnabled = false;
		this._defaultCursor = &quot;default&quot;;
		this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 };
		this._dataInRenderedOrder = [];

		this._container = typeof (this._containerId) === &quot;string&quot; ? document.getElementById(this._containerId) : this._containerId;

		if (!this._container) {
			if (window.console)
				window.console.log(&quot;CanvasJS Error: Chart Container with id \&quot;&quot; + this._containerId + &quot;\&quot; was not found&quot;);
			return;
		}

		this._container.innerHTML = &quot;&quot;;

		var width = 0;
		var height = 0;

		if (this._options.width)
			width = this.width;
		else
			width = this._container.clientWidth &gt; 0 ? this._container.clientWidth : this.width;

		if (this._options.height)
			height = this.height;
		else
			height = this._container.clientHeight &gt; 0 ? this._container.clientHeight : this.height;

		this.width = width;
		this.height = height;

		this.x1 = this.y1 = 0;
		this.x2 = this.width;
		this.y2 = this.height;


		this._selectedColorSet = typeof (colorSets[this.colorSet]) !== &quot;undefined&quot; ? colorSets[this.colorSet] : colorSets[&quot;colorSet1&quot;];

		this._canvasJSContainer = document.createElement(&quot;div&quot;);
		this._canvasJSContainer.setAttribute(&quot;class&quot;, &quot;canvasjs-chart-container&quot;);

		this._canvasJSContainer.style.position = &quot;relative&quot;;
		this._canvasJSContainer.style.textAlign = &quot;left&quot;;
		this._canvasJSContainer.style.cursor = &quot;auto&quot;;
		if (!isCanvasSupported) {
			this._canvasJSContainer.style.height = &quot;0px&quot;;//In IE6 toolTip doesn&#x27;t show at proper position if not set.
		}
		this._container.appendChild(this._canvasJSContainer);


		this.canvas = createCanvas(width, height);

		this.canvas.style.position = &quot;absolute&quot;;
		if (this.canvas.getContext) {
			//try {
			//	this.canvas.style.background = this.backgroundColor;
			//} catch (e) { }
			this._canvasJSContainer.appendChild(this.canvas);
			this.ctx = this.canvas.getContext(&quot;2d&quot;);
			this.ctx.textBaseline = &quot;top&quot;;
			extendCtx(this.ctx);
		} else
			return;

		//this.canvas.style.cursor = &quot;pointer&quot;;

		if (!isCanvasSupported) {
			this.plotArea.canvas = createCanvas(width, height);
			this.plotArea.canvas.style.position = &quot;absolute&quot;;
			this.plotArea.canvas.setAttribute(&quot;class&quot;, &quot;plotAreaCanvas&quot;);
			this._canvasJSContainer.appendChild(this.plotArea.canvas);

			this.plotArea.ctx = this.plotArea.canvas.getContext(&quot;2d&quot;);
		} else {
			this.plotArea.ctx = this.ctx;
		}

		this.overlaidCanvas = createCanvas(width, height);
		this.overlaidCanvas.style.position = &quot;absolute&quot;;
		this._canvasJSContainer.appendChild(this.overlaidCanvas);
		this.overlaidCanvasCtx = this.overlaidCanvas.getContext(&quot;2d&quot;);
		this.overlaidCanvasCtx.textBaseline = &quot;top&quot;;

		this._eventManager = new EventManager(this);

		addEvent(window, &quot;resize&quot;, function () {
			//this._container.addEventListener(&quot;DOMSubtreeModified&quot;, function () {

			if (_this._updateSize())
				_this.render();
		});


		this._toolBar = document.createElement(&quot;div&quot;);
		this._toolBar.setAttribute(&quot;class&quot;, &quot;canvasjs-chart-toolbar&quot;);
		this._toolBar.style.cssText = &quot;position: absolute; right: 1px; top: 1px;&quot;;
		this._canvasJSContainer.appendChild(this._toolBar);


		this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height };

		addEvent(this.overlaidCanvas, &#x27;click&#x27;, function (e) {
			_this._mouseEventHandler(e);
		});

		addEvent(this.overlaidCanvas, &#x27;mousemove&#x27;, function (e) {
			_this._mouseEventHandler(e);
		});

		addEvent(this.overlaidCanvas, &#x27;mouseup&#x27;, function (e) {
			_this._mouseEventHandler(e);
		});

		addEvent(this.overlaidCanvas, &#x27;mousedown&#x27;, function (e) {
			_this._mouseEventHandler(e);
			hide(_this._dropdownMenu);
		});

		addEvent(this.overlaidCanvas, &#x27;mouseout&#x27;, function (e) {
			_this._mouseEventHandler(e);
		});


		addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? &quot;MSPointerDown&quot; : &quot;touchstart&quot;, function (e) {
			_this._touchEventHandler(e);
		});

		addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? &quot;MSPointerMove&quot; : &#x27;touchmove&#x27;, function (e) {
			_this._touchEventHandler(e);
		});

		addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? &quot;MSPointerUp&quot; : &#x27;touchend&#x27;, function (e) {
			_this._touchEventHandler(e);
		});

		addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? &quot;MSPointerCancel&quot; : &#x27;touchcancel&#x27;, function (e) {
			_this._touchEventHandler(e);
		});

		if (!this._creditLink) {
			this._creditLink = document.createElement(&quot;a&quot;);
			this._creditLink.setAttribute(&quot;class&quot;, &quot;canvasjs-chart-credit&quot;);
			this._creditLink.setAttribute(&quot;style&quot;, &quot;outline:none;margin:0px;position:absolute;right:3px;top:&quot; + (this.height - 14) + &quot;px;color:dimgrey;text-decoration:none;font-size:10px;font-family:Lucida Grande, Lucida Sans Unicode, Arial, sans-serif&quot;);

			this._creditLink.setAttribute(&quot;tabIndex&quot;, -1);

			this._creditLink.setAttribute(&quot;target&quot;, &quot;_blank&quot;);
		}

		this._toolTip = new ToolTip(this, this._options.toolTip, this.theme);


		this.data = null;
		this.axisX = null;
		this.axisY = null;
		this.axisY2 = null;



		this.sessionVariables = {
			axisX: {},
			axisY: {},
			axisY2: {}
		};
	}

	extend(Chart, CanvasJSObject);

	//Update Chart Properties
	Chart.prototype._updateOptions = function () {
		var _this = this;

		this.updateOption(&quot;width&quot;);
		this.updateOption(&quot;height&quot;);

		this.updateOption(&quot;dataPointWidth&quot;);
		this.updateOption(&quot;dataPointMinWidth&quot;);
		this.updateOption(&quot;dataPointMaxWidth&quot;);

		this.updateOption(&quot;interactivityEnabled&quot;);
		this.updateOption(&quot;theme&quot;);

		if (this.updateOption(&quot;colorSet&quot;))
			this._selectedColorSet = typeof (colorSets[this.colorSet]) !== &quot;undefined&quot; ? colorSets[this.colorSet] : colorSets[&quot;colorSet1&quot;];

		this.updateOption(&quot;backgroundColor&quot;);
		if (!this.backgroundColor)
			this.backgroundColor = &quot;rgba(0,0,0,0)&quot;;

		this.updateOption(&quot;culture&quot;);
		this._cultureInfo = new CultureInfo(this._options.culture);

		this.updateOption(&quot;animationEnabled&quot;);
		this.animationEnabled = this.animationEnabled &amp;&amp; isCanvasSupported;
		this.updateOption(&quot;animationDuration&quot;);

		this.updateOption(&quot;rangeChanging&quot;);
		this.updateOption(&quot;rangeChanged&quot;);

		this.updateOption(&quot;exportEnabled&quot;);
		this.updateOption(&quot;exportFileName&quot;);

		this.updateOption(&quot;zoomType&quot;);

		//Need to check this._options.zoomEnabled because this.zoomEnabled is used internally to keep track of state - and hence changes.
		if (this._options.zoomEnabled) {

			if (!this._zoomButton) {

				hide(this._zoomButton = document.createElement(&quot;button&quot;));

				setButtonState(this, this._zoomButton, &quot;pan&quot;);

				this._toolBar.appendChild(this._zoomButton);
				addEvent(this._zoomButton, &quot;click&quot;, function () {
					if (_this.zoomEnabled) {
						_this.zoomEnabled = false;
						_this.panEnabled = true;

						setButtonState(_this, _this._zoomButton, &quot;zoom&quot;);

					} else {
						_this.zoomEnabled = true;
						_this.panEnabled = false;

						setButtonState(_this, _this._zoomButton, &quot;pan&quot;);
					}

					_this.render();
				});
			}


			if (!this._resetButton) {
				hide(this._resetButton = document.createElement(&quot;button&quot;));
				setButtonState(this, this._resetButton, &quot;reset&quot;);
				this._toolBar.appendChild(this._resetButton);

				addEvent(this._resetButton, &quot;click&quot;, function () {

					_this._toolTip.hide();

					if (_this.zoomEnabled || _this.panEnabled) {
						_this.zoomEnabled = true;
						_this.panEnabled = false;
						setButtonState(_this, _this._zoomButton, &quot;pan&quot;);

						_this._defaultCursor = &quot;default&quot;;
						_this.overlaidCanvas.style.cursor = _this._defaultCursor;
					} else {
						_this.zoomEnabled = false;
						_this.panEnabled = false;
					}
					//Reset axisX
					if (_this.sessionVariables.axisX) {
						_this.sessionVariables.axisX.newViewportMinimum = null;
						_this.sessionVariables.axisX.newViewportMaximum = null;
					}

					//Reset axisY
					if (_this.sessionVariables.axisY) {
						_this.sessionVariables.axisY.newViewportMinimum = null;
						_this.sessionVariables.axisY.newViewportMaximum = null;
					}

					//Reset axisY2
					if (_this.sessionVariables.axisY2) {
						_this.sessionVariables.axisY2.newViewportMinimum = null;
						_this.sessionVariables.axisY2.newViewportMaximum = null;
					}

					_this.resetOverlayedCanvas();

					hide(_this._zoomButton, _this._resetButton);

					_this._dispatchRangeEvent(&quot;rangeChanging&quot;, &quot;reset&quot;);
					_this.render();
					_this._dispatchRangeEvent(&quot;rangeChanged&quot;, &quot;reset&quot;);
				});

				this.overlaidCanvas.style.cursor = _this._defaultCursor;
			}

			if (!this.zoomEnabled &amp;&amp; !this.panEnabled) {
				if (!this._zoomButton) {
					this.zoomEnabled = true;
					this.panEnabled = false;
				} else {

					if (_this._zoomButton.getAttribute(&quot;state&quot;) === _this._cultureInfo.zoomText) {
						this.panEnabled = true;
						this.zoomEnabled = false;
					}
					else {
						this.zoomEnabled = true;
						this.panEnabled = false;
					}

					show(_this._zoomButton, _this._resetButton);
				}
			}



		} else {
			this.zoomEnabled = false;
			this.panEnabled = false;
		}



		if (this._menuButton) {
			if (this.exportEnabled)
				show(this._menuButton);
			else
				hide(this._menuButton);
		} else if (this.exportEnabled &amp;&amp; isCanvasSupported) {
			this._menuButton = document.createElement(&quot;button&quot;);
			setButtonState(this, this._menuButton, &quot;menu&quot;);
			this._toolBar.appendChild(this._menuButton);

			addEvent(this._menuButton, &quot;click&quot;, function () {
				if (_this._dropdownMenu.style.display === &quot;none&quot;) {

					if (_this._dropDownCloseTime &amp;&amp; ((new Date()).getTime() - _this._dropDownCloseTime.getTime() &lt;= 500))
						return;

					_this._dropdownMenu.style.display = &quot;block&quot;;
					_this._menuButton.blur();
					_this._dropdownMenu.focus();
				}

			}, true);
		}


		if (!this._dropdownMenu &amp;&amp; this.exportEnabled &amp;&amp; isCanvasSupported) {
			this._dropdownMenu = document.createElement(&quot;div&quot;);
			this._dropdownMenu.setAttribute(&quot;tabindex&quot;, -1);
			this._dropdownMenu.style.cssText = &quot;position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 1px;top: 25px;min-width: 120px;outline: 0;border: 1px solid silver;font-size: 14px;font-family: Calibri, Verdana, sans-serif;padding: 5px 0px 5px 0px;text-align: left;background-color: #fff;line-height: 20px;box-shadow: 2px 2px 10px #888888;&quot;;
			_this._dropdownMenu.style.display = &quot;none&quot;;
			this._toolBar.appendChild(this._dropdownMenu);

			addEvent(this._dropdownMenu, &quot;blur&quot;, function () {
				hide(_this._dropdownMenu);

				_this._dropDownCloseTime = new Date();
			}, true);

			var exportOption = document.createElement(&quot;div&quot;);
			exportOption.style.cssText = &quot;padding: 2px 15px 2px 10px&quot;
			exportOption.innerHTML = this._cultureInfo.saveJPGText;
			this._dropdownMenu.appendChild(exportOption);

			addEvent(exportOption, &quot;mouseover&quot;, function () {
				this.style.backgroundColor = &quot;#EEEEEE&quot;;
			}, true);

			addEvent(exportOption, &quot;mouseout&quot;, function () {
				this.style.backgroundColor = &quot;transparent&quot;;
			}, true);

			addEvent(exportOption, &quot;click&quot;, function () {
				exportCanvas(_this.canvas, &quot;jpeg&quot;, _this.exportFileName);
				hide(_this._dropdownMenu);
			}, true);

			var exportOption = document.createElement(&quot;div&quot;);
			exportOption.style.cssText = &quot;padding: 2px 15px 2px 10px&quot;
			exportOption.innerHTML = this._cultureInfo.savePNGText;
			this._dropdownMenu.appendChild(exportOption);

			addEvent(exportOption, &quot;mouseover&quot;, function () {
				this.style.backgroundColor = &quot;#EEEEEE&quot;;
			}, true);

			addEvent(exportOption, &quot;mouseout&quot;, function () {
				this.style.backgroundColor = &quot;transparent&quot;;
			}, true);

			addEvent(exportOption, &quot;click&quot;, function () {
				exportCanvas(_this.canvas, &quot;png&quot;, _this.exportFileName);
				hide(_this._dropdownMenu);
			}, true);
		}


		if (this._toolBar.style.display !== &quot;none&quot; &amp;&amp; this._zoomButton) {

			this.panEnabled ? setButtonState(_this, _this._zoomButton, &quot;zoom&quot;) : setButtonState(_this, _this._zoomButton, &quot;pan&quot;);


			if (_this._resetButton.getAttribute(&quot;state&quot;) !== _this._cultureInfo.resetText)
				setButtonState(_this, _this._resetButton, &quot;reset&quot;);
		}

		if (typeof (defaultOptions.Chart.creditHref) === &quot;undefined&quot;) {
			this.creditHref = &quot;http://canvasjs.com/&quot;;
			this.creditText = &quot;CanvasJS.com&quot;;
		} else {
			var creditTextChanged = this.updateOption(&quot;creditText&quot;);
			var creditHrefChanged = this.updateOption(&quot;creditHref&quot;);
		}

		if (this.renderCount === 0 || (creditTextChanged || creditHrefChanged)) {
			this._creditLink.setAttribute(&quot;href&quot;, this.creditHref);
			this._creditLink.innerHTML = this.creditText;
		}

		if (this.creditHref &amp;&amp; this.creditText) {
			if (!this._creditLink.parentElement)
				this._canvasJSContainer.appendChild(this._creditLink);
		}
		else if (this._creditLink.parentElement)
			this._canvasJSContainer.removeChild(this._creditLink);

		if (this._options.toolTip &amp;&amp; this._toolTip._options !== this._options.toolTip)
			this._toolTip._options = this._options.toolTip

		for (var prop in this._toolTip._options) {

			if (this._toolTip._options.hasOwnProperty(prop)) {
				this._toolTip.updateOption(prop);
			}
		}

	}

	Chart.prototype._updateSize = function () {
		var width = 0;
		var height = 0;

		if (this._options.width)
			width = this.width;
		else
			this.width = width = this._container.clientWidth &gt; 0 ? this._container.clientWidth : this.width;

		if (this._options.height)
			height = this.height;
		else
			this.height = height = this._container.clientHeight &gt; 0 ? this._container.clientHeight : this.height;

		if (this.canvas.width !== width * devicePixelBackingStoreRatio || this.canvas.height !== height * devicePixelBackingStoreRatio) {
			setCanvasSize(this.canvas, width, height);

			setCanvasSize(this.overlaidCanvas, width, height);
			setCanvasSize(this._eventManager.ghostCanvas, width, height);

			return true;
		}

		return false;
	}

	// initialize chart objects
	Chart.prototype._initialize = function () {
		///&lt;signature&gt;
		///&lt;summary&gt;Initializes Chart objects/state. Creates DataSeries class instance for each DataSeries provided by ther user. Sets the Axis Type based on the user data&lt;/summary&gt;
		///&lt;/signature&gt;
		//this.width = this.width;

		if (!this._animator)
			this._animator = new Animator(this);
		else {
			this._animator.cancelAllAnimations();
		}

		this.removeAllEventListeners();

		this.disableToolTip = false;

		this._axes = [];

		this.pieDoughnutClickHandler = null;
		//this._touchCurrentCoordinates = null;

		if (this.animationRequestId)
			this.cancelRequestAnimFrame.call(window, this.animationRequestId);

		this._updateOptions();

		this.animatedRender = isCanvasSupported &amp;&amp; this.animationEnabled &amp;&amp; (this.renderCount === 0);

		this._updateSize();

		//this._selectedColorSet = colorSets[&quot;colorSet2&quot;];

		//this.ctx.clearRect(0, 0, this.width, this.height);
		this.clearCanvas();
		this.ctx.beginPath();

		this.axisX = null;
		this.axisY = null;
		this.axisY2 = null;
		this._indexLabels = [];
		this._dataInRenderedOrder = [];

		this._events = [];
		if (this._eventManager)
			this._eventManager.reset();

		this.plotInfo = {
			axisPlacement: null,
			axisXValueType: null,
			plotTypes: []//array of plotType: {type:&quot;&quot;, axisYType: &quot;primary&quot;, dataSeriesIndexes:[]}
		};

		this.layoutManager = new LayoutManager(0, 0, this.width, this.height, 2);

		if (this.plotArea.layoutManager)
			this.plotArea.layoutManager.reset();


		this.data = [];
		var dataSeriesIndex = 0;

		if (this._options.data) {
			for (var series = 0; series &lt; this._options.data.length; series++) {
				//for (series in this._options.data) {

				dataSeriesIndex++;

				if (!(!this._options.data[series].type || Chart._supportedChartTypes.indexOf(this._options.data[series].type) &gt;= 0))
					continue;

				var dataSeries = new DataSeries(this, this._options.data[series], this.theme, dataSeriesIndex - 1, ++this._eventManager.lastObjectId);
				if (dataSeries.name === null)
					dataSeries.name = &quot;DataSeries &quot; + (dataSeriesIndex);

				if (dataSeries.color === null) {
					if (this._options.data.length &gt; 1) {
						dataSeries._colorSet = [this._selectedColorSet[dataSeries.index % this._selectedColorSet.length]];
						dataSeries.color = this._selectedColorSet[dataSeries.index % this._selectedColorSet.length];
					} else {
						if (dataSeries.type === &quot;line&quot; || dataSeries.type === &quot;stepLine&quot; || dataSeries.type === &quot;spline&quot; || dataSeries.type === &quot;area&quot;
							|| dataSeries.type === &quot;stepArea&quot; || dataSeries.type === &quot;splineArea&quot; || dataSeries.type === &quot;stackedArea&quot; || dataSeries.type === &quot;stackedArea100&quot;
							|| dataSeries.type === &quot;rangeArea&quot; || dataSeries.type === &quot;rangeSplineArea&quot; || dataSeries.type === &quot;candlestick&quot; || dataSeries.type === &quot;ohlc&quot;) {
							dataSeries._colorSet = [this._selectedColorSet[0]];
						}
						else
							dataSeries._colorSet = this._selectedColorSet;
					}
				} else {
					dataSeries._colorSet = [dataSeries.color];
				}

				if (dataSeries.markerSize === null) {
					if (((dataSeries.type === &quot;line&quot; || dataSeries.type === &quot;stepLine&quot; || dataSeries.type === &quot;spline&quot; || dataSeries.type.toLowerCase().indexOf(&quot;area&quot;) &gt;= 0) &amp;&amp; dataSeries.dataPoints &amp;&amp; dataSeries.dataPoints.length &lt; this.width / 16) || dataSeries.type === &quot;scatter&quot;) {
						//if (dataSeries.type === &quot;line&quot;) {
						dataSeries.markerSize = 8;
					}
				}

				if ((dataSeries.type === &quot;bubble&quot; || dataSeries.type === &quot;scatter&quot;) &amp;&amp; dataSeries.dataPoints) {
					if (dataSeries.dataPoints.some) {
						if (dataSeries.dataPoints.some(function (element) { return element.x; }))
							dataSeries.dataPoints.sort(compareDataPointX);
					}
					else
						dataSeries.dataPoints.sort(compareDataPointX);
				}

				this.data.push(dataSeries);

				var seriesAxisPlacement = dataSeries.axisPlacement;

				var errorMessage;

				if (seriesAxisPlacement === &quot;normal&quot;) {

					if (this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
						errorMessage = &quot;You cannot combine \&quot;&quot; + dataSeries.type + &quot;\&quot; with bar chart&quot;;
					} else if (this.plotInfo.axisPlacement === &quot;none&quot;) {
						errorMessage = &quot;You cannot combine \&quot;&quot; + dataSeries.type + &quot;\&quot; with pie chart&quot;;
					} else if (this.plotInfo.axisPlacement === null)
						this.plotInfo.axisPlacement = &quot;normal&quot;;
				}
				else if (seriesAxisPlacement === &quot;xySwapped&quot;) {

					if (this.plotInfo.axisPlacement === &quot;normal&quot;) {
						errorMessage = &quot;You cannot combine \&quot;&quot; + dataSeries.type + &quot;\&quot; with line, area, column or pie chart&quot;;
					} else if (this.plotInfo.axisPlacement === &quot;none&quot;) {
						errorMessage = &quot;You cannot combine \&quot;&quot; + dataSeries.type + &quot;\&quot; with pie chart&quot;;
					} else if (this.plotInfo.axisPlacement === null)
						this.plotInfo.axisPlacement = &quot;xySwapped&quot;;
				}
				else if (seriesAxisPlacement == &quot;none&quot;) {

					if (this.plotInfo.axisPlacement === &quot;normal&quot;) {
						errorMessage = &quot;You cannot combine \&quot;&quot; + dataSeries.type + &quot;\&quot; with line, area, column or bar chart&quot;;
					} else if (this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
						errorMessage = &quot;You cannot combine \&quot;&quot; + dataSeries.type + &quot;\&quot; with bar chart&quot;;
					} else if (this.plotInfo.axisPlacement === null)
						this.plotInfo.axisPlacement = &quot;none&quot;;
				}

				if (errorMessage &amp;&amp; window.console) {
					window.console.log(errorMessage);
					return;
				}
			}
		}
		//if (isDebugMode &amp;&amp; window.console) {
		//    window.console.log(&quot;xMin: &quot; + this.plotInfo.viewPortXMin + &quot;; xMax: &quot; + this.plotInfo.viewPortXMax + &quot;; yMin: &quot; + this.plotInfo.yMin + &quot;; yMax: &quot; + this.plotInfo.yMax);
		//}

		this._objectsInitialized = true;
	}

	//indexOf is not supported in IE8-
	Chart._supportedChartTypes = addArrayIndexOf([&quot;line&quot;, &quot;stepLine&quot;, &quot;spline&quot;, &quot;column&quot;, &quot;area&quot;, &quot;stepArea&quot;, &quot;splineArea&quot;, &quot;bar&quot;, &quot;bubble&quot;, &quot;scatter&quot;,
		&quot;stackedColumn&quot;, &quot;stackedColumn100&quot;, &quot;stackedBar&quot;, &quot;stackedBar100&quot;,
		&quot;stackedArea&quot;, &quot;stackedArea100&quot;,
		&quot;candlestick&quot;,
		&quot;ohlc&quot;,
		&quot;rangeColumn&quot;,
		&quot;rangeBar&quot;,
		&quot;rangeArea&quot;,
		&quot;rangeSplineArea&quot;,
		&quot;pie&quot;, &quot;doughnut&quot;, &quot;funnel&quot;
	]);

	Chart.prototype.render = function (options) {
		if (options)
			this._options = options;



		this._initialize();
		var plotAreaElements = []; //Elements to be rendered inside the plotArea

		//Create Primary and Secondary axis and assign them to the series
		for (var i = 0; i &lt; this.data.length; i++) {

			if (this.plotInfo.axisPlacement === &quot;normal&quot; || this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
				if (!this.data[i].axisYType || this.data[i].axisYType === &quot;primary&quot;) {
					if (!this.axisY) {

						if (this.plotInfo.axisPlacement === &quot;normal&quot;) {
							this._axes.push(this.axisY = new Axis(this, this._options.axisY, &quot;axisY&quot;, &quot;left&quot;));
						}
						else if (this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
							this._axes.push(this.axisY = new Axis(this, this._options.axisY, &quot;axisY&quot;, &quot;bottom&quot;));
						}
					}
					this.data[i].axisY = this.axisY;
				}
				else if (this.data[i].axisYType === &quot;secondary&quot;) {
					if (!this.axisY2) {
						if (this.plotInfo.axisPlacement === &quot;normal&quot;) {
							this._axes.push(this.axisY2 = new Axis(this, this._options.axisY2, &quot;axisY&quot;, &quot;right&quot;));
						}
						else if (this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
							this._axes.push(this.axisY2 = new Axis(this, this._options.axisY2, &quot;axisY&quot;, &quot;top&quot;));
						}
					}
					this.data[i].axisY = this.axisY2;
				}

				if (!this.axisX) {
					if (this.plotInfo.axisPlacement === &quot;normal&quot;) {
						this._axes.push(this.axisX = new Axis(this, this._options.axisX, &quot;axisX&quot;, &quot;bottom&quot;));
					} else if (this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
						this._axes.push(this.axisX = new Axis(this, this._options.axisX, &quot;axisX&quot;, &quot;left&quot;));
					}
				}

				this.data[i].axisX = this.axisX;
			}
		}

		//If Both Primary and Secondary axis are present, disable gridlines for one of them unless the user has set value for both
		if (this.axisY &amp;&amp; this.axisY2) {
			if (this.axisY.gridThickness &gt; 0 &amp;&amp; typeof (this.axisY2._options.gridThickness) === &quot;undefined&quot;)
				this.axisY2.gridThickness = 0;
			else if (this.axisY2.gridThickness &gt; 0 &amp;&amp; typeof (this.axisY._options.gridThickness) === &quot;undefined&quot;)
				this.axisY.gridThickness = 0;
		}


		//Show toolBar when viewportMinimum/viewportMaximum are set
		var showToolBar = false;
		if (this._axes.length &gt; 0 &amp;&amp; (this.zoomEnabled || this.panEnabled)) {
			for (var i = 0; i &lt; this._axes.length; i++) {
				if (this._axes[i].viewportMinimum !== null || this._axes[i].viewportMaximum !== null) {
					showToolBar = true;
					break;
				}
			}
		}

		if (showToolBar) {
			show(this._zoomButton, this._resetButton);
		} else {
			hide(this._zoomButton, this._resetButton);
			if (this._options.zoomEnabled) {
				this.zoomEnabled = true;
				this.panEnabled = false;
			}
		}


		this._processData();// Categorises the dataSeries and calculates min, max and other values

		if (this._options.title) {
			this._title = new Title(this, this._options.title);

			if (!this._title.dockInsidePlotArea)
				this._title.render();
			else
				plotAreaElements.push(this._title);
		}

		if (this._options.subtitles) {
			for (var i = 0; i &lt; this._options.subtitles.length; i++) {

				this.subtitles = [];

				var subtitle = new Subtitle(this, this._options.subtitles[i]);
				this.subtitles.push(subtitle);

				if (!subtitle.dockInsidePlotArea)
					subtitle.render();
				else
					plotAreaElements.push(subtitle);
			}
		}

		this.legend = new Legend(this, this._options.legend, this.theme);
		for (var i = 0; i &lt; this.data.length; i++) {
			if (this.data[i].showInLegend || this.data[i].type === &quot;pie&quot; || this.data[i].type === &quot;doughnut&quot;) {
				this.legend.dataSeries.push(this.data[i]);
			}
		}

		if (!this.legend.dockInsidePlotArea)
			this.legend.render();
		else
			plotAreaElements.push(this.legend);

		//TBI: Revisit and check if the functionality is enough.
		if (this.plotInfo.axisPlacement === &quot;normal&quot; || this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {

			//var freeSpace = this.layoutManager.getFreeSpace();

			Axis.setLayoutAndRender(this.axisX, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());
		} else if (this.plotInfo.axisPlacement === &quot;none&quot;) {
			//In case of charts with axis this method is called inside setLayoutAndRender
			this.preparePlotArea();
		}
		else {
			return;
		}

		for (var index = 0; index &lt; plotAreaElements.length; index++) {
			plotAreaElements[index].render();
		}

		var animations = [];
		if (this.animatedRender) {
			var initialState = createCanvas(this.width, this.height);
			var initialStateCtx = initialState.getContext(&quot;2d&quot;);
			initialStateCtx.drawImage(this.canvas, 0, 0, this.width, this.height);
		}

		for (var i = 0; i &lt; this.plotInfo.plotTypes.length; i++) {
			var plotType = this.plotInfo.plotTypes[i];

			for (var j = 0; j &lt; plotType.plotUnits.length; j++) {

				var plotUnit = plotType.plotUnits[j];
				var animationInfo = null;

				plotUnit.targetCanvas = null; //In case chart updates before the animation is complete, previous canvases need to be removed

				if (this.animatedRender) {
					plotUnit.targetCanvas = createCanvas(this.width, this.height);
					plotUnit.targetCanvasCtx = plotUnit.targetCanvas.getContext(&quot;2d&quot;);
				}

				if (plotUnit.type === &quot;line&quot;)
					animationInfo = this.renderLine(plotUnit);
				else if (plotUnit.type === &quot;stepLine&quot;)
					animationInfo = this.renderStepLine(plotUnit);
				else if (plotUnit.type === &quot;spline&quot;)
					animationInfo = this.renderSpline(plotUnit);
				else if (plotUnit.type === &quot;column&quot;)
					animationInfo = this.renderColumn(plotUnit);
				else if (plotUnit.type === &quot;bar&quot;)
					animationInfo = this.renderBar(plotUnit);
				else if (plotUnit.type === &quot;area&quot;)
					animationInfo = this.renderArea(plotUnit);
				else if (plotUnit.type === &quot;stepArea&quot;)
					animationInfo = this.renderStepArea(plotUnit);
				else if (plotUnit.type === &quot;splineArea&quot;)
					animationInfo = this.renderSplineArea(plotUnit);
				else if (plotUnit.type === &quot;stackedColumn&quot;)
					animationInfo = this.renderStackedColumn(plotUnit);
				else if (plotUnit.type === &quot;stackedColumn100&quot;)
					animationInfo = this.renderStackedColumn100(plotUnit);
				else if (plotUnit.type === &quot;stackedBar&quot;)
					animationInfo = this.renderStackedBar(plotUnit);
				else if (plotUnit.type === &quot;stackedBar100&quot;)
					animationInfo = this.renderStackedBar100(plotUnit);
				else if (plotUnit.type === &quot;stackedArea&quot;)
					animationInfo = this.renderStackedArea(plotUnit);
				else if (plotUnit.type === &quot;stackedArea100&quot;)
					animationInfo = this.renderStackedArea100(plotUnit);
				else if (plotUnit.type === &quot;bubble&quot;)
					animationInfo = animationInfo = this.renderBubble(plotUnit);
				else if (plotUnit.type === &quot;scatter&quot;)
					animationInfo = this.renderScatter(plotUnit);
				else if (plotUnit.type === &quot;pie&quot;)
					this.renderPie(plotUnit);
				else if (plotUnit.type === &quot;doughnut&quot;)
					this.renderPie(plotUnit);
				else if (plotUnit.type === &quot;candlestick&quot;)
					animationInfo = this.renderCandlestick(plotUnit);
				else if (plotUnit.type === &quot;ohlc&quot;)
					animationInfo = this.renderCandlestick(plotUnit);
				else if (plotUnit.type === &quot;rangeColumn&quot;)
					animationInfo = this.renderRangeColumn(plotUnit);
				else if (plotUnit.type === &quot;rangeBar&quot;)
					animationInfo = this.renderRangeBar(plotUnit);
				else if (plotUnit.type === &quot;rangeArea&quot;)
					animationInfo = this.renderRangeArea(plotUnit);
				else if (plotUnit.type === &quot;rangeSplineArea&quot;)
					animationInfo = this.renderRangeSplineArea(plotUnit);

				for (var k = 0; k &lt; plotUnit.dataSeriesIndexes.length; k++) {
					this._dataInRenderedOrder.push(this.data[plotUnit.dataSeriesIndexes[k]]);
				}

				if (this.animatedRender &amp;&amp; animationInfo)
					animations.push(animationInfo);
			}
		}

		if (this.animatedRender &amp;&amp; this._indexLabels.length &gt; 0) {
			var indexLabelCanvas = createCanvas(this.width, this.height);
			var indexLabelCanvasCtx = indexLabelCanvas.getContext(&quot;2d&quot;);
			animations.push(this.renderIndexLabels(indexLabelCanvasCtx));
		}

		var _this = this;

		if (animations.length &gt; 0) {
			//var animationCount = 0;
			_this.disableToolTip = true;
			_this._animator.animate(200, _this.animationDuration, function (fractionComplete) {

				//console.log(fractionComplete);
				//animationCount++;

				_this.ctx.clearRect(0, 0, _this.width, _this.height);


				//  _this.ctx.drawImage(initialState, 0, 0, _this.width * devicePixelBackingStoreRatio, _this.height * devicePixelBackingStoreRatio, 0, 0, _this.width, _this.height);                
				_this.ctx.drawImage(initialState, 0, 0, Math.floor(_this.width * devicePixelBackingStoreRatio), Math.floor(_this.height * devicePixelBackingStoreRatio), 0, 0, _this.width, _this.height);

				for (var l = 0; l &lt; animations.length; l++) {

					animationInfo = animations[l];

					if (fractionComplete &lt; 1 &amp;&amp; typeof (animationInfo.startTimePercent) !== &quot;undefined&quot;) {
						if (fractionComplete &gt;= animationInfo.startTimePercent) {
							//animationInfo.animationCallback(AnimationHelper.easing.linear(fractionComplete - animationInfo.startTimePercent, 0, 1, 1 - animationInfo.startTimePercent), animationInfo);

							animationInfo.animationCallback(animationInfo.easingFunction(fractionComplete - animationInfo.startTimePercent, 0, 1, 1 - animationInfo.startTimePercent), animationInfo);
						}
					} else {

						animationInfo.animationCallback(animationInfo.easingFunction(fractionComplete, 0, 1, 1), animationInfo);
					}
				}

				_this.dispatchEvent(&quot;dataAnimationIterationEnd&quot;,
									{
										chart: _this
									});

			}, function () {

				animations = [];

				var count = 0;

				//Delete all render target canvases used for animation.
				for (var i = 0; i &lt; _this.plotInfo.plotTypes.length; i++) {
					var plotType = _this.plotInfo.plotTypes[i];

					for (var j = 0; j &lt; plotType.plotUnits.length; j++) {
						var plotUnit = plotType.plotUnits[j];
						plotUnit.targetCanvas = null;
					}
				}

				initialState = null;
				_this.disableToolTip = false;
				//console.log(&quot;*********** Animation Complete - &quot; + animationCount + &quot; ***********&quot;);

			});
		} else {
			if (_this._indexLabels.length &gt; 0)
				_this.renderIndexLabels();

			_this.dispatchEvent(&quot;dataAnimationIterationEnd&quot;,
					{
						chart: _this
					});
		}

		this.attachPlotAreaEventHandlers();

		if (!this.zoomEnabled &amp;&amp; !this.panEnabled &amp;&amp; this._zoomButton &amp;&amp; this._zoomButton.style.display !== &quot;none&quot;) {
			hide(this._zoomButton, this._resetButton);
		}

		this._toolTip._updateToolTip();

		this.renderCount++;

		//if (window.console) {
		//    window.console.log(new Date().getTime() - dt);
		//}

		if (isDebugMode) {

			var _this = this;
			setTimeout(function () {
				var ghostCanvasCopy = document.getElementById(&quot;ghostCanvasCopy&quot;);

				if (ghostCanvasCopy) {
					//console.log(ghostCanvasCopy.clientWidth);
					setCanvasSize(ghostCanvasCopy, _this.width, _this.height);
					var ghostCanvasCopyCtx = ghostCanvasCopy.getContext(&quot;2d&quot;);

					//ghostCanvasCopyCtx.scale(1, 1);
					//var imageData = this._eventManager.ghostCtx.getImageData(0, 0, this._container.clientWidth, this._container.clientHeight);
					//this._eventManager.ghostCtx.drawImage(this._eventManager.ghostCanvas, 0, 0);
					//this.ctx.drawImage(this._eventManager.ghostCanvas, 0, 0);

					ghostCanvasCopyCtx.drawImage(_this._eventManager.ghostCanvas, 0, 0);
					//_this._canvasJSContainer.appendChild(_this._eventManager.ghostCanvas);
					//_this.overlaidCanvasCtx.drawImage(_this._eventManager.ghostCanvas, 0, 0);
				}
			}, 2000);
		}
	}

	Chart.prototype.attachPlotAreaEventHandlers = function () {

		//this._toolBar.style.display = &quot;inline&quot;;

		this.attachEvent({
			context: this,
			chart: this,
			mousedown: this._plotAreaMouseDown,
			mouseup: this._plotAreaMouseUp,
			mousemove: this._plotAreaMouseMove,
			cursor: this.zoomEnabled ? &quot;col-resize&quot; : &quot;move&quot;,
			cursor: this.panEnabled ? &quot;move&quot; : &quot;default&quot;,
			capture: true,
			bounds: this.plotArea
		});

	}

	Chart.prototype.categoriseDataSeries = function () {
		var dataSeries = &quot;&quot;;

		for (var i = 0; i &lt; this.data.length; i++) {
			dataSeries = this.data[i]
			if (!dataSeries.dataPoints || dataSeries.dataPoints.length === 0 || !dataSeries.visible)
				continue;

			if (Chart._supportedChartTypes.indexOf(dataSeries.type) &gt;= 0) {

				var plotType = null;
				var plotTypeExists = false;

				var plotUnit = null;
				var plotUnitExists = false;

				for (var j = 0; j &lt; this.plotInfo.plotTypes.length; j++) {
					if (this.plotInfo.plotTypes[j].type === dataSeries.type) {
						plotTypeExists = true;
						var plotType = this.plotInfo.plotTypes[j];
						break;
					}
				}

				if (!plotTypeExists) {
					plotType = {
						type: dataSeries.type,
						totalDataSeries: 0,
						plotUnits: []
					};
					this.plotInfo.plotTypes.push(plotType)
				}

				for (var j = 0; j &lt; plotType.plotUnits.length; j++) {
					if (plotType.plotUnits[j].axisYType === dataSeries.axisYType) {
						plotUnitExists = true;
						var plotUnit = plotType.plotUnits[j];
						break;
					}
				}

				if (!plotUnitExists) {
					plotUnit = {
						type: dataSeries.type,
						previousDataSeriesCount: 0, //to be set next
						index: plotType.plotUnits.length,
						plotType: plotType,
						axisYType: dataSeries.axisYType,
						axisY: dataSeries.axisYType === &quot;primary&quot; ? this.axisY : this.axisY2,
						axisX: this.axisX,
						dataSeriesIndexes: [], //index of dataSeries
						yTotals: []
					}
					plotType.plotUnits.push(plotUnit);
				}

				plotType.totalDataSeries++;

				plotUnit.dataSeriesIndexes.push(i);

				dataSeries.plotUnit = plotUnit;
			}
		}

		for (var i = 0; i &lt; this.plotInfo.plotTypes.length; i++) {
			var plotType = this.plotInfo.plotTypes[i];
			var previousDataSeriesCount = 0;

			for (var j = 0; j &lt; plotType.plotUnits.length; j++) {

				plotType.plotUnits[j].previousDataSeriesCount = previousDataSeriesCount;

				previousDataSeriesCount += plotType.plotUnits[j].dataSeriesIndexes.length;
			}
		}
	}

	Chart.prototype.assignIdToDataPoints = function () {

		for (var i = 0; i &lt; this.data.length; i++) {
			var dataSeries = this.data[i];

			if (!dataSeries.dataPoints)
				continue;

			var length = dataSeries.dataPoints.length;

			for (var j = 0; j &lt; length; j++) {
				dataSeries.dataPointIds[j] = ++this._eventManager.lastObjectId;
			}
		}
	}

	Chart.prototype._processData = function () {
		this.assignIdToDataPoints();
		this.categoriseDataSeries();

		for (var i = 0; i &lt; this.plotInfo.plotTypes.length; i++) {
			var plotType = this.plotInfo.plotTypes[i];

			for (var j = 0; j &lt; plotType.plotUnits.length; j++) {

				var plotUnit = plotType.plotUnits[j];

				if (plotUnit.type === &quot;line&quot; || plotUnit.type === &quot;stepLine&quot; || plotUnit.type === &quot;spline&quot; || plotUnit.type === &quot;column&quot; || plotUnit.type === &quot;area&quot; || plotUnit.type === &quot;stepArea&quot; || plotUnit.type === &quot;splineArea&quot; || plotUnit.type === &quot;bar&quot; || plotUnit.type === &quot;bubble&quot; || plotUnit.type === &quot;scatter&quot;)
					this._processMultiseriesPlotUnit(plotUnit);
				else if (plotUnit.type === &quot;stackedColumn&quot; || plotUnit.type === &quot;stackedBar&quot; || plotUnit.type === &quot;stackedArea&quot;)
					this._processStackedPlotUnit(plotUnit);
				else if (plotUnit.type === &quot;stackedColumn100&quot; || plotUnit.type === &quot;stackedBar100&quot; || plotUnit.type === &quot;stackedArea100&quot;)
					this._processStacked100PlotUnit(plotUnit);
				else if (plotUnit.type === &quot;candlestick&quot; || plotUnit.type === &quot;ohlc&quot; || plotUnit.type === &quot;rangeColumn&quot; || plotUnit.type === &quot;rangeBar&quot; || plotUnit.type === &quot;rangeArea&quot; || plotUnit.type === &quot;rangeSplineArea&quot;)
					this._processMultiYPlotUnit(plotUnit);
			}
		}

	}

	Chart.prototype._processMultiseriesPlotUnit = function (plotUnit) {
		if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length &lt; 1)
			return;

		var axisYDataInfo = plotUnit.axisY.dataInfo;
		var axisXDataInfo = plotUnit.axisX.dataInfo;
		var dataPointX, dataPointY;
		var isDateTime = false;


		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {
			var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];
			var i = 0;
			var isFirstDPInViewPort = false;
			var isLastDPInViewPort = false;
			var prevNonNullX;

			if (dataSeries.axisPlacement === &quot;normal&quot; || dataSeries.axisPlacement === &quot;xySwapped&quot;) {

				var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : (this._options.axisX &amp;&amp; this._options.axisX.viewportMinimum) ?
					this._options.axisX.viewportMinimum : (this._options.axisX &amp;&amp; this._options.axisX.minimum) ? this._options.axisX.minimum : -Infinity;

				var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : (this._options.axisX &amp;&amp; this._options.axisX.viewportMaximum) ?
					this._options.axisX.viewportMaximum : (this._options.axisX &amp;&amp; this._options.axisX.maximum) ? this._options.axisX.maximum : Infinity;
			}


			if (dataSeries.dataPoints[i].x &amp;&amp; dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === &quot;dateTime&quot;) {
				isDateTime = true;
			}

			for (i = 0; i &lt; dataSeries.dataPoints.length; i++) {

				if (typeof dataSeries.dataPoints[i].x === &quot;undefined&quot;) {
					dataSeries.dataPoints[i].x = i;
				}

				if (dataSeries.dataPoints[i].x.getTime) {
					isDateTime = true;
					dataPointX = dataSeries.dataPoints[i].x.getTime();//dataPointX is used so that getTime is called only once in case of dateTime values
				}
				else
					dataPointX = dataSeries.dataPoints[i].x;

				dataPointY = dataSeries.dataPoints[i].y;


				if (dataPointX &lt; axisXDataInfo.min)
					axisXDataInfo.min = dataPointX;
				if (dataPointX &gt; axisXDataInfo.max)
					axisXDataInfo.max = dataPointX;

				if (dataPointY &lt; axisYDataInfo.min)
					axisYDataInfo.min = dataPointY;

				if (dataPointY &gt; axisYDataInfo.max)
					axisYDataInfo.max = dataPointY;


				if (i &gt; 0) {
					var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;
					xDiff &lt; 0 &amp;&amp; (xDiff = xDiff * -1); //If Condition shortcut

					if (axisXDataInfo.minDiff &gt; xDiff &amp;&amp; xDiff !== 0) {
						axisXDataInfo.minDiff = xDiff;
					}

					if (dataPointY !== null &amp;&amp; dataSeries.dataPoints[i - 1].y !== null) {
						var yDiff = dataPointY - dataSeries.dataPoints[i - 1].y;
						yDiff &lt; 0 &amp;&amp; (yDiff = yDiff * -1); //If Condition shortcut

						if (axisYDataInfo.minDiff &gt; yDiff &amp;&amp; yDiff !== 0) {
							axisYDataInfo.minDiff = yDiff;
						}
					}
				}

				// This section makes sure that partially visible dataPoints are included in the begining
				if (dataPointX &lt; plotAreaXMin &amp;&amp; !isFirstDPInViewPort) {
					if (dataPointY !== null)
						prevNonNullX = dataPointX;
					continue;
				} else if (!isFirstDPInViewPort) {
					isFirstDPInViewPort = true;

					if (i &gt; 0) {
						i -= 2;
						continue;
					}
				}

				// This section makes sure that partially visible dataPoints are included at the end
				if (dataPointX &gt; plotAreaXMax &amp;&amp; !isLastDPInViewPort) {
					isLastDPInViewPort = true;
				} else if (dataPointX &gt; plotAreaXMax &amp;&amp; isLastDPInViewPort) {
					continue;
				}

				if (dataSeries.dataPoints[i].label)
					plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;


				if (dataPointX &lt; axisXDataInfo.viewPortMin)
					axisXDataInfo.viewPortMin = dataPointX;
				if (dataPointX &gt; axisXDataInfo.viewPortMax)
					axisXDataInfo.viewPortMax = dataPointX;

				if (dataPointY === null) {
					if (axisXDataInfo.viewPortMin === dataPointX &amp;&amp; prevNonNullX &lt; dataPointX)
						axisXDataInfo.viewPortMin = prevNonNullX;
					continue;
				}


				if (dataPointY &lt; axisYDataInfo.viewPortMin)
					axisYDataInfo.viewPortMin = dataPointY;
				if (dataPointY &gt; axisYDataInfo.viewPortMax)
					axisYDataInfo.viewPortMax = dataPointY;
			}

			this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? &quot;dateTime&quot; : &quot;number&quot;;
		}

		//this.dataPoints.sort(compareDataPointX);
		//this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });
	}

	Chart.prototype._processStackedPlotUnit = function (plotUnit) {
		if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length &lt; 1)
			return;

		var axisYDataInfo = plotUnit.axisY.dataInfo;
		var axisXDataInfo = plotUnit.axisX.dataInfo;

		var dataPointX, dataPointY;
		var isDateTime = false;

		var dataPointYPositiveSums = [];
		var dataPointYNegativeSums = [];

		var firstSeriesMin = Infinity;
		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {
			var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];
			var i = 0;
			var isFirstDPInViewPort = false;
			var isLastDPInViewPort = false;
			var prevNonNullX;

			if (dataSeries.axisPlacement === &quot;normal&quot; || dataSeries.axisPlacement === &quot;xySwapped&quot;) {

				var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : (this._options.axisX &amp;&amp; this._options.axisX.viewportMinimum) ?
					this._options.axisX.viewportMinimum : (this._options.axisX &amp;&amp; this._options.axisX.minimum) ? this._options.axisX.minimum : -Infinity;

				var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : (this._options.axisX &amp;&amp; this._options.axisX.viewportMaximum) ?
					this._options.axisX.viewportMaximum : (this._options.axisX &amp;&amp; this._options.axisX.maximum) ? this._options.axisX.maximum : Infinity;
			}


			if (dataSeries.dataPoints[i].x &amp;&amp; dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === &quot;dateTime&quot;) {
				isDateTime = true;
			}

			for (i = 0; i &lt; dataSeries.dataPoints.length; i++) {

				// Requird when no x values are provided 
				if (typeof dataSeries.dataPoints[i].x === &quot;undefined&quot;) {
					dataSeries.dataPoints[i].x = i;
				}

				if (dataSeries.dataPoints[i].x.getTime) {
					isDateTime = true;
					dataPointX = dataSeries.dataPoints[i].x.getTime();//dataPointX is used so that getTime is called only once in case of dateTime values
				}
				else
					dataPointX = dataSeries.dataPoints[i].x;

				if (!isNullOrUndefined(dataSeries.dataPoints[i].y)) {
					dataPointY = dataSeries.dataPoints[i].y;

					if (j === 0)
						firstSeriesMin = Math.min(dataPointY, firstSeriesMin);
				}
				else {
					dataPointY = 0;
				}

				if (dataPointX &lt; axisXDataInfo.min)
					axisXDataInfo.min = dataPointX;
				if (dataPointX &gt; axisXDataInfo.max)
					axisXDataInfo.max = dataPointX;

				if (i &gt; 0) {
					var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;
					xDiff &lt; 0 &amp;&amp; (xDiff = xDiff * -1); //If Condition shortcut

					if (axisXDataInfo.minDiff &gt; xDiff &amp;&amp; xDiff !== 0) {
						axisXDataInfo.minDiff = xDiff;
					}

					if (dataPointY !== null &amp;&amp; dataSeries.dataPoints[i - 1].y !== null) {
						var yDiff = dataPointY - dataSeries.dataPoints[i - 1].y;
						yDiff &lt; 0 &amp;&amp; (yDiff = yDiff * -1); //If Condition shortcut

						if (axisYDataInfo.minDiff &gt; yDiff &amp;&amp; yDiff !== 0) {
							axisYDataInfo.minDiff = yDiff;
						}
					}
				}

				// This section makes sure that partially visible dataPoints are included in the begining
				if (dataPointX &lt; plotAreaXMin &amp;&amp; !isFirstDPInViewPort) {
					if (dataSeries.dataPoints[i].y !== null)
						prevNonNullX = dataPointX;
					continue;
				} else if (!isFirstDPInViewPort) {
					isFirstDPInViewPort = true;

					if (i &gt; 0) {
						i -= 2;
						continue;
					}
				}

				// This section makes sure that partially visible dataPoints are included at the end
				if (dataPointX &gt; plotAreaXMax &amp;&amp; !isLastDPInViewPort) {
					isLastDPInViewPort = true;
				} else if (dataPointX &gt; plotAreaXMax &amp;&amp; isLastDPInViewPort) {
					continue;
				}


				if (dataSeries.dataPoints[i].label)
					plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;

				if (dataPointX &lt; axisXDataInfo.viewPortMin)
					axisXDataInfo.viewPortMin = dataPointX;
				if (dataPointX &gt; axisXDataInfo.viewPortMax)
					axisXDataInfo.viewPortMax = dataPointX;

				if (dataSeries.dataPoints[i].y === null) {
					if (axisXDataInfo.viewPortMin === dataPointX &amp;&amp; prevNonNullX &lt; dataPointX)
						axisXDataInfo.viewPortMin = prevNonNullX;
					continue;
				}

				plotUnit.yTotals[dataPointX] = (!plotUnit.yTotals[dataPointX] ? 0 : plotUnit.yTotals[dataPointX]) + Math.abs(dataPointY);

				if (dataPointY &gt;= 0) {
					if (dataPointYPositiveSums[dataPointX])
						dataPointYPositiveSums[dataPointX] += dataPointY;
					else
						dataPointYPositiveSums[dataPointX] = dataPointY;
				} else {
					if (dataPointYNegativeSums[dataPointX])
						dataPointYNegativeSums[dataPointX] += dataPointY;
					else
						dataPointYNegativeSums[dataPointX] = dataPointY;
				}
			}

			this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? &quot;dateTime&quot; : &quot;number&quot;;
		}

		for (i in dataPointYPositiveSums) {
			if (dataPointYPositiveSums.hasOwnProperty(i)) {
				if (isNaN(i)) {
					continue;
				}
				var ySum = dataPointYPositiveSums[i];

				if (ySum &lt; axisYDataInfo.min)
					axisYDataInfo.min = Math.min(ySum, firstSeriesMin);

				if (ySum &gt; axisYDataInfo.max)
					axisYDataInfo.max = ySum;

				if (i &lt; axisXDataInfo.viewPortMin || i &gt; axisXDataInfo.viewPortMax)
					continue;

				if (ySum &lt; axisYDataInfo.viewPortMin)
					axisYDataInfo.viewPortMin = Math.min(ySum, firstSeriesMin);
				if (ySum &gt; axisYDataInfo.viewPortMax)
					axisYDataInfo.viewPortMax = ySum;
			}

		}

		for (i in dataPointYNegativeSums) {

			if (dataPointYNegativeSums.hasOwnProperty(i)) {
				if (isNaN(i)) {
					continue;
				}

				var ySum = dataPointYNegativeSums[i];

				if (ySum &lt; axisYDataInfo.min)
					axisYDataInfo.min = Math.min(ySum, firstSeriesMin);

				if (ySum &gt; axisYDataInfo.max)
					axisYDataInfo.max = ySum;

				if (i &lt; axisXDataInfo.viewPortMin || i &gt; axisXDataInfo.viewPortMax)
					continue;

				if (ySum &lt; axisYDataInfo.viewPortMin)
					axisYDataInfo.viewPortMin = Math.min(ySum, firstSeriesMin);
				if (ySum &gt; axisYDataInfo.viewPortMax)
					axisYDataInfo.viewPortMax = ySum;
			}

		}


		//this.dataPoints.sort(compareDataPointX);
		//this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });

		//window.console.log(&quot;viewPortYMin: &quot; + plotInfo.viewPortYMin + &quot;; viewPortYMax: &quot; + plotInfo.viewPortYMax);
	}

	Chart.prototype._processStacked100PlotUnit = function (plotUnit) {
		if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length &lt; 1)
			return;

		var axisYDataInfo = plotUnit.axisY.dataInfo;
		var axisXDataInfo = plotUnit.axisX.dataInfo;

		var dataPointX, dataPointY;
		var isDateTime = false;
		var containsPositiveY = false;
		var containsNegativeY = false;

		var dataPointYSums = [];

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {
			var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];
			var i = 0;
			var isFirstDPInViewPort = false;
			var isLastDPInViewPort = false;
			var prevNonNullX;

			if (dataSeries.axisPlacement === &quot;normal&quot; || dataSeries.axisPlacement === &quot;xySwapped&quot;) {

				var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : (this._options.axisX &amp;&amp; this._options.axisX.viewportMinimum) ?
					this._options.axisX.viewportMinimum : (this._options.axisX &amp;&amp; this._options.axisX.minimum) ? this._options.axisX.minimum : -Infinity;

				var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : (this._options.axisX &amp;&amp; this._options.axisX.viewportMaximum) ?
					this._options.axisX.viewportMaximum : (this._options.axisX &amp;&amp; this._options.axisX.maximum) ? this._options.axisX.maximum : Infinity;
			}


			if (dataSeries.dataPoints[i].x &amp;&amp; dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === &quot;dateTime&quot;) {
				isDateTime = true;
			}

			for (i = 0; i &lt; dataSeries.dataPoints.length; i++) {

				// Requird when no x values are provided 
				if (typeof dataSeries.dataPoints[i].x === &quot;undefined&quot;) {
					dataSeries.dataPoints[i].x = i;
				}

				if (dataSeries.dataPoints[i].x.getTime) {
					isDateTime = true;
					dataPointX = dataSeries.dataPoints[i].x.getTime();//dataPointX is used so that getTime is called only once in case of dateTime values
				}
				else
					dataPointX = dataSeries.dataPoints[i].x;
				if (!isNullOrUndefined(dataSeries.dataPoints[i].y))
					dataPointY = dataSeries.dataPoints[i].y;
				else
					dataPointY = null;



				if (dataPointX &lt; axisXDataInfo.min)
					axisXDataInfo.min = dataPointX;
				if (dataPointX &gt; axisXDataInfo.max)
					axisXDataInfo.max = dataPointX;

				if (i &gt; 0) {
					var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;
					xDiff &lt; 0 &amp;&amp; (xDiff = xDiff * -1); //If Condition shortcut

					if (axisXDataInfo.minDiff &gt; xDiff &amp;&amp; xDiff !== 0) {
						axisXDataInfo.minDiff = xDiff;
					}

					if (!isNullOrUndefined(dataPointY) &amp;&amp; dataSeries.dataPoints[i - 1].y !== null) {
						var yDiff = dataPointY - dataSeries.dataPoints[i - 1].y;
						yDiff &lt; 0 &amp;&amp; (yDiff = yDiff * -1); //If Condition shortcut

						if (axisYDataInfo.minDiff &gt; yDiff &amp;&amp; yDiff !== 0) {
							axisYDataInfo.minDiff = yDiff;
						}
					}
				}

				// This section makes sure that partially visible dataPoints are included in the begining
				if (dataPointX &lt; plotAreaXMin &amp;&amp; !isFirstDPInViewPort) {
					if (dataPointY !== null)
						prevNonNullX = dataPointX;
					continue;
				} else if (!isFirstDPInViewPort) {
					isFirstDPInViewPort = true;

					if (i &gt; 0) {
						i -= 2;
						continue;
					}
				}

				// This section makes sure that partially visible dataPoints are included at the end
				if (dataPointX &gt; plotAreaXMax &amp;&amp; !isLastDPInViewPort) {
					isLastDPInViewPort = true;
				} else if (dataPointX &gt; plotAreaXMax &amp;&amp; isLastDPInViewPort) {
					continue;
				}

				if (dataSeries.dataPoints[i].label)
					plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;

				if (dataPointX &lt; axisXDataInfo.viewPortMin)
					axisXDataInfo.viewPortMin = dataPointX;
				if (dataPointX &gt; axisXDataInfo.viewPortMax)
					axisXDataInfo.viewPortMax = dataPointX;

				if (dataPointY === null) {
					if (axisXDataInfo.viewPortMin === dataPointX &amp;&amp; prevNonNullX &lt; dataPointX)
						axisXDataInfo.viewPortMin = prevNonNullX;
					continue;
				}

				plotUnit.yTotals[dataPointX] = (!plotUnit.yTotals[dataPointX] ? 0 : plotUnit.yTotals[dataPointX]) + Math.abs(dataPointY);

				if (dataPointY &gt;= 0) {
					containsPositiveY = true;
				} else if (dataPointY &lt; 0) {//If dataPointY is undefied or null
					containsNegativeY = true;
				}

				if (dataPointYSums[dataPointX])
					dataPointYSums[dataPointX] += Math.abs(dataPointY);
				else
					dataPointYSums[dataPointX] = Math.abs(dataPointY);
			}

			this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? &quot;dateTime&quot; : &quot;number&quot;;
		}


		if (containsPositiveY &amp;&amp; !containsNegativeY) {
			axisYDataInfo.max = (!isNullOrUndefined(axisYDataInfo.viewPortMax)) ? Math.max(axisYDataInfo.viewPortMax, 99) : 99;
			axisYDataInfo.min = (!isNullOrUndefined(axisYDataInfo.viewPortMin)) ? Math.min(axisYDataInfo.viewPortMin, 1) : 1;
		} else if (containsPositiveY &amp;&amp; containsNegativeY) {
			axisYDataInfo.max = (!isNullOrUndefined(axisYDataInfo.viewPortMax)) ? Math.max(axisYDataInfo.viewPortMax, 99) : 99;
			axisYDataInfo.min = (!isNullOrUndefined(axisYDataInfo.viewPortMin)) ? Math.min(axisYDataInfo.viewPortMin, -99) : -99;
		} else if (!containsPositiveY &amp;&amp; containsNegativeY) {
			axisYDataInfo.max = (!isNullOrUndefined(axisYDataInfo.viewPortMax)) ? Math.max(axisYDataInfo.viewPortMax, -1) : -1;
			axisYDataInfo.min = (!isNullOrUndefined(axisYDataInfo.viewPortMin)) ? Math.min(axisYDataInfo.viewPortMin, -99) : -99;
		}
		//Max of array to max

		axisYDataInfo.viewPortMin = axisYDataInfo.min;
		axisYDataInfo.viewPortMax = axisYDataInfo.max;

		plotUnit.dataPointYSums = dataPointYSums;

		//this.dataPoints.sort(compareDataPointX);
		//this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });

		//window.console.log(&quot;viewPortYMin: &quot; + plotInfo.viewPortYMin + &quot;; viewPortYMax: &quot; + plotInfo.viewPortYMax);
	}

	Chart.prototype._processMultiYPlotUnit = function (plotUnit) {
		if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length &lt; 1)
			return;

		var axisYDataInfo = plotUnit.axisY.dataInfo;
		var axisXDataInfo = plotUnit.axisX.dataInfo;
		var dataPointX, dataPointY, dataPointYMin, dataPointYMax;
		var isDateTime = false;


		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {
			var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];
			var i = 0;
			var isFirstDPInViewPort = false;
			var isLastDPInViewPort = false;
			var prevNonNullX;
			var currentDataNonNull;
			var firstNonNullX;

			if (dataSeries.axisPlacement === &quot;normal&quot; || dataSeries.axisPlacement === &quot;xySwapped&quot;) {

				var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : (this._options.axisX &amp;&amp; this._options.axisX.viewportMinimum) ?
					this._options.axisX.viewportMinimum : (this._options.axisX &amp;&amp; this._options.axisX.minimum) ? this._options.axisX.minimum : -Infinity;

				var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : (this._options.axisX &amp;&amp; this._options.axisX.viewportMaximum) ?
					this._options.axisX.viewportMaximum : (this._options.axisX &amp;&amp; this._options.axisX.maximum) ? this._options.axisX.maximum : Infinity;
			}


			if (dataSeries.dataPoints[i].x &amp;&amp; dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === &quot;dateTime&quot;) {
				isDateTime = true;
			}

			for (i = 0; i &lt; dataSeries.dataPoints.length; i++) {

				if (typeof dataSeries.dataPoints[i].x === &quot;undefined&quot;) {
					dataSeries.dataPoints[i].x = i;
				}

				if (dataSeries.dataPoints[i].x.getTime) {
					isDateTime = true;
					dataPointX = dataSeries.dataPoints[i].x.getTime();//dataPointX is used so that getTime is called only once in case of dateTime values
				}
				else
					dataPointX = dataSeries.dataPoints[i].x;

				dataPointY = dataSeries.dataPoints[i].y;

				if (dataPointY &amp;&amp; dataPointY.length) {
					dataPointYMin = Math.min.apply(null, dataPointY);
					dataPointYMax = Math.max.apply(null, dataPointY);

					currentDataNonNull = true;
					for (var k = 0; k &lt; dataPointY.length; k++)
						if (dataPointY.k === null)
							currentDataNonNull = false;
					if (currentDataNonNull) {
						if (!isFirstDPInViewPort)
							firstNonNullX = prevNonNullX;
						prevNonNullX = dataPointX;
					}
				}


				if (dataPointX &lt; axisXDataInfo.min)
					axisXDataInfo.min = dataPointX;
				if (dataPointX &gt; axisXDataInfo.max)
					axisXDataInfo.max = dataPointX;

				if (dataPointYMin &lt; axisYDataInfo.min)
					axisYDataInfo.min = dataPointYMin;

				if (dataPointYMax &gt; axisYDataInfo.max)
					axisYDataInfo.max = dataPointYMax;


				if (i &gt; 0) {
					var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;
					xDiff &lt; 0 &amp;&amp; (xDiff = xDiff * -1); //If Condition shortcut

					if (axisXDataInfo.minDiff &gt; xDiff &amp;&amp; xDiff !== 0) {
						axisXDataInfo.minDiff = xDiff;
					}

					if (dataPointY &amp;&amp; dataPointY[0] !== null &amp;&amp; dataSeries.dataPoints[i - 1].y &amp;&amp; dataSeries.dataPoints[i - 1].y[0] !== null) {
						var yDiff = dataPointY[0] - dataSeries.dataPoints[i - 1].y[0];
						yDiff &lt; 0 &amp;&amp; (yDiff = yDiff * -1); //If Condition shortcut

						if (axisYDataInfo.minDiff &gt; yDiff &amp;&amp; yDiff !== 0) {
							axisYDataInfo.minDiff = yDiff;
						}
					}
				}

				// This section makes sure that partially visible dataPoints are included in the begining
				if (dataPointX &lt; plotAreaXMin &amp;&amp; !isFirstDPInViewPort) {
					continue;
				} else if (!isFirstDPInViewPort) {
					isFirstDPInViewPort = true;

					if (i &gt; 0) {
						i -= 2;
						prevNonNullX = firstNonNullX;
						continue;
					}
				}

				// This section makes sure that partially visible dataPoints are included at the end
				if (dataPointX &gt; plotAreaXMax &amp;&amp; !isLastDPInViewPort) {
					isLastDPInViewPort = true;
				} else if (dataPointX &gt; plotAreaXMax &amp;&amp; isLastDPInViewPort) {
					continue;
				}

				if (dataSeries.dataPoints[i].label)
					plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;


				if (dataPointX &lt; axisXDataInfo.viewPortMin)
					axisXDataInfo.viewPortMin = dataPointX;
				if (dataPointX &gt; axisXDataInfo.viewPortMax)
					axisXDataInfo.viewPortMax = dataPointX;

				if (axisXDataInfo.viewPortMin === dataPointX &amp;&amp; dataPointY)
					for (var k = 0; k &lt; dataPointY.length ; k++)
						if (dataPointY[k] === null &amp;&amp; prevNonNullX &lt; dataPointX) {
							axisXDataInfo.viewPortMin = prevNonNullX;
							break;
						}

				if (dataPointY === null) {
					if (axisXDataInfo.viewPortMin === dataPointX &amp;&amp; prevNonNullX &lt; dataPointX)
						axisXDataInfo.viewPortMin = prevNonNullX;
					continue;
				}

				if (dataPointYMin &lt; axisYDataInfo.viewPortMin)
					axisYDataInfo.viewPortMin = dataPointYMin;
				if (dataPointYMax &gt; axisYDataInfo.viewPortMax)
					axisYDataInfo.viewPortMax = dataPointYMax;
			}

			this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? &quot;dateTime&quot; : &quot;number&quot;;
		}

		//this.dataPoints.sort(compareDataPointX);
		//this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });
	}

	//getClosest returns objects nearby and hence shouldn&#x27;t be used for events like click, mouseover, mousemove, etc which require object that is exactly under the mouse.
	Chart.prototype.getDataPointAtXY = function (mouseX, mouseY, getClosest) {

		getClosest = getClosest || false;
		var results = [];

		for (var i = this._dataInRenderedOrder.length - 1; i &gt;= 0; i--) {
			var dataSeries = this._dataInRenderedOrder[i];

			var result = null;

			result = dataSeries.getDataPointAtXY(mouseX, mouseY, getClosest);
			if (result)
				results.push(result);
		}

		var closestResult = null;
		var onlyLineAreaTypes = false;

		for (var m = 0; m &lt; results.length; m++) {

			if (results[m].dataSeries.type === &quot;line&quot; || results[m].dataSeries.type === &quot;stepLine&quot; || results[m].dataSeries.type === &quot;area&quot; || results[m].dataSeries.type === &quot;stepArea&quot;) {
				var markerSize = getProperty(&quot;markerSize&quot;, results[m].dataPoint, results[m].dataSeries) || 8;
				if (results[m].distance &lt;= markerSize / 2) {
					onlyLineAreaTypes = true;
					break;
				}
			}
		}

		for (m = 0; m &lt; results.length; m++) {

			if (onlyLineAreaTypes &amp;&amp; results[m].dataSeries.type !== &quot;line&quot; &amp;&amp; results[m].dataSeries.type !== &quot;stepLine&quot; &amp;&amp; results[m].dataSeries.type !== &quot;area&quot; &amp;&amp; results[m].dataSeries.type !== &quot;stepArea&quot;)
				continue;

			if (!closestResult) {
				closestResult = results[m];
			} else if (results[m].distance &lt;= closestResult.distance) {
				closestResult = results[m];
			}
		}

		return closestResult;
	}

	Chart.prototype.getObjectAtXY = function (mouseX, mouseY, getClosest) {
		getClosest = getClosest || false;

		var id = null;

		var dataPointInfo = this.getDataPointAtXY(mouseX, mouseY, getClosest);

		if (dataPointInfo) {
			id = dataPointInfo.dataSeries.dataPointIds[dataPointInfo.dataPointIndex];
		} else if (isCanvasSupported) {//IE9+
			id = getObjectId(mouseX, mouseY, this._eventManager.ghostCtx);
		}
		else {
			for (var i = 0; i &lt; this.legend.items.length; i++) {
				var item = this.legend.items[i];

				if (mouseX &gt;= item.x1 &amp;&amp; mouseX &lt;= item.x2 &amp;&amp; mouseY &gt;= item.y1 &amp;&amp; mouseY &lt;= item.y2) {
					id = item.id;
				}
			}
		}

		return id;
	}

	/// &lt;summary&gt;Calculates Font Size based on standardSize and Chart Size&lt;/summary&gt;
	/// &lt;param name=&quot;standardSize&quot; type=&quot;Number&quot;&gt;Standard font size for a Chart with min(width,height) = 400px&lt;/param&gt;
	/// &lt;returns type=&quot;Number&quot;&gt;The area.&lt;/returns&gt;	
	Chart.prototype.getAutoFontSize = function (standardSize, width, height) {

		width = width || this.width;
		height = height || this.height;

		var fontSizeScaleFactor = standardSize / 400;

		return Math.round(Math.min(this.width, this.height) * fontSizeScaleFactor);
	}

	//#region Events

	Chart.prototype.resetOverlayedCanvas = function () {
		//var width = this.overlaidCanvas.width;
		//this.overlaidCanvas.width = 0;
		//this.overlaidCanvas.width = width;
		this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);
	}

	Chart.prototype.clearCanvas = function () {
		this.ctx.clearRect(0, 0, this.width, this.height);

		if (this.backgroundColor) {
			this.ctx.fillStyle = this.backgroundColor;
			this.ctx.fillRect(0, 0, this.width, this.height);
		}
	}

	Chart.prototype.attachEvent = function (param) {
		this._events.push(param);
	}

	Chart.prototype._touchEventHandler = function (ev) {
		if (!ev.changedTouches || !this.interactivityEnabled)
			return;

		var mouseEvents = [];
		var touches = ev.changedTouches;
		var first = touches ? touches[0] : ev;
		var touchCurrentCoordinates = null;

		//window.console.log(touches.length);

		switch (ev.type) {
			case &quot;touchstart&quot;: case &quot;MSPointerDown&quot;:
				mouseEvents = [&quot;mousemove&quot;, &quot;mousedown&quot;];
				this._lastTouchData = getMouseCoordinates(first);
				this._lastTouchData.time = new Date();
				break;
			case &quot;touchmove&quot;: case &quot;MSPointerMove&quot;: mouseEvents = [&quot;mousemove&quot;]; break;
			case &quot;touchend&quot;: case &quot;MSPointerUp&quot;: mouseEvents = (this._lastTouchEventType === &quot;touchstart&quot; || this._lastTouchEventType === &quot;MSPointerDown&quot;) ? [&quot;mouseup&quot;, &quot;click&quot;] : [&quot;mouseup&quot;];
				break;
			default: return;
		}

		if (touches &amp;&amp; touches.length &gt; 1) return;


		touchCurrentCoordinates = getMouseCoordinates(first);
		touchCurrentCoordinates.time = new Date();
		try {
			var dy = touchCurrentCoordinates.y - this._lastTouchData.y;
			var dx = touchCurrentCoordinates.x - this._lastTouchData.x;
			var dt = touchCurrentCoordinates.time - this._lastTouchData.time;

			if (Math.abs(dy) &gt; 15 &amp;&amp; (!!this._lastTouchData.scroll || dt &lt; 200)) {
				//this._lastTouchData.y = touchCurrentCoordinates.y;
				this._lastTouchData.scroll = true;

				var win = window.parent || window;
				if (win &amp;&amp; win.scrollBy)
					win.scrollBy(0, -dy);
			}
		} catch (e) { };

		this._lastTouchEventType = ev.type;

		if (!!this._lastTouchData.scroll &amp;&amp; this.zoomEnabled) {
			if (this.isDrag)
				this.resetOverlayedCanvas();

			this.isDrag = false;
			return;
		}

		for (var i = 0; i &lt; mouseEvents.length; i++) {

			var type = mouseEvents[i];
			var simulatedEvent = document.createEvent(&quot;MouseEvent&quot;);
			simulatedEvent.initMouseEvent(type, true, true, window, 1,
									  first.screenX, first.screenY,
									  first.clientX, first.clientY, false,
									  false, false, false, 0, null);

			first.target.dispatchEvent(simulatedEvent);

			if (ev.preventManipulation) {
				//alert(&quot;preventManipulation&quot;);
				ev.preventManipulation();
			}

			if (ev.preventDefault) {
				//alert(&quot;preventDefault&quot;);
				ev.preventDefault();
			}
		}
	}

	Chart.prototype._dispatchRangeEvent = function (eventName, triggerSource) {
		var eventParameter = {};

		eventParameter.chart = this._publicChartReference;
		eventParameter.type = eventName;
		eventParameter.trigger = triggerSource;

		var axes = [];

		if (this.axisX)
			axes.push(&quot;axisX&quot;);
		if (this.axisY)
			axes.push(&quot;axisY&quot;);
		if (this.axisY2)
			axes.push(&quot;axisY2&quot;);

		for (var i = 0; i &lt; axes.length; i++) {
			eventParameter[axes[i]] = {
				viewportMinimum: this[axes[i]].sessionVariables.newViewportMinimum,
				viewportMaximum: this[axes[i]].sessionVariables.newViewportMaximum
			}
		}

		this.dispatchEvent(eventName, eventParameter, this._publicChartReference);
	}

	Chart.prototype._mouseEventHandler = function (ev) {

		//IE8- uses srcElement instead of target. So instead of checking this condition everytime, its better to create a reference called target.
		if (typeof (ev.target) === &quot;undefined&quot; &amp;&amp; ev.srcElement)
			ev.target = ev.srcElement;

		var xy = getMouseCoordinates(ev);
		var type = ev.type;
		var eventParam;
		var rightclick;

		if (!ev) var e = window.event;
		if (ev.which) rightclick = (ev.which == 3);
		else if (ev.button) rightclick = (ev.button == 2);

		releaseCapturedEvent();

		//console.log(ev.type);

		if (!this.interactivityEnabled)
			return;

		if (this._ignoreNextEvent) {
			this._ignoreNextEvent = false;
			return;
		}

		// stop panning and zooming so we can draw
		if (ev.preventManipulation) {
			//alert(&quot;preventManipulation&quot;);
			ev.preventManipulation();
		}

		// we are handling this event
		if (ev.preventDefault) {
			//alert(&quot;preventDefault&quot;);
			ev.preventDefault();
		}

		var bounds;

		//window.console.log(type + &quot; --&gt; x: &quot; + xy.x + &quot;; y:&quot; + xy.y);

		//if (type === &quot;mouseout&quot;) {
		//    this._toolTip.hide();
		//}

		if (isDebugMode &amp;&amp; window.console) {
			window.console.log(type + &quot; --&gt; x: &quot; + xy.x + &quot;; y:&quot; + xy.y);
			if (rightclick)
				window.console.log(ev.which);

			if (type === &quot;mouseup&quot;)
				window.console.log(&quot;mouseup&quot;);
		}

		if (rightclick)
			return;

		//if (this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
		//    //var temp = xy.x;
		//    //xy.x = xy.y;
		//    //xy.y = temp;
		//    xy = {x: xy.y, y: xy.x};
		//}

		function releaseCapturedEvent() {
			if (Chart.capturedEventParam) {
				eventParam = Chart.capturedEventParam;
				bounds = eventParam.bounds;

				if (type === &quot;mouseup&quot;) {
					Chart.capturedEventParam = null;

					if (eventParam.chart.overlaidCanvas.releaseCapture)
						eventParam.chart.overlaidCanvas.releaseCapture();
					else
						document.documentElement.removeEventListener(&quot;mouseup&quot;, eventParam.chart._mouseEventHandler, false);
				}

				if (eventParam.hasOwnProperty(type)) {

					if (type === &quot;mouseup&quot; &amp;&amp; !eventParam.chart.overlaidCanvas.releaseCapture) {
						if (ev.target !== eventParam.chart.overlaidCanvas)
							eventParam.chart.isDrag = false;
					} else if (ev.target === eventParam.chart.overlaidCanvas)
						eventParam[type].call(eventParam.context, xy.x, xy.y);

				}
			}
		}

		if (!Chart.capturedEventParam &amp;&amp; this._events) {

			for (var i = 0; i &lt; this._events.length; i++) {
				if (!this._events[i].hasOwnProperty(type))
					continue;

				eventParam = this._events[i];
				bounds = eventParam.bounds;

				if (xy.x &gt;= bounds.x1 &amp;&amp; xy.x &lt;= bounds.x2 &amp;&amp; xy.y &gt;= bounds.y1 &amp;&amp; xy.y &lt;= bounds.y2) {
					eventParam[type].call(eventParam.context, xy.x, xy.y);

					if (type === &quot;mousedown&quot; &amp;&amp; eventParam.capture === true) {
						Chart.capturedEventParam = eventParam;

						if (this.overlaidCanvas.setCapture)
							this.overlaidCanvas.setCapture();
						else {
							document.documentElement.addEventListener(&quot;mouseup&quot;, this._mouseEventHandler, false);
							//addEvent(document.body, &quot;mouseup&quot;, this._mouseEventHandler);
						}
					} else if (type === &quot;mouseup&quot;) {
						if (eventParam.chart.overlaidCanvas.releaseCapture)
							eventParam.chart.overlaidCanvas.releaseCapture();
						else
							document.documentElement.removeEventListener(&quot;mouseup&quot;, this._mouseEventHandler, false);
					}

					break;
				}
				else
					eventParam = null;
			}

			if (eventParam &amp;&amp; eventParam.cursor) {
				ev.target.style.cursor = eventParam.cursor;
			}
			else
				ev.target.style.cursor = this._defaultCursor;

			//eventParam = 
		}

		var plotArea = this.plotArea;
		if (xy.x &lt; plotArea.x1 || xy.x &gt; plotArea.x2 || xy.y &lt; plotArea.y1 || xy.y &gt; plotArea.y2) {
			if (this._toolTip &amp;&amp; this._toolTip.enabled) {
				this._toolTip.hide();
			} else {
				this.resetOverlayedCanvas();
			}
		}


		if ((!this.isDrag || !this.zoomEnabled) &amp;&amp; this._eventManager) {

			this._eventManager.mouseEventHandler(ev);
			//this._updateToolTip(ev.x, ev.y);            
		}

		//if (this._toolTip.enabled)
		//    this._toolTip.mouseMoveHandler(ev.x, ev.y);
	}

	Chart.prototype._plotAreaMouseDown = function (x, y) {
		this.isDrag = true;

		this.dragStartPoint = {
			x: x, y: y
		};
	}

	Chart.prototype._plotAreaMouseUp = function (x, y) {
		var plotArea = this.plotArea;

		if (this.plotInfo.axisPlacement === &quot;normal&quot; || this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
			if (this.isDrag) {
				var dragDelta = 0,
					dragDeltaPY = y - this.dragStartPoint.y,
					dragDeltaPX = x - this.dragStartPoint.x,
					zoomPX = this.zoomType.indexOf(&quot;x&quot;) &gt;= 0, //Whether to zoom horizontally
					zoomPY = this.zoomType.indexOf(&quot;y&quot;) &gt;= 0, //Whether to zoom vertically
					reRender = false;

				this.resetOverlayedCanvas();

				if (this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
					var temp = zoomPY;
					zoomPY = zoomPX;
					zoomPX = temp;
				}

				if (this.panEnabled || this.zoomEnabled) {
					if (this.panEnabled) {

						var overflow = 0;

						for (var i = 0; i &lt; this._axes.length; i++) {
							var axis = this._axes[i];

							if (axis.viewportMinimum &lt; axis.minimum) {

								overflow = axis.minimum - axis.viewportMinimum;

								axis.sessionVariables.newViewportMinimum = axis.viewportMinimum + overflow;
								axis.sessionVariables.newViewportMaximum = axis.viewportMaximum + overflow;

								reRender = true;
							} else if (axis.viewportMaximum &gt; axis.maximum) {

								overflow = axis.viewportMaximum - axis.maximum;
								axis.sessionVariables.newViewportMinimum = axis.viewportMinimum - overflow;
								axis.sessionVariables.newViewportMaximum = axis.viewportMaximum - overflow;

								reRender = true;
							}
						}

					}
					else if (((!zoomPX || Math.abs(dragDeltaPX) &gt; 2) &amp;&amp; (!zoomPY || Math.abs(dragDeltaPY) &gt; 2)) &amp;&amp; this.zoomEnabled) {

						if (!this.dragStartPoint)
							return;

						var selectedRegion = {
							x1: zoomPX ? this.dragStartPoint.x : this.plotArea.x1,
							y1: zoomPY ? this.dragStartPoint.y : this.plotArea.y1,
							x2: zoomPX ? x : this.plotArea.x2,
							y2: zoomPY ? y : this.plotArea.y2
						};

						if (Math.abs(selectedRegion.x1 - selectedRegion.x2) &gt; 2 &amp;&amp; Math.abs(selectedRegion.y1 - selectedRegion.y2) &gt; 2) {

							if (this._zoomPanToSelectedRegion(selectedRegion.x1, selectedRegion.y1, selectedRegion.x2, selectedRegion.y2)) {

								reRender = true;
							}
						}
					}

					if (reRender) {
						this._ignoreNextEvent = true;//Required so that click event doesn&#x27;t fire after zooming into a section of the chart.

						this._dispatchRangeEvent(&quot;rangeChanging&quot;, &quot;zoom&quot;);
						this.render();
						this._dispatchRangeEvent(&quot;rangeChanged&quot;, &quot;zoom&quot;);

						if (reRender &amp;&amp; this.zoomEnabled &amp;&amp; this._zoomButton.style.display === &quot;none&quot;) {
							show(this._zoomButton, this._resetButton);
							setButtonState(this, this._zoomButton, &quot;pan&quot;);
							setButtonState(this, this._resetButton, &quot;reset&quot;);
						}
					}
				}
			}

		}

		this.isDrag = false;
	}

	Chart.prototype._plotAreaMouseMove = function (x, y) {
		if (this.isDrag &amp;&amp; this.plotInfo.axisPlacement !== &quot;none&quot;) {

			var dragDeltaPX = 0,
				dragDeltaPY = 0,
				alpha = null,
				selectedRegion = null,
				zoomPX = this.zoomType.indexOf(&quot;x&quot;) &gt;= 0, //Whether to zoom horizontally
				zoomPY = this.zoomType.indexOf(&quot;y&quot;) &gt;= 0, //Whether to zoom vertically
				_this = this;

			if (this.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
				var temp = zoomPY;
				zoomPY = zoomPX;
				zoomPX = temp;
			}

			dragDeltaPX = this.dragStartPoint.x - x;
			dragDeltaPY = this.dragStartPoint.y - y;

			if (Math.abs(dragDeltaPX) &gt; 2 &amp;&amp; Math.abs(dragDeltaPX) &lt; 8 &amp;&amp; (this.panEnabled || this.zoomEnabled)) {
				this._toolTip.hide();
			} else if (!this.panEnabled &amp;&amp; !this.zoomEnabled) {
				this._toolTip.mouseMoveHandler(x, y);
			}

			if (((!zoomPX || Math.abs(dragDeltaPX) &gt; 2) || (!zoomPY || Math.abs(dragDeltaPY) &gt; 2)) &amp;&amp; (this.panEnabled || this.zoomEnabled)) {
				if (this.panEnabled) {

					selectedRegion =
						{
							x1: zoomPX ? this.plotArea.x1 + dragDeltaPX : this.plotArea.x1,
							y1: zoomPY ? this.plotArea.y1 + dragDeltaPY : this.plotArea.y1,
							x2: zoomPX ? this.plotArea.x2 + dragDeltaPX : this.plotArea.x2,
							y2: zoomPY ? this.plotArea.y2 + dragDeltaPY : this.plotArea.y2
						};

					if (this._zoomPanToSelectedRegion(selectedRegion.x1, selectedRegion.y1, selectedRegion.x2, selectedRegion.y2, true)) {
						this._dispatchRangeEvent(&quot;rangeChanging&quot;, &quot;pan&quot;);
						this.render();
						this._dispatchRangeEvent(&quot;rangeChanged&quot;, &quot;pan&quot;);

						this.dragStartPoint.x = x;
						this.dragStartPoint.y = y;

						//clearTimeout(this._panTimerId);
						//this._panTimerId = setTimeout(function () {
						//	_this._dispatchRangeEvent(&quot;rangeChanging&quot;, &quot;pan&quot;);
						//	_this.render();
						//	_this._dispatchRangeEvent(&quot;rangeChanged&quot;, &quot;pan&quot;);
						//}, 0);
					}

				} else if (this.zoomEnabled) {

					this.resetOverlayedCanvas();

					alpha = this.overlaidCanvasCtx.globalAlpha;


					this.overlaidCanvasCtx.fillStyle = &quot;#A89896&quot;;

					var rect = {
						x1: zoomPX ? this.dragStartPoint.x : this.plotArea.x1,
						y1: zoomPY ? this.dragStartPoint.y : this.plotArea.y1,
						x2: zoomPX ? x - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1,
						y2: zoomPY ? y - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1
					};

					if (this.validateRegion(rect.x1, rect.y1, zoomPX ? x : this.plotArea.x2 - this.plotArea.x1, zoomPY ? y : this.plotArea.y2 - this.plotArea.y1, this.zoomType !== &quot;xy&quot;).isValid) {
						this.resetOverlayedCanvas();
						this.overlaidCanvasCtx.fillStyle = &quot;#99B2B5&quot;; //&quot;#A0ABB8&quot;;
					}

					this.overlaidCanvasCtx.globalAlpha = .7;
					this.overlaidCanvasCtx.fillRect(rect.x1, rect.y1, rect.x2, rect.y2);

					this.overlaidCanvasCtx.globalAlpha = alpha;
				}
			}

		} else
			this._toolTip.mouseMoveHandler(x, y);
	}

	//#endregion Events

	//Sets the viewport range of Axis based on the given rect bounds (pixels). Also limits the zooming/panning based on axis bounds. Returns a boolean to indicate whether it was succesful or not based on the selected region.
	Chart.prototype._zoomPanToSelectedRegion = function (px1, py1, px2, py2, keepAxisIndependent) {

		var validateRegion = this.validateRegion(px1, py1, px2, py2, keepAxisIndependent);
		var axesWithValidRange = validateRegion.axesWithValidRange,
			axesRanges = validateRegion.axesRanges;


		if (validateRegion.isValid) {
			for (var i = 0; i &lt; axesWithValidRange.length; i++) {
				var axis = axesWithValidRange[i];
				var param = axesRanges[i];

				axis.setViewPortRange(param.val1, param.val2);
			}
		}
		//else console.log(px1,px2, val2, &quot;-&quot;, val1, &quot;=&quot;, Math.abs(val2 - val1));

		return validateRegion.isValid;
	}

	Chart.prototype.validateRegion = function (px1, py1, px2, py2, keepAxisIndependent) {

		keepAxisIndependent = keepAxisIndependent || false;

		var zoomPX = this.zoomType.indexOf(&quot;x&quot;) &gt;= 0, //Whether to zoom horizontally
			zoomPY = this.zoomType.indexOf(&quot;y&quot;) &gt;= 0, //Whether to zoom vertically
			isValid = false,
            axesWithValidRange = [],
            axes = [],
            axesRanges = [];

		if (this.axisX &amp;&amp; zoomPX)
			axes.push(this.axisX);
		if (this.axisY &amp;&amp; zoomPY)
			axes.push(this.axisY);
		if (this.axisY2 &amp;&amp; zoomPY)
			axes.push(this.axisY2);


		for (var i = 0; i &lt; axes.length; i++) {
			var axis = axes[i];
			//var range = Math.abs(axis.viewportMaximum - axis.viewportMinimum);

			var val1 = axis.convertPixelToValue({ x: px1, y: py1 });
			var val2 = axis.convertPixelToValue({ x: px2, y: py2 });

			if (val1 &gt; val2) {
				var temp = val2;
				val2 = val1;
				val1 = temp;
			}

			if (isFinite(axis.dataInfo.minDiff)) {
				if (!(Math.abs(val2 - val1) &lt; 3 * Math.abs(axis.dataInfo.minDiff)
				|| (val1 &lt; axis.minimum) || (val2 &gt; axis.maximum))) {
					axesWithValidRange.push(axis);
					axesRanges.push({ val1: val1, val2: val2 });

					isValid = true;
				} else if (!keepAxisIndependent) {
					isValid = false;
					break;
				}
			}
		}

		return {
			isValid: isValid, axesWithValidRange: axesWithValidRange, axesRanges: axesRanges
		};
	}

	Chart.prototype.preparePlotArea = function () {

		var plotArea = this.plotArea;

		var yAxis = this.axisY ? this.axisY : this.axisY2;

		if (!isCanvasSupported &amp;&amp; (plotArea.x1 &gt; 0 || plotArea.y1 &gt; 0)) {
			plotArea.ctx.translate(plotArea.x1, plotArea.y1);
		}

		if (this.axisX &amp;&amp; yAxis) {
			plotArea.x1 = this.axisX.lineCoordinates.x1 &lt; this.axisX.lineCoordinates.x2 ? this.axisX.lineCoordinates.x1 : yAxis.lineCoordinates.x1;
			plotArea.y1 = (this.axisX.lineCoordinates.y1 &lt; yAxis.lineCoordinates.y1 ? this.axisX.lineCoordinates.y1 : yAxis.lineCoordinates.y1);

			plotArea.x2 = (this.axisX.lineCoordinates.x2 &gt; yAxis.lineCoordinates.x2 ? this.axisX.lineCoordinates.x2 : yAxis.lineCoordinates.x2);
			plotArea.y2 = this.axisX.lineCoordinates.y2 &gt; this.axisX.lineCoordinates.y1 ? this.axisX.lineCoordinates.y2 : yAxis.lineCoordinates.y2;

			plotArea.width = plotArea.x2 - plotArea.x1;
			plotArea.height = plotArea.y2 - plotArea.y1;
			//plotArea = { x1: x1, y1: y1, x2: x2, y2: y2, width: x2 - x1, height: y2 - y1 };
		} else {
			//ToDo: @sunil
			var freeSpace = this.layoutManager.getFreeSpace();
			plotArea.x1 = freeSpace.x1;
			plotArea.x2 = freeSpace.x2;
			plotArea.y1 = freeSpace.y1;
			plotArea.y2 = freeSpace.y2;

			plotArea.width = freeSpace.width;
			plotArea.height = freeSpace.height;
		}

		if (!isCanvasSupported) {

			plotArea.canvas.width = plotArea.width;
			plotArea.canvas.height = plotArea.height;

			plotArea.canvas.style.left = plotArea.x1 + &quot;px&quot;;
			plotArea.canvas.style.top = plotArea.y1 + &quot;px&quot;;

			if (plotArea.x1 &gt; 0 || plotArea.y1 &gt; 0) {
				plotArea.ctx.translate(-plotArea.x1, -plotArea.y1);
			}
		}

		plotArea.layoutManager = new LayoutManager(plotArea.x1, plotArea.y1, plotArea.x2, plotArea.y2, 2);
	}

	Chart.prototype.getPixelCoordinatesOnPlotArea = function (x, y) {
		return {
			x: this.axisX.getPixelCoordinatesOnAxis(x).x, y: this.axisY.getPixelCoordinatesOnAxis(y).y
		}
		//return { x: 5, y: 10 };
	}

	//#region Render Methods

	Chart.prototype.renderIndexLabels = function (targetCtx) {
		var ctx = targetCtx || this.plotArea.ctx;

		var plotArea = this.plotArea;

		var mid = 0;
		var yMinLimit = 0;
		var yMaxLimit = 0;
		var xMinLimit = 0;
		var xMaxLimit = 0;
		var marginX = 0, marginY = 0; // Margin between label and dataPoint / PlotArea
		var offSetX = 0, offSetY = 0; // Distance to offSet textBlock (top) from dataPoint inorder to position it
		var offset = 0;
		var visibleWidth = 0;
		var visibleHeight = 0;

		for (var i = 0; i &lt; this._indexLabels.length; i++) {

			var indexLabel = this._indexLabels[i];
			var chartTypeLower = indexLabel.chartType.toLowerCase();

			var x, y, angle;

			var fontColor = getProperty(&quot;indexLabelFontColor&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var fontSize = getProperty(&quot;indexLabelFontSize&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var fontFamily = getProperty(&quot;indexLabelFontFamily&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var fontStyle = getProperty(&quot;indexLabelFontStyle&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var fontWeight = getProperty(&quot;indexLabelFontWeight&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var backgroundColor = getProperty(&quot;indexLabelBackgroundColor&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var maxWidth = getProperty(&quot;indexLabelMaxWidth&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var indexLabelWrap = getProperty(&quot;indexLabelWrap&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var indexLabelLineDashType = getProperty(&quot;indexLabelLineDashType&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var indexLabelLineColor = getProperty(&quot;indexLabelLineColor&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var indexLabelLineThickness = isNullOrUndefined(indexLabel.dataPoint.indexLabelLineThickness) ?
											isNullOrUndefined(indexLabel.dataSeries._options.indexLabelLineThickness) ? 0 : indexLabel.dataSeries._options.indexLabelLineThickness
											: indexLabel.dataPoint.indexLabelLineThickness;
			offset = indexLabelLineThickness &gt; 0 ? Math.min(10, (this.plotInfo.axisPlacement === &quot;normal&quot; ? this.plotArea.height : this.plotArea.width) &lt;&lt; 0) : 0;

			var percentAndTotal = {
				percent: null, total: null
			};
			var formatterParameter = null;

			if (indexLabel.dataSeries.type.indexOf(&quot;stacked&quot;) &gt;= 0 || indexLabel.dataSeries.type === &quot;pie&quot; || indexLabel.dataSeries.type === &quot;doughnut&quot;)
				percentAndTotal = this.getPercentAndTotal(indexLabel.dataSeries, indexLabel.dataPoint);

			if (indexLabel.dataSeries.indexLabelFormatter || indexLabel.dataPoint.indexLabelFormatter)
				formatterParameter = {
					chart: this._publicChartReference, dataSeries: indexLabel.dataSeries, dataPoint: indexLabel.dataPoint, index: indexLabel.indexKeyword, total: percentAndTotal.total, percent: percentAndTotal.percent
				};


			var indexLabelText = indexLabel.dataPoint.indexLabelFormatter ? indexLabel.dataPoint.indexLabelFormatter(formatterParameter)
				: indexLabel.dataPoint.indexLabel ? this.replaceKeywordsWithValue(indexLabel.dataPoint.indexLabel, indexLabel.dataPoint, indexLabel.dataSeries, null, indexLabel.indexKeyword)
				: indexLabel.dataSeries.indexLabelFormatter ? indexLabel.dataSeries.indexLabelFormatter(formatterParameter)
				: indexLabel.dataSeries.indexLabel ? this.replaceKeywordsWithValue(indexLabel.dataSeries.indexLabel, indexLabel.dataPoint, indexLabel.dataSeries, null, indexLabel.indexKeyword) : null;

			if (indexLabelText === null || indexLabelText === &quot;&quot;)
				continue;

			var placement = getProperty(&quot;indexLabelPlacement&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var orientation = getProperty(&quot;indexLabelOrientation&quot;, indexLabel.dataPoint, indexLabel.dataSeries);
			var angle = 0;

			var direction = indexLabel.direction; // +1 for above the point and -1 for below the point

			var axisX = indexLabel.dataSeries.axisX;
			var axisY = indexLabel.dataSeries.axisY;
			var isInside = false;


			var textBlock = new TextBlock(ctx, {
				x: 0,
				y: 0,
				maxWidth: maxWidth ? maxWidth : this.width * .5,
				maxHeight: indexLabelWrap ? fontSize * 5 : fontSize * 1.5,
				angle: orientation === &quot;horizontal&quot; ? 0 : -90,
				text: indexLabelText,
				padding: 0,
				backgroundColor: backgroundColor,
				horizontalAlign: &quot;left&quot;,//left, center, right
				fontSize: fontSize,//in pixels
				fontFamily: fontFamily,
				fontWeight: fontWeight, //normal, bold, bolder, lighter,
				fontColor: fontColor,
				fontStyle: fontStyle, // normal, italic, oblique
				textBaseline: &quot;top&quot;
			});

			var textSize = textBlock.measureText();

			//if (indexLabel.dataPoint.x &lt; axisX.viewportMinimum || indexLabel.dataPoint.x &gt; axisX.viewportMaximum || indexLabel.dataPoint.y &lt; axisY.viewportMinimum || indexLabel.dataPoint.y &gt; axisY.viewportMaximum)
			//	continue;

			if (chartTypeLower.indexOf(&quot;line&quot;) &gt;= 0 || chartTypeLower.indexOf(&quot;area&quot;) &gt;= 0
					|| chartTypeLower.indexOf(&quot;bubble&quot;) &gt;= 0 || chartTypeLower.indexOf(&quot;scatter&quot;) &gt;= 0) {

				if (indexLabel.dataPoint.x &lt; axisX.viewportMinimum || indexLabel.dataPoint.x &gt; axisX.viewportMaximum || indexLabel.dataPoint.y &lt; axisY.viewportMinimum || indexLabel.dataPoint.y &gt; axisY.viewportMaximum)
					continue;
			}
			else if (chartTypeLower.indexOf(&quot;column&quot;) &gt;= 0) {
				if (indexLabel.dataPoint.x &lt; axisX.viewportMinimum || indexLabel.dataPoint.x &gt; axisX.viewportMaximum || indexLabel.bounds.y1 &gt; plotArea.y2 || indexLabel.bounds.y2 &lt; plotArea.y1)
					continue;
			}
			else if (chartTypeLower.indexOf(&quot;bar&quot;) &gt;= 0) {
				if (indexLabel.dataPoint.x &lt; axisX.viewportMinimum || indexLabel.dataPoint.x &gt; axisX.viewportMaximum || indexLabel.bounds.x1 &gt; plotArea.x2 || indexLabel.bounds.x2 &lt; plotArea.x1)
					continue;
			}
			else {
				if (indexLabel.dataPoint.x &lt; axisX.viewportMinimum || indexLabel.dataPoint.x &gt; axisX.viewportMaximum)
					continue;
			}

			marginY = 2;
			marginX = 2;

			if (orientation === &quot;horizontal&quot;) {
				visibleWidth = textBlock.width;
				visibleHeight = textBlock.height;
			} else {
				visibleHeight = textBlock.width;
				visibleWidth = textBlock.height;
			}

			if (this.plotInfo.axisPlacement === &quot;normal&quot;) {

				if (chartTypeLower.indexOf(&quot;line&quot;) &gt;= 0 || chartTypeLower.indexOf(&quot;area&quot;) &gt;= 0) {

					placement = &quot;auto&quot;;
					marginY = 4;

				} else if (chartTypeLower.indexOf(&quot;stacked&quot;) &gt;= 0) {

					if (placement === &quot;auto&quot;)
						placement = &quot;inside&quot;;

				} else if (chartTypeLower === &quot;bubble&quot; || chartTypeLower === &quot;scatter&quot;) {

					placement = &quot;inside&quot;;

				}

				x = indexLabel.point.x - visibleWidth / 2;

				if (placement !== &quot;inside&quot;) {	//outside or auto

					yMinLimit = plotArea.y1;
					yMaxLimit = plotArea.y2;

					if (direction &gt; 0) {
						y = indexLabel.point.y - visibleHeight - marginY - offset;

						if (y &lt; yMinLimit) {
							if (placement === &quot;auto&quot;) {
								y = Math.max(indexLabel.point.y, yMinLimit) + marginY + offset;
							}
							else {
								y = yMinLimit + marginY + offset;
							}
							isInside = y + visibleHeight &gt; indexLabel.point.y;
						}
					}
					else {
						y = indexLabel.point.y + marginY + offset;

						if (y &gt; yMaxLimit - visibleHeight - marginY - offset) {
							if (placement === &quot;auto&quot;) {
								y = Math.min(indexLabel.point.y, yMaxLimit) - visibleHeight - marginY - offset;
							}
							else {
								y = yMaxLimit - visibleHeight - marginY - offset;
							}
							isInside = y &lt; indexLabel.point.y;
						}
					}

				} else {


					yMinLimit = Math.max(indexLabel.bounds.y1, plotArea.y1);
					yMaxLimit = Math.min(indexLabel.bounds.y2, plotArea.y2);


					if (chartTypeLower.indexOf(&quot;range&quot;) &gt;= 0) {
						if (direction &gt; 0)
							mid = Math.max(indexLabel.bounds.y1, plotArea.y1) + visibleHeight / 2 + marginY;
						else
							mid = Math.min(indexLabel.bounds.y2, plotArea.y2) - visibleHeight / 2 - marginY;
					}
					else
						mid = (Math.max(indexLabel.bounds.y1, plotArea.y1) + Math.min(indexLabel.bounds.y2, plotArea.y2)) / 2

					if (direction &gt; 0) {
						y = Math.max(indexLabel.point.y, mid) - visibleHeight / 2;

						if (y &lt; yMinLimit &amp;&amp; (chartTypeLower === &quot;bubble&quot; || chartTypeLower === &quot;scatter&quot;)) {
							y = Math.max(indexLabel.point.y - visibleHeight - marginY, plotArea.y1 + marginY);
						}
					}
					else {
						y = Math.min(indexLabel.point.y, mid) - visibleHeight / 2;

						if (y &gt; yMaxLimit - visibleHeight - marginY &amp;&amp; (chartTypeLower === &quot;bubble&quot; || chartTypeLower === &quot;scatter&quot;)) {
							y = Math.min(indexLabel.point.y + marginY, plotArea.y2 - visibleHeight - marginY);
						}
					}

					// Make Sure that it does not overlap the axis line
					y = Math.min(y, yMaxLimit - visibleHeight);
				}
			}
			else {

				if (chartTypeLower.indexOf(&quot;line&quot;) &gt;= 0 || chartTypeLower.indexOf(&quot;area&quot;) &gt;= 0
					|| chartTypeLower.indexOf(&quot;scatter&quot;) &gt;= 0) {

					placement = &quot;auto&quot;;
					marginX = 4;

				} else if (chartTypeLower.indexOf(&quot;stacked&quot;) &gt;= 0) {

					if (placement === &quot;auto&quot;)
						placement = &quot;inside&quot;;

				} else if (chartTypeLower === &quot;bubble&quot;) {

					placement = &quot;inside&quot;;

				}

				y = indexLabel.point.y - visibleHeight / 2;

				if (placement !== &quot;inside&quot;) {	//outside or auto

					xMinLimit = plotArea.x1;
					xMaxLimit = plotArea.x2;

					if (direction &lt; 0) {
						x = indexLabel.point.x - visibleWidth - marginX - offset;

						if (x &lt; xMinLimit) {
							if (placement === &quot;auto&quot;) {
								x = Math.max(indexLabel.point.x, xMinLimit) + marginX + offset;
							}
							else {
								x = xMinLimit + marginX + offset;
							}
							isInside = x + visibleWidth &gt; indexLabel.point.x;
						}
					}
					else {
						x = indexLabel.point.x + marginX + offset;

						if (x &gt; xMaxLimit - visibleWidth - marginX - offset) {
							if (placement === &quot;auto&quot;) {
								x = Math.min(indexLabel.point.x, xMaxLimit) - visibleWidth - marginX - offset;
							}
							else {
								x = xMaxLimit - visibleWidth - marginX - offset;
							}
							isInside = x &lt; indexLabel.point.x;
						}
					}

				} else {

					xMinLimit = Math.max(indexLabel.bounds.x1, plotArea.x1);
					xMaxLimit = Math.min(indexLabel.bounds.x2, plotArea.x2);

					if (chartTypeLower.indexOf(&quot;range&quot;) &gt;= 0) {
						if (direction &lt; 0)
							mid = Math.max(indexLabel.bounds.x1, plotArea.x1) + visibleWidth / 2 + marginX;
						else
							mid = Math.min(indexLabel.bounds.x2, plotArea.x2) - visibleWidth / 2 - marginX;
					}
					else
						var mid = (Math.max(indexLabel.bounds.x1, plotArea.x1) + Math.min(indexLabel.bounds.x2, plotArea.x2)) / 2;

					if (direction &lt; 0) {
						x = Math.max(indexLabel.point.x, mid) - visibleWidth / 2;

						//if (y &lt; xMinLimit) {
						//	y = Math.max(indexLabel.point.y - visibleHeight - marginY, plotArea.y1 + marginY);
						//}
					}
					else {
						x = Math.min(indexLabel.point.x, mid) - visibleWidth / 2;

						//if (y &gt; xMaxLimit - visibleHeight - marginY) {
						//	y = Math.min(indexLabel.point.y + marginY, plotArea.y2 - visibleHeight - marginY);
						//}
					}

					// Make Sure that it does not overlap the axis line
					x = Math.max(x, xMinLimit);
				}
			}

			if (orientation === &quot;vertical&quot;) {
				y += visibleHeight;
			}

			//y -= 5;
			textBlock.x = x;
			textBlock.y = y;

			//console.log(textBlock.text + &quot;: &quot; + textBlock.x + &quot;; &quot; + textBlock.y);

			textBlock.render(true);

			//indexLabel connection line rendering logic not for pie and doughnut, use textSize later on
			if (indexLabelLineThickness &amp;&amp; placement !== &quot;inside&quot; &amp;&amp;
				(chartTypeLower.indexOf(&quot;bar&quot;) &lt; 0 &amp;&amp; indexLabel.point.x &gt; plotArea.x1 &amp;&amp; indexLabel.point.x &lt; plotArea.x2 || !isInside) &amp;&amp;
				(chartTypeLower.indexOf(&quot;column&quot;) &lt; 0 &amp;&amp; indexLabel.point.y &gt; plotArea.y1 &amp;&amp; indexLabel.point.y &lt; plotArea.y2 || !isInside)) {

				ctx.lineWidth = indexLabelLineThickness;
				ctx.strokeStyle = indexLabelLineColor ? indexLabelLineColor : &quot;gray&quot;;
				if (ctx.setLineDash) {
					ctx.setLineDash(getLineDashArray(indexLabelLineDashType, indexLabelLineThickness));
				}
				ctx.beginPath();
				ctx.moveTo(indexLabel.point.x, indexLabel.point.y);

				if (chartTypeLower.indexOf(&quot;bar&quot;) &gt;= 0)
					ctx.lineTo(x + (indexLabel.direction &gt; 0 ? 0 : visibleWidth), y + (orientation === &quot;horizontal&quot; ? visibleHeight : -visibleHeight) / 2);
				else if (chartTypeLower.indexOf(&quot;column&quot;) &gt;= 0)
					ctx.lineTo(x + visibleWidth / 2, y + ((indexLabel.direction &gt; 0 ? visibleHeight : -visibleHeight) + (orientation === &quot;horizontal&quot; ? visibleHeight : -visibleHeight)) / 2);
				else
					ctx.lineTo(x + visibleWidth / 2, y + ((y &lt; indexLabel.point.y ? visibleHeight : -visibleHeight) + (orientation === &quot;horizontal&quot; ? visibleHeight : -visibleHeight)) / 2);
				ctx.stroke();
			}
		}

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0, startTimePercent: .7
		};
		return animationInfo;
	}

	Chart.prototype.renderLine = function (plotUnit) {

		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;
		if (totalDataSeries &lt;= 0)
			return;

		var ghostCtx = this._eventManager.ghostCtx;
		//var ghostCtx = this.overlaidCanvasCtx;

		ctx.save();

		var plotArea = this.plotArea;

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		var markers = [];

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			ctx.lineWidth = dataSeries.lineThickness;
			var dataPoints = dataSeries.dataPoints;
			var currentLineDashType = &quot;solid&quot;;

			if (ctx.setLineDash) {
				var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
				currentLineDashType = dataSeries.lineDashType;
				var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
				ctx.setLineDash(lineDashType);
			}

			var seriesId = dataSeries.id;
			this._eventManager.objectMap[seriesId] = {
				objectType: &quot;dataSeries&quot;, dataSeriesIndex: dataSeriesIndex
			};
			var hexColor = intToHexColorString(seriesId);
			ghostCtx.strokeStyle = hexColor;
			//ghostCtx.lineWidth = dataSeries.lineThickness;
			ghostCtx.lineWidth = dataSeries.lineThickness &gt; 0 ? Math.max(dataSeries.lineThickness, 4) : 0;

			var colorSet = dataSeries._colorSet;
			var color = dataSeries._options.lineColor ? dataSeries._options.lineColor : colorSet[0];
			var currentStrokeStyle = color;
			ctx.strokeStyle = color;

			var isFirstDataPointInPlotArea = true;
			var i = 0, x, y;
			var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number back and forth.

			//if (!dataSeries._options.markerSize &amp;&amp; dataSeries.dataPoints.length &lt; 1000)
			//    dataSeries.markerSize = 8;
			ctx.beginPath();
			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				//dataSeries.noDataPointsInPlotArea = 0
				var prevDataNull = false;
				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax &amp;&amp; !(dataSeries.connectNullData &amp;&amp; prevDataNull))
						continue;

					//if (!isFinite(dataPoints[i].y))
					//    continue;

					if (typeof (dataPoints[i].y) !== &quot;number&quot;) {
						if (i &gt; 0 &amp;&amp; !(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea)) {// if first dataPoint is null then no need to call stroke method
							ctx.stroke();
							if (isCanvasSupported) {
								ghostCtx.stroke();
							}
						}


						prevDataNull = true;
						continue;
					}

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
					};


					//dataSeries.noDataPointsInPlotArea++;

					if (isFirstDataPointInPlotArea || prevDataNull) {

						//For drawing line over nonNull dataPoints
						if (!isFirstDataPointInPlotArea &amp;&amp; dataSeries.connectNullData) {
							//Applying nullLineDshType If lineDashType at dataPoints not mentoioned in prevuous dataPoints
							if (ctx.setLineDash &amp;&amp; (dataSeries._options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType &amp;&amp; dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
								ctx.stroke();
								//if (isCanvasSupported) {
								//	ghostCtx.stroke();
								//}
								currentLineDashType = dataSeries.nullDataLineDashType;
								ctx.setLineDash(nullDataLineDashType);
							}

							ctx.lineTo(x, y);
							if (isCanvasSupported)
								ghostCtx.lineTo(x, y);

						} else { //If connectNullData = false
							ctx.beginPath();
							ctx.moveTo(x, y);
							if (isCanvasSupported) {
								ghostCtx.beginPath();
								ghostCtx.moveTo(x, y);
							}
						}

						isFirstDataPointInPlotArea = false;
						prevDataNull = false;
					} else {

						ctx.lineTo(x, y);

						if (isCanvasSupported)
							ghostCtx.lineTo(x, y);

						if (i % 500 == 0) {
							ctx.stroke();
							ctx.beginPath();
							ctx.moveTo(x, y);

							if (isCanvasSupported) {
								ghostCtx.stroke();
								ghostCtx.beginPath();
								ghostCtx.moveTo(x, y);
							}
						}
					}

					if (i &lt; dataPoints.length - 1 &amp;&amp; (currentStrokeStyle !== (dataPoints[i].lineColor || color) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

						ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(x, y);
						//if (isCanvasSupported) {
						//	ghostCtx.stroke();
						//	ghostCtx.beginPath();
						//	ghostCtx.moveTo(x, y);
						//}

						currentStrokeStyle = dataPoints[i].lineColor || color;
						ctx.strokeStyle = currentStrokeStyle;
						if (ctx.setLineDash)
							if (dataPoints[i].lineDashType) {
								currentLineDashType = dataPoints[i].lineDashType;
								ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
							}
							else {
								currentLineDashType = dataSeries.lineDashType;
								ctx.setLineDash(lineDashType);
							}
					}


					//Render Marker
					if (dataPoints[i].markerSize &gt; 0 || dataSeries.markerSize &gt; 0) {

						var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
						markers.push(markerProps);

						//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
						//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
						//}

						var markerColor = intToHexColorString(id);

						//window.console.log(&quot;index: &quot; + i + &quot;; id: &quot; + id + &quot;; hex: &quot; + markerColor);

						if (isCanvasSupported) {
							markers.push({
								x: x, y: y, ctx: ghostCtx,
								type: markerProps.type,
								size: markerProps.size,
								color: markerColor,
								borderColor: markerColor,
								borderThickness: markerProps.borderThickness
							});
						}
					}

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;line&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x, y: y
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							color: color
						});

					}

				}

				ctx.stroke();

				if (isCanvasSupported)
					ghostCtx.stroke();
			}

		}


		RenderHelper.drawMarkers(markers);
		ctx.restore();

		ctx.beginPath();

		if (isCanvasSupported)
			ghostCtx.beginPath();

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
		};
		return animationInfo;
	}

	Chart.prototype.renderStepLine = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;
		if (totalDataSeries &lt;= 0)
			return;

		var ghostCtx = this._eventManager.ghostCtx;
		//var ghostCtx = this.overlaidCanvasCtx;

		ctx.save();

		var plotArea = this.plotArea;

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		var markers = [];

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			ctx.lineWidth = dataSeries.lineThickness;
			var dataPoints = dataSeries.dataPoints;
			var currentLineDashType = &quot;solid&quot;;

			if (ctx.setLineDash) {
				var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
				currentLineDashType = dataSeries.lineDashType;
				var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
				ctx.setLineDash(lineDashType);
			}

			var seriesId = dataSeries.id;
			this._eventManager.objectMap[seriesId] = {
				objectType: &quot;dataSeries&quot;, dataSeriesIndex: dataSeriesIndex
			};
			var hexColor = intToHexColorString(seriesId);
			ghostCtx.strokeStyle = hexColor;
			//ghostCtx.lineWidth = dataSeries.lineThickness;
			ghostCtx.lineWidth = dataSeries.lineThickness &gt; 0 ? Math.max(dataSeries.lineThickness, 4) : 0;

			var colorSet = dataSeries._colorSet;
			var color = dataSeries._options.lineColor ? dataSeries._options.lineColor : colorSet[0];
			var currentStrokeStyle = color;
			ctx.strokeStyle = color;

			var isFirstDataPointInPlotArea = true;
			var i = 0, x, y;
			var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number back and forth.

			//if (!dataSeries._options.markerSize &amp;&amp; dataSeries.dataPoints.length &lt; 1000)
			//    dataSeries.markerSize = 8;
			ctx.beginPath();
			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				//dataSeries.noDataPointsInPlotArea = 0
				var prevDataNull = false;
				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax &amp;&amp; !(dataSeries.connectNullData &amp;&amp; prevDataNull))
						continue;

					//if (!isFinite(dataPoints[i].y))
					//    continue;

					if (typeof (dataPoints[i].y) !== &quot;number&quot;) {
						if (i &gt; 0 &amp;&amp; !(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea)) {// if first dataPoint is null then no need to call stroke method
							ctx.stroke();

							if (isCanvasSupported) {
								ghostCtx.stroke();
							}
						}

						prevDataNull = true;
						continue;
					}

					var prevY = y;

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
					};


					//dataSeries.noDataPointsInPlotArea++;

					if (isFirstDataPointInPlotArea || prevDataNull) {

						if (!isFirstDataPointInPlotArea &amp;&amp; dataSeries.connectNullData) {

							if (ctx.setLineDash &amp;&amp; (dataSeries._options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType &amp;&amp; dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
								ctx.stroke();
								//if(!dataPoints[prevNonNullDataPointIndex].lineDashType)
								currentLineDashType = dataSeries.nullDataLineDashType;
								ctx.setLineDash(nullDataLineDashType);
							}
							ctx.lineTo(x, prevY);
							ctx.lineTo(x, y);
							if (isCanvasSupported) {
								ghostCtx.lineTo(x, prevY);
								ghostCtx.lineTo(x, y);
							}
						}
						else { //connectNullData = false
							ctx.beginPath();
							ctx.moveTo(x, y);
							if (isCanvasSupported) {
								ghostCtx.beginPath();
								ghostCtx.moveTo(x, y);
							}
						}

						isFirstDataPointInPlotArea = false;
						prevDataNull = false;
					} else {

						ctx.lineTo(x, prevY);
						if (isCanvasSupported)
							ghostCtx.lineTo(x, prevY);

						ctx.lineTo(x, y);
						if (isCanvasSupported)
							ghostCtx.lineTo(x, y);

						if (i % 500 == 0) {
							ctx.stroke();
							ctx.beginPath();
							ctx.moveTo(x, y);

							if (isCanvasSupported) {
								ghostCtx.stroke();
								ghostCtx.beginPath();
								ghostCtx.moveTo(x, y);
							}
						}

					}

					if (i &lt; dataPoints.length - 1 &amp;&amp; (currentStrokeStyle !== (dataPoints[i].lineColor || color) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint
						ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(x, y);
						currentStrokeStyle = dataPoints[i].lineColor || color;
						ctx.strokeStyle = currentStrokeStyle;
						if (ctx.setLineDash)
							if (dataPoints[i].lineDashType) {
								currentLineDashType = dataPoints[i].lineDashType;
								ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
							}
							else {
								currentLineDashType = dataSeries.lineDashType;
								ctx.setLineDash(lineDashType);
							}
					}

					//Render Marker
					if (dataPoints[i].markerSize &gt; 0 || dataSeries.markerSize &gt; 0) {

						var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
						markers.push(markerProps);

						//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
						//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
						//}

						var markerColor = intToHexColorString(id);

						//window.console.log(&quot;index: &quot; + i + &quot;; id: &quot; + id + &quot;; hex: &quot; + markerColor);
						if (isCanvasSupported) {
							markers.push({
								x: x, y: y, ctx: ghostCtx,
								type: markerProps.type,
								size: markerProps.size,
								color: markerColor,
								borderColor: markerColor,
								borderThickness: markerProps.borderThickness
							});
						}
					}

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;stepLine&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x, y: y
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							color: color
						});

					}

				}

				ctx.stroke();
				if (isCanvasSupported)
					ghostCtx.stroke();
			}
		}


		RenderHelper.drawMarkers(markers);
		ctx.restore();

		ctx.beginPath();

		if (isCanvasSupported)
			ghostCtx.beginPath();

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
		};
		return animationInfo;
	}

	function getBezierPoints(points, defaultTension) {
		var bezierPoints = [],
			tension;

		for (var i = 0; i &lt; points.length; i++) {

			if (i == 0) {
				bezierPoints.push(points[0]);
				continue;
			}

			var i1, i2, pointIndex;

			pointIndex = i - 1;
			i1 = pointIndex === 0 ? 0 : pointIndex - 1;
			i2 = pointIndex === points.length - 1 ? pointIndex : pointIndex + 1;
			tension = Math.abs((points[i2].x - points[i1].x) / ((points[i2].x - points[pointIndex].x) === 0 ? 0.01 : (points[i2].x - points[pointIndex].x))) * (defaultTension - 1) / 2 + 1;

			var drv1 = {
				x: (points[i2].x - points[i1].x) / tension, y: (points[i2].y - points[i1].y) / tension
			}

			if (points[pointIndex].x &gt; points[i1].x &amp;&amp; drv1.x &gt; 0 || points[pointIndex].x &lt; points[i1].x &amp;&amp; drv1.x &lt; 0)
				var cp1 = {
					x: points[pointIndex].x + drv1.x / 3, y: points[pointIndex].y + drv1.y / 3
				}
			else
				var cp1 = {
					x: points[pointIndex].x, y: points[pointIndex].y + drv1.y / 9
				}

			bezierPoints[bezierPoints.length] = cp1;


			pointIndex = i;
			i1 = pointIndex === 0 ? 0 : pointIndex - 1;
			i2 = pointIndex === points.length - 1 ? pointIndex : pointIndex + 1;
			tension = Math.abs((points[i2].x - points[i1].x) / ((points[pointIndex].x - points[i1].x) === 0 ? 0.01 : (points[pointIndex].x - points[i1].x))) * (defaultTension - 1) / 2 + 1;
			var drv2 = {
				x: (points[i2].x - points[i1].x) / tension, y: (points[i2].y - points[i1].y) / tension
			}

			if (points[pointIndex].x &gt; points[i1].x &amp;&amp; drv2.x &gt; 0 || points[pointIndex].x &lt; points[i1].x &amp;&amp; drv2.x &lt; 0)
				var cp2 = {
					x: points[pointIndex].x - drv2.x / 3, y: points[pointIndex].y - drv2.y / 3
				}
			else
				var cp2 = {
					x: points[pointIndex].x, y: points[pointIndex].y - drv2.y / 9
				}

			bezierPoints[bezierPoints.length] = cp2;

			bezierPoints[bezierPoints.length] = points[i];
		}

		return bezierPoints;
	}

	Chart.prototype.renderSpline = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;
		if (totalDataSeries &lt;= 0)
			return;

		var ghostCtx = this._eventManager.ghostCtx;

		ctx.save();

		var plotArea = this.plotArea;

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		var markers = [];

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			ctx.lineWidth = dataSeries.lineThickness;
			var dataPoints = dataSeries.dataPoints;
			var currentLineDashType = &quot;solid&quot;;

			if (ctx.setLineDash) {
				var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
				currentLineDashType = dataSeries.lineDashType;
				var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
				ctx.setLineDash(lineDashType);
			}

			var seriesId = dataSeries.id;
			this._eventManager.objectMap[seriesId] = {
				objectType: &quot;dataSeries&quot;, dataSeriesIndex: dataSeriesIndex
			};
			var hexColor = intToHexColorString(seriesId);
			ghostCtx.strokeStyle = hexColor;
			//ghostCtx.lineWidth = dataSeries.lineThickness;
			ghostCtx.lineWidth = dataSeries.lineThickness &gt; 0 ? Math.max(dataSeries.lineThickness, 4) : 0;

			var colorSet = dataSeries._colorSet;
			var color = dataSeries._options.lineColor ? dataSeries._options.lineColor : colorSet[0];
			var currentStrokeStyle = color;
			ctx.strokeStyle = color;

			var isFirstDataPointInPlotArea = true;
			var i = 0, x, y;
			var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number back and forth.

			//if (!dataSeries._options.markerSize &amp;&amp; dataSeries.dataPoints.length &lt; 1000)
			//    dataSeries.markerSize = 8;

			var pixels = [];

			ctx.beginPath();
			if (dataPoints.length &gt; 0) {

				var prevDataNull = false;
				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax &amp;&amp; !(dataSeries.connectNullData &amp;&amp; prevDataNull))
						continue;

					//if (!isFinite(dataPoints[i].y))
					//    continue;

					if (typeof (dataPoints[i].y) !== &quot;number&quot;) {
						if (i &gt; 0 &amp;&amp; !prevDataNull) {// if first dataPoint is null then no need to call stroke method
							if (dataSeries.connectNullData) {
								if (ctx.setLineDash &amp;&amp; pixels.length &gt; 0 &amp;&amp; (dataSeries._options.nullDataLineDashType || !dataPoints[i - 1].lineDashType)) {
									pixels[pixels.length - 1].newLineDashArray = nullDataLineDashType;
									currentLineDashType = dataSeries.nullDataLineDashType;
								}
							}
							else {
								renderBezier(pixels);
								pixels = [];
							}

						}

						prevDataNull = true;
						continue;
					}

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
					};

					pixels[pixels.length] = {
						x: x, y: y
					};

					//Drawing cunnectNullData
					/*if (prevDataNull &amp;&amp; dataSeries.connectNullData &amp;&amp; ctx.setLineDash &amp;&amp; !isFirstDataPointInPlotArea &amp;&amp; (currentLineDashType === dataSeries.nullDataLineDashType &amp;&amp; dataSeries.nullDataLineDashType !== dataSeries.lineDashType )) {
						newLineDashArray = lineDashType;
							currentLineDashType = dataSeries.lineDashType;
					}*/

					if (i &lt; dataPoints.length - 1 &amp;&amp; (currentStrokeStyle !== (dataPoints[i].lineColor || color) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

						currentStrokeStyle = dataPoints[i].lineColor || color;
						pixels[pixels.length - 1].newStrokeStyle = currentStrokeStyle;
						if (ctx.setLineDash)
							if (dataPoints[i].lineDashType) {
								currentLineDashType = dataPoints[i].lineDashType;
								pixels[pixels.length - 1].newLineDashArray = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
							}
							else {
								currentLineDashType = dataSeries.lineDashType;
								pixels[pixels.length - 1].newLineDashArray = lineDashType;
							}
					}


					//Add Markers
					if (dataPoints[i].markerSize &gt; 0 || dataSeries.markerSize &gt; 0) {

						var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
						markers.push(markerProps);

						//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
						//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
						//}

						var markerColor = intToHexColorString(id);

						//window.console.log(&quot;index: &quot; + i + &quot;; id: &quot; + id + &quot;; hex: &quot; + markerColor);
						if (isCanvasSupported) {
							markers.push({
								x: x, y: y, ctx: ghostCtx,
								type: markerProps.type,
								size: markerProps.size,
								color: markerColor,
								borderColor: markerColor,
								borderThickness: markerProps.borderThickness
							});
						}
					}

					//Add Labels
					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;spline&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x, y: y
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							color: color
						});

					}

					isFirstDataPointInPlotArea = false;
					prevDataNull = false;

				}
			}

			renderBezier(pixels);
		}

		RenderHelper.drawMarkers(markers);
		ctx.restore();

		ctx.beginPath();

		if (isCanvasSupported)
			ghostCtx.beginPath();

		function renderBezier(pixels) {

			var bp = getBezierPoints(pixels, 2);

			if (bp.length &gt; 0) {
				ctx.beginPath();
				if (isCanvasSupported)
					ghostCtx.beginPath();

				ctx.moveTo(bp[0].x, bp[0].y);
				if (bp[0].newStrokeStyle)
					ctx.strokeStyle = bp[0].newStrokeStyle;
				if (bp[0].newLineDashArray)
					ctx.setLineDash(bp[0].newLineDashArray);

				if (isCanvasSupported)
					ghostCtx.moveTo(bp[0].x, bp[0].y);

				for (var i = 0; i &lt; bp.length - 3; i += 3) {

					ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

					if (isCanvasSupported)
						ghostCtx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

					if (i &gt; 0 &amp;&amp; i % 3000 === 0 || bp[i + 3].newStrokeStyle || bp[i + 3].newLineDashArray) {
						ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(bp[i + 3].x, bp[i + 3].y);
						if (bp[i + 3].newStrokeStyle)
							ctx.strokeStyle = bp[i + 3].newStrokeStyle;
						if (bp[i + 3].newLineDashArray)
							ctx.setLineDash(bp[i + 3].newLineDashArray);

						if (isCanvasSupported) {
							ghostCtx.stroke();
							ghostCtx.beginPath();
							ghostCtx.moveTo(bp[i + 3].x, bp[i + 3].y);
						}
					}
				}

				ctx.stroke();

				if (isCanvasSupported)
					ghostCtx.stroke();
			}
		}

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
		};
		return animationInfo;
	}

	var drawRect = function (ctx, x1, y1, x2, y2, color, borderThickness, borderColor, top, bottom, left, right, fillOpacity) {
		if (typeof (fillOpacity) === &quot;undefined&quot;)
			fillOpacity = 1;

		borderThickness = borderThickness || 0;
		borderColor = borderColor || &quot;black&quot;;
		//alert(&quot;top&quot;+ top + &quot;bottom&quot; + bottom + &quot; lt&quot; + left+ &quot;rt&quot; + right )
		var a1 = x1, a2 = x2, b1 = y1, b2 = y2, edgeY, edgeX;
		if (x2 - x1 &gt; 15 &amp;&amp; y2 - y1 &gt; 15)
			var bevelDepth = 8;
		else
			var bevelDepth = 0.35 * Math.min((x2 - x1), (y2 - y1));
		//alert(a1 + &quot;&quot; + a2);
		var color2 = &quot;rgba(255, 255, 255, .4)&quot;;
		var color3 = &quot;rgba(255, 255, 255, 0.1)&quot;;
		//color1 = &quot;rgba(&quot; + r + &quot;,&quot; + g + &quot;, &quot; + b + &quot;,1)&quot;;
		var color1 = color;

		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.save();
		ctx.fillStyle = color1;

		ctx.globalAlpha = fillOpacity;
		ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
		ctx.globalAlpha = 1;

		if (borderThickness &gt; 0) {
			var offset = borderThickness % 2 === 0 ? 0 : .5;
			ctx.beginPath();
			ctx.lineWidth = borderThickness;
			ctx.strokeStyle = borderColor;
			ctx.moveTo(x1, y1);
			ctx.rect(x1 - offset, y1 - offset, x2 - x1 + 2 * offset, y2 - y1 + 2 * offset);
			ctx.stroke();
		}

		ctx.restore();
		//   ctx.beginPath();
		if (top === true) {
			// alert(x1 + &quot;&quot; + x2 + &quot; &quot; + bevelDepth);
			ctx.save();
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x1 + bevelDepth, y1 + bevelDepth);
			ctx.lineTo(x2 - bevelDepth, y1 + bevelDepth);
			ctx.lineTo(x2, y1);
			ctx.closePath();
			var grd = ctx.createLinearGradient((x2 + x1) / 2, b1 + bevelDepth, (x2 + x1) / 2, b1);
			grd.addColorStop(0, color1);
			grd.addColorStop(1, color2);
			ctx.fillStyle = grd;
			ctx.fill();
			//              ctx.stroke();
			ctx.restore();
		}


		if (bottom === true) {
			ctx.save();
			ctx.beginPath();
			ctx.moveTo(x1, y2);
			ctx.lineTo(x1 + bevelDepth, y2 - bevelDepth);
			ctx.lineTo(x2 - bevelDepth, y2 - bevelDepth);
			ctx.lineTo(x2, y2);
			ctx.closePath();
			var grd = ctx.createLinearGradient((x2 + x1) / 2, b2 - bevelDepth, (x2 + x1) / 2, b2);
			grd.addColorStop(0, color1);
			grd.addColorStop(1, color2);
			ctx.fillStyle = grd;
			//       ctx.stroke();
			ctx.fill();
			ctx.restore();
		}

		if (left === true) {
			//   alert(x1)
			ctx.save();
			ctx.beginPath();
			ctx.moveTo(x1, y1)
			ctx.lineTo(x1 + bevelDepth, y1 + bevelDepth);
			ctx.lineTo(x1 + bevelDepth, y2 - bevelDepth);
			ctx.lineTo(x1, y2);
			ctx.closePath();
			var grd = ctx.createLinearGradient(a1 + bevelDepth, (y2 + y1) / 2, a1, (y2 + y1) / 2);
			grd.addColorStop(0, color1);
			grd.addColorStop(1, color3);
			ctx.fillStyle = grd;
			ctx.fill();
			//     ctx.stroke();
			ctx.restore();
		}


		if (right === true) {
			ctx.save();
			ctx.beginPath();
			ctx.moveTo(x2, y1)
			ctx.lineTo(x2 - bevelDepth, y1 + bevelDepth);
			ctx.lineTo(x2 - bevelDepth, y2 - bevelDepth);
			ctx.lineTo(x2, y2);
			var grd = ctx.createLinearGradient(a2 - bevelDepth, (y2 + y1) / 2, a2, (y2 + y1) / 2);
			grd.addColorStop(0, color1);
			grd.addColorStop(1, color3);
			ctx.fillStyle = grd;
			grd.addColorStop(0, color1);
			grd.addColorStop(1, color3);
			ctx.fillStyle = grd;
			ctx.fill();
			ctx.closePath();
			//          ctx.stroke();
			ctx.restore();
		}
		//	

	}

	Chart.prototype.renderColumn = function (plotUnit) {

		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var i = 0, x, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number from dataTime everytime it is used.

		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min((this.width * .15), this.plotArea.width / plotUnit.plotType.totalDataSeries * .9) &lt;&lt; 0;

		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

		if (!isFinite(xMinDiff)) {
			xMinDiff = Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum) * .3;
		}

		var barWidth = this.dataPointWidth ? this.dataPointWidth : (((plotArea.width / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / plotUnit.plotType.totalDataSeries * .9) &lt;&lt; 0;

		if (this.dataPointMaxWidth &amp;&amp; minBarWidth &gt; maxBarWidth)
			minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

		if (!this.dataPointMaxWidth &amp;&amp; this.dataPointMinWidth &amp;&amp; maxBarWidth &lt; minBarWidth)
			maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

		if (barWidth &lt; minBarWidth)
			barWidth = minBarWidth;

		if (barWidth &gt; maxBarWidth)
			barWidth = maxBarWidth;


		ctx.save();
		if (isCanvasSupported)
			this._eventManager.ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    this._eventManager.ghostCtx.beginPath();
			this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			this._eventManager.ghostCtx.clip();
		}
		//ctx.beginPath();

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;


			// Reducing pixelPerUnit by 1 just to overcome any problems due to rounding off of pixels.
			//dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);

			//var offsetX = barWidth * plotUnit.index &lt;&lt; 0;


			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				var bevelEnabled = (barWidth &gt; 5) &amp;&amp; dataSeries.bevelEnabled ? true : false;

				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (typeof (dataPoints[i].y) !== &quot;number&quot;)
						continue;

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					var x1 = x - (plotUnit.plotType.totalDataSeries * barWidth / 2) + ((plotUnit.previousDataSeriesCount + j) * barWidth) &lt;&lt; 0;
					var x2 = x1 + barWidth &lt;&lt; 0;
					var y1;
					var y2;

					if (dataPoints[i].y &gt;= 0) {
						y1 = y;

						y2 = yZeroToPixel;

						if (y1 &gt; y2) {
							var temp = y1;
							y1 = y2;
							y2 = y1;
						}

					} else {
						y2 = y;

						y1 = yZeroToPixel;

						if (y1 &gt; y2) {
							var temp = y1;
							y1 = y2;
							y2 = y1;
						}
					}

					color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
					drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled &amp;&amp; (dataPoints[i].y &gt;= 0), (dataPoints[i].y &lt; 0) &amp;&amp; bevelEnabled, false, false, dataSeries.fillOpacity);

					//if (dataSeries.markerType &amp;&amp; dataSeries.markerSize &gt; 0) {
					//    RenderHelper.drawMarker(x1 + (x2 - x1) / 2, y, ctx, dataSeries.markerType, dataSeries.markerSize, color, dataSeries.markerBorderColor, dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : 1);
					//}

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
					};

					color = intToHexColorString(id);
					if (isCanvasSupported)
						drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;column&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x1 + (x2 - x1) / 2, y: dataPoints[i].y &gt;= 0 ? y1 : y2
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							bounds: {
								x1: x1, y1: Math.min(y1, y2), x2: x2, y2: Math.max(y1, y2)
							},
							color: color
						});

					}
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationBase = Math.min(yZeroToPixel, plotUnit.axisY.boundingRect.y2);
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.yScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
		};
		return animationInfo;
	}

	Chart.prototype.renderStackedColumn = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var offsetPositiveY = [];
		var offsetNegativeY = [];

		var i = 0, x, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number everytime it is accessed.

		//var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) &lt;&lt; 0;
		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : this.width * .15 &lt;&lt; 0;

		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

		if (!isFinite(xMinDiff)) {
			xMinDiff = Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum) * .3;
		}

		var barWidth = this.dataPointWidth ? this.dataPointWidth : (((plotArea.width / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / plotUnit.plotType.plotUnits.length * .9) &lt;&lt; 0;

		if (this.dataPointMaxWidth &amp;&amp; minBarWidth &gt; maxBarWidth)
			minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

		if (!this.dataPointMaxWidth &amp;&amp; this.dataPointMinWidth &amp;&amp; maxBarWidth &lt; minBarWidth)
			maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

		if (barWidth &lt; minBarWidth)
			barWidth = minBarWidth;

		if (barWidth &gt; maxBarWidth)
			barWidth = maxBarWidth;


		ctx.save();
		if (isCanvasSupported)
			this._eventManager.ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    this._eventManager.ghostCtx.beginPath();
			this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			this._eventManager.ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];
			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;

			// Reducing pixelPerUnit by 1 just to overcome any problems due to rounding off of pixels.
			//dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);


			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				var bevelEnabled = (barWidth &gt; 5) &amp;&amp; dataSeries.bevelEnabled ? true : false;

				ctx.strokeStyle = &quot;#4572A7 &quot;;

				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;


					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (typeof (dataPoints[i].y) !== &quot;number&quot;)
						continue;

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum));

					var x1 = x - (plotUnit.plotType.plotUnits.length * barWidth / 2) + (plotUnit.index * barWidth) &lt;&lt; 0;
					var x2 = x1 + barWidth &lt;&lt; 0;
					var y1;
					var y2;


					if (dataPoints[i].y &gt;= 0) {
						var offset = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : 0;

						y1 = y - offset;
						y2 = yZeroToPixel - offset;

						offsetPositiveY[dataPointX] = offset + (y2 - y1);

					} else {
						var offset = offsetNegativeY[dataPointX] ? offsetNegativeY[dataPointX] : 0;

						y2 = y + offset;
						y1 = yZeroToPixel + offset;

						offsetNegativeY[dataPointX] = offset + (y2 - y1);
					}

					color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];

					drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled &amp;&amp; (dataPoints[i].y &gt;= 0), (dataPoints[i].y &lt; 0) &amp;&amp; bevelEnabled, false, false, dataSeries.fillOpacity);

					//if (dataSeries.markerType &amp;&amp; dataSeries.markerSize &gt; 0) {
					//    RenderHelper.drawMarker(x1 + (x2 - x1)/2, y1, ctx, dataSeries.markerType, dataSeries.markerSize, color, dataSeries.markerBorderColor, dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : 1);
					//}

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
					};
					color = intToHexColorString(id);

					if (isCanvasSupported)
						drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);


					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;stackedColumn&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x, y: dataPoints[i].y &gt;= 0 ? y1 : y2
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							bounds: {
								x1: x1, y1: Math.min(y1, y2), x2: x2, y2: Math.max(y1, y2)
							},
							color: color
						});

					}
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationBase = Math.min(yZeroToPixel, plotUnit.axisY.boundingRect.y2);
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.yScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
		};
		return animationInfo;
	}

	Chart.prototype.renderStackedColumn100 = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var offsetPositiveY = [];
		var offsetNegativeY = [];

		var i = 0, x, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number everytime it is accessed.

		//var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) &lt;&lt; 0;
		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : this.width * .15 &lt;&lt; 0;
		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

		if (!isFinite(xMinDiff)) {
			xMinDiff = Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum) * .3;
		}

		var barWidth = this.dataPointWidth ? this.dataPointWidth : (((plotArea.width / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / plotUnit.plotType.plotUnits.length * .9) &lt;&lt; 0;

		if (this.dataPointMaxWidth &amp;&amp; minBarWidth &gt; maxBarWidth)
			minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

		if (!this.dataPointMaxWidth &amp;&amp; this.dataPointMinWidth &amp;&amp; maxBarWidth &lt; minBarWidth)
			maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

		if (barWidth &lt; minBarWidth)
			barWidth = minBarWidth;

		if (barWidth &gt; maxBarWidth)
			barWidth = maxBarWidth;

		ctx.save();
		if (isCanvasSupported)
			this._eventManager.ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    this._eventManager.ghostCtx.beginPath();
			this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			this._eventManager.ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;


			//dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);


			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				var bevelEnabled = (barWidth &gt; 5) &amp;&amp; dataSeries.bevelEnabled ? true : false;

				//ctx.strokeStyle = &quot;#4572A7 &quot;;

				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;


					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (typeof (dataPoints[i].y) !== &quot;number&quot;)
						continue;

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;

					var yPercent;
					if (plotUnit.dataPointYSums[dataPointX] !== 0)
						yPercent = dataPoints[i].y / plotUnit.dataPointYSums[dataPointX] * 100;
					else
						yPercent = 0;

					//y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (yPercent - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (yPercent - plotUnit.axisY.conversionParameters.minimum));

					var x1 = x - (plotUnit.plotType.plotUnits.length * barWidth / 2) + (plotUnit.index * barWidth) &lt;&lt; 0;
					var x2 = x1 + barWidth &lt;&lt; 0;
					var y1;
					var y2;


					if (dataPoints[i].y &gt;= 0) {
						var offset = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : 0;

						y1 = y - offset;
						y2 = yZeroToPixel - offset;

						offsetPositiveY[dataPointX] = offset + (y2 - y1);

					} else {
						var offset = offsetNegativeY[dataPointX] ? offsetNegativeY[dataPointX] : 0;

						y2 = y + offset;
						y1 = yZeroToPixel + offset;

						offsetNegativeY[dataPointX] = offset + (y2 - y1);
					}


					color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
					drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled &amp;&amp; (dataPoints[i].y &gt;= 0), (dataPoints[i].y &lt; 0) &amp;&amp; bevelEnabled, false, false, dataSeries.fillOpacity);

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
					};
					color = intToHexColorString(id);

					if (isCanvasSupported)
						drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);


					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;stackedColumn100&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x, y: dataPoints[i].y &gt;= 0 ? y1 : y2
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							bounds: {
								x1: x1, y1: Math.min(y1, y2), x2: x2, y2: Math.max(y1, y2)
							},
							color: color
						});

					}
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationBase = Math.min(yZeroToPixel, plotUnit.axisY.boundingRect.y2);
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.yScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
		};
		return animationInfo;
	}

	Chart.prototype.renderBar = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var i = 0, x, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number from dataTime everytime it is used.

		//In case of Bar Chart, yZeroToPixel is x co-ordinate!
		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min((this.height * .15), this.plotArea.height / plotUnit.plotType.totalDataSeries * .9) &lt;&lt; 0;
		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

		if (!isFinite(xMinDiff)) {
			xMinDiff = Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum) * .3;
		}

		var barWidth = this.dataPointWidth ? this.dataPointWidth : (((plotArea.height / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / plotUnit.plotType.totalDataSeries * .9) &lt;&lt; 0;

		if (this.dataPointMaxWidth &amp;&amp; minBarWidth &gt; maxBarWidth)
			minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

		if (!this.dataPointMaxWidth &amp;&amp; this.dataPointMinWidth &amp;&amp; maxBarWidth &lt; minBarWidth)
			maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

		if (barWidth &lt; minBarWidth)
			barWidth = minBarWidth;

		if (barWidth &gt; maxBarWidth)
			barWidth = maxBarWidth;

		ctx.save();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    this._eventManager.ghostCtx.beginPath();
			this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			this._eventManager.ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;


			//dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);


			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				var bevelEnabled = (barWidth &gt; 5) &amp;&amp; dataSeries.bevelEnabled ? true : false;

				ctx.strokeStyle = &quot;#4572A7 &quot;;

				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (typeof (dataPoints[i].y) !== &quot;number&quot;)
						continue;

					//x and y are pixel co-ordinates of point and should not be confused with X and Y values
					y = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					x = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;


					var y1 = (y - (plotUnit.plotType.totalDataSeries * barWidth / 2) + ((plotUnit.previousDataSeriesCount + j) * barWidth)) &lt;&lt; 0;
					var y2 = y1 + barWidth &lt;&lt; 0;
					var x1;
					var x2;

					if (dataPoints[i].y &gt;= 0) {
						x1 = yZeroToPixel;
						x2 = x;
					} else {
						x1 = x;
						x2 = yZeroToPixel;
					}

					//drawRect(ctx, x1, y1, plotArea.x2, y2, &quot;#EEEEEE&quot;, 0, null, false, false, false, false);
					//drawRect(ctx, x1, y1, plotArea.x2, y2, &quot;#BDCED3&quot;, 0, null, false, false, false, false);

					color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
					//color = &quot;#1B4962&quot;;
					drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled, false, false, false, dataSeries.fillOpacity);


					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
					};
					color = intToHexColorString(id);

					if (isCanvasSupported)
						drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter)
						this._indexLabels.push({
							chartType: &quot;bar&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: dataPoints[i].y &gt;= 0 ? x2 : x1, y: y1 + (y2 - y1) / 2
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							bounds: {
								x1: Math.min(x1, x2), y1: y1, x2: Math.max(x1, x2), y2: y2
							},
							color: color
						});
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationBase = Math.max(yZeroToPixel, plotUnit.axisX.boundingRect.x2);
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
		};
		return animationInfo;
	}

	Chart.prototype.renderStackedBar = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var offsetPositiveY = [];
		var offsetNegativeY = [];

		var i = 0, x, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number everytime it is accessed.

		//var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) &lt;&lt; 0;
		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : this.height * .15 &lt;&lt; 0;
		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

		if (!isFinite(xMinDiff)) {
			xMinDiff = Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum) * .3;
		}

		var barWidth = this.dataPointWidth ? this.dataPointWidth : (((plotArea.height / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / plotUnit.plotType.plotUnits.length * .9) &lt;&lt; 0;

		if (this.dataPointMaxWidth &amp;&amp; minBarWidth &gt; maxBarWidth)
			minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

		if (!this.dataPointMaxWidth &amp;&amp; this.dataPointMinWidth &amp;&amp; maxBarWidth &lt; minBarWidth)
			maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

		if (barWidth &lt; minBarWidth)
			barWidth = minBarWidth;

		if (barWidth &gt; maxBarWidth)
			barWidth = maxBarWidth;

		ctx.save();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    this._eventManager.ghostCtx.beginPath();
			this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			this._eventManager.ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;

			//dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);

			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				var bevelEnabled = (barWidth &gt; 5) &amp;&amp; dataSeries.bevelEnabled ? true : false;

				ctx.strokeStyle = &quot;#4572A7 &quot;;

				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;


					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (typeof (dataPoints[i].y) !== &quot;number&quot;)
						continue;

					y = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					//x = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
					x = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum));

					//var x1 = x - (plotUnit.plotType.plotUnits.length * barWidth / 2) + (plotUnit.index * barWidth) &lt;&lt; 0;

					var y1 = y - (plotUnit.plotType.plotUnits.length * barWidth / 2) + (plotUnit.index * barWidth) &lt;&lt; 0;
					var y2 = y1 + barWidth &lt;&lt; 0;
					var x1;
					var x2;

					if (dataPoints[i].y &gt;= 0) {
						var offset = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : 0;

						x1 = yZeroToPixel + offset;
						x2 = x + offset;

						offsetPositiveY[dataPointX] = offset + (x2 - x1);

					} else {
						var offset = offsetNegativeY[dataPointX] ? offsetNegativeY[dataPointX] : 0;

						x1 = x - offset;
						x2 = yZeroToPixel - offset;

						offsetNegativeY[dataPointX] = offset + (x2 - x1);
					}


					color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
					drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled, false, false, false, dataSeries.fillOpacity);

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
					};
					color = intToHexColorString(id);

					if (isCanvasSupported)
						drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter)
						this._indexLabels.push({
							chartType: &quot;stackedBar&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: dataPoints[i].y &gt;= 0 ? x2 : x1, y: y
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							bounds: {
								x1: Math.min(x1, x2), y1: y1, x2: Math.max(x1, x2), y2: y2
							},
							color: color
						});
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationBase = Math.max(yZeroToPixel, plotUnit.axisX.boundingRect.x2);
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
		};
		return animationInfo;
	}

	Chart.prototype.renderStackedBar100 = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var offsetPositiveY = [];
		var offsetNegativeY = [];

		var i = 0, x, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number everytime it is accessed.

		//var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) &lt;&lt; 0;
		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : this.height * .15 &lt;&lt; 0;
		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

		if (!isFinite(xMinDiff)) {
			xMinDiff = Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum) * .3;
		}

		var barWidth = this.dataPointWidth ? this.dataPointWidth : (((plotArea.height / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / plotUnit.plotType.plotUnits.length * .9) &lt;&lt; 0;

		if (this.dataPointMaxWidth &amp;&amp; minBarWidth &gt; maxBarWidth)
			minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

		if (!this.dataPointMaxWidth &amp;&amp; this.dataPointMinWidth &amp;&amp; maxBarWidth &lt; minBarWidth)
			maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

		if (barWidth &lt; minBarWidth)
			barWidth = minBarWidth;

		if (barWidth &gt; maxBarWidth)
			barWidth = maxBarWidth;

		ctx.save();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    this._eventManager.ghostCtx.beginPath();
			this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			this._eventManager.ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;

			//dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);

			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				var bevelEnabled = (barWidth &gt; 5) &amp;&amp; dataSeries.bevelEnabled ? true : false;

				ctx.strokeStyle = &quot;#4572A7 &quot;;

				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;


					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (typeof (dataPoints[i].y) !== &quot;number&quot;)
						continue;

					y = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;

					var yPercent;
					if (plotUnit.dataPointYSums[dataPointX] !== 0)
						yPercent = dataPoints[i].y / plotUnit.dataPointYSums[dataPointX] * 100;
					else
						yPercent = 0;

					//x = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (yPercent - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
					x = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (yPercent - plotUnit.axisY.conversionParameters.minimum));

					var y1 = y - (plotUnit.plotType.plotUnits.length * barWidth / 2) + (plotUnit.index * barWidth) &lt;&lt; 0;
					var y2 = y1 + barWidth &lt;&lt; 0;
					var x1;
					var x2;


					if (dataPoints[i].y &gt;= 0) {
						var offset = offsetPositiveY[dataPointX] ? offsetPositiveY[dataPointX] : 0;

						x1 = yZeroToPixel + offset;
						x2 = x + offset;

						offsetPositiveY[dataPointX] = offset + (x2 - x1);

					} else {
						var offset = offsetNegativeY[dataPointX] ? offsetNegativeY[dataPointX] : 0;

						x1 = x - offset;
						x2 = yZeroToPixel - offset;

						offsetNegativeY[dataPointX] = offset + (x2 - x1);
					}


					color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
					drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled, false, false, false, dataSeries.fillOpacity);

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
					};
					color = intToHexColorString(id);

					if (isCanvasSupported)
						drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter)
						this._indexLabels.push({
							chartType: &quot;stackedBar100&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: dataPoints[i].y &gt;= 0 ? x2 : x1, y: y
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							bounds: {
								x1: Math.min(x1, x2), y1: y1, x2: Math.max(x1, x2), y2: y2
							},
							color: color
						});
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationBase = Math.max(yZeroToPixel, plotUnit.axisX.boundingRect.x2);
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xScaleAnimation, easingFunction: AnimationHelper.easing.easeOutQuart, animationBase: animationBase
		};
		return animationInfo;
	}

	Chart.prototype.renderArea = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var ghostCtx = this._eventManager.ghostCtx;

		var axisXProps = plotUnit.axisX.lineCoordinates;
		var axisYProps = plotUnit.axisY.lineCoordinates;
		var markers = [];

		var plotArea = this.plotArea;
		ctx.save();

		if (isCanvasSupported)
			ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
			ghostCtx.beginPath();
			ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];

			var dataPoints = dataSeries.dataPoints;

			var seriesId = dataSeries.id;
			this._eventManager.objectMap[seriesId] = {
				objectType: &quot;dataSeries&quot;, dataSeriesIndex: dataSeriesIndex
			};

			var hexColor = intToHexColorString(seriesId);
			ghostCtx.fillStyle = hexColor;
			//ghostCtx.lineWidth = dataSeries.lineThickness;
			//ghostCtx.lineWidth = 20;

			markers = [];

			var isFirstDataPointInPlotArea = true;
			var i = 0, x, y;
			var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number back and forth.

			var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
			var baseY;

			var startPoint = null;

			if (dataPoints.length &gt; 0) {
				//ctx.strokeStyle = &quot;#4572A7 &quot;;                
				var color = dataSeries._colorSet[i % dataSeries._colorSet.length];
				var lineColor = dataSeries._options.lineColor || color;
				var currentStrokeStyle = lineColor;
				//ctx.strokeStyle = &quot;red&quot;;
				ctx.fillStyle = color;
				ctx.strokeStyle = lineColor;
				ctx.lineWidth = dataSeries.lineThickness;
				var currentLineDashType = &quot;solid&quot;;

				if (ctx.setLineDash) {
					var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
					currentLineDashType = dataSeries.lineDashType;
					var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
					ctx.setLineDash(lineDashType);
				}

				var prevDataNull = true;
				for (; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax &amp;&amp; !(dataSeries.connectNullData &amp;&amp; prevDataNull)) {
						continue;
					}

					if (typeof (dataPoints[i].y) !== &quot;number&quot;) {
						if (!(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea))
							closeArea();

						prevDataNull = true;
						continue;
					}

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					if (isFirstDataPointInPlotArea || prevDataNull) {

						if (!isFirstDataPointInPlotArea &amp;&amp; dataSeries.connectNullData) {
							//Applying nullLineDshType If lineDashType at dataPoints not mentoioned in prevuous dataPoints
							if (ctx.setLineDash &amp;&amp; (dataSeries._options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType &amp;&amp; dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
								ctx.stroke();
								currentLineDashType = dataSeries.nullDataLineDashType;
								ctx.setLineDash(nullDataLineDashType);
							}

							ctx.lineTo(x, y);
							if (isCanvasSupported)
								ghostCtx.lineTo(x, y);

						} else { //If connectNullData = false
							ctx.beginPath();
							ctx.moveTo(x, y);
							if (isCanvasSupported) {
								ghostCtx.beginPath();
								ghostCtx.moveTo(x, y);
							}
							startPoint = {
								x: x, y: y
							};
						}

						isFirstDataPointInPlotArea = false;
						prevDataNull = false;
					}
					else {

						ctx.lineTo(x, y);

						if (isCanvasSupported)
							ghostCtx.lineTo(x, y);

						if (i % 250 == 0) {
							closeArea();
						}
					}

					if (i &lt; dataPoints.length - 1 &amp;&amp; (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

						closeArea();
						//ctx.stroke();
						//ctx.beginPath();
						//ctx.moveTo(x, y);

						currentStrokeStyle = dataPoints[i].lineColor || lineColor;
						ctx.strokeStyle = currentStrokeStyle;
						if (ctx.setLineDash)
							if (dataPoints[i].lineDashType) {
								currentLineDashType = dataPoints[i].lineDashType;
								ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
							}
							else {
								currentLineDashType = dataSeries.lineDashType;
								ctx.setLineDash(lineDashType);
							}
					}

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
					};

					//Render Marker
					if (dataPoints[i].markerSize !== 0) {
						if (dataPoints[i].markerSize &gt; 0 || dataSeries.markerSize &gt; 0) {
							var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
							markers.push(markerProps);

							//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
							//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
							//}

							var markerColor = intToHexColorString(id);

							if (isCanvasSupported) {
								markers.push({
									x: x, y: y, ctx: ghostCtx,
									type: markerProps.type,
									size: markerProps.size,
									color: markerColor,
									borderColor: markerColor,
									borderThickness: markerProps.borderThickness
								});
							}
						}
					}

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;area&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x, y: y
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							color: color
						});

					}
				}

				closeArea();

				//startPoint = { x: x, y: y };
				RenderHelper.drawMarkers(markers);
			}
		}

		ctx.restore();
		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		function closeArea() {

			if (!startPoint)
				return;

			if (dataSeries.lineThickness &gt; 0)
				ctx.stroke();

			if (plotUnit.axisY.viewportMinimum &lt;= 0 &amp;&amp; plotUnit.axisY.viewportMaximum &gt;= 0) {
				baseY = yZeroToPixel;
			}
			else if (plotUnit.axisY.viewportMaximum &lt; 0)
				baseY = axisYProps.y1;
			else if (plotUnit.axisY.viewportMinimum &gt; 0)
				baseY = axisXProps.y2;

			ctx.lineTo(x, baseY);
			ctx.lineTo(startPoint.x, baseY);
			ctx.closePath();

			ctx.globalAlpha = dataSeries.fillOpacity;
			ctx.fill();
			ctx.globalAlpha = 1;

			if (isCanvasSupported) {
				ghostCtx.lineTo(x, baseY);
				ghostCtx.lineTo(startPoint.x, baseY);
				ghostCtx.closePath();
				ghostCtx.fill();
			}

			ctx.beginPath();
			ctx.moveTo(x, y);
			ghostCtx.beginPath();
			ghostCtx.moveTo(x, y);

			startPoint = {
				x: x, y: y
			};
		}

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
		};
		return animationInfo;
	}

	Chart.prototype.renderSplineArea = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var ghostCtx = this._eventManager.ghostCtx;

		var axisXProps = plotUnit.axisX.lineCoordinates;
		var axisYProps = plotUnit.axisY.lineCoordinates;
		var markers = [];

		var plotArea = this.plotArea;
		ctx.save();

		if (isCanvasSupported)
			ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
			ghostCtx.beginPath();
			ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];

			var dataPoints = dataSeries.dataPoints;

			var seriesId = dataSeries.id;
			this._eventManager.objectMap[seriesId] = {
				objectType: &quot;dataSeries&quot;, dataSeriesIndex: dataSeriesIndex
			};

			var hexColor = intToHexColorString(seriesId);
			ghostCtx.fillStyle = hexColor;
			//ghostCtx.lineWidth = dataSeries.lineThickness;
			//ghostCtx.lineWidth = 20;

			markers = [];

			var isFirstDataPointInPlotArea = true;
			var i = 0, x, y;
			var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number back and forth.

			var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
			var baseY;

			var startPoint = null;

			var pixels = [];

			if (dataPoints.length &gt; 0) {
				//ctx.strokeStyle = &quot;#4572A7 &quot;;                
				var color = dataSeries._colorSet[i % dataSeries._colorSet.length];
				var lineColor = dataSeries._options.lineColor || color;
				var currentStrokeStyle = lineColor;
				ctx.fillStyle = color;
				ctx.strokeStyle = lineColor;
				ctx.lineWidth = dataSeries.lineThickness;
				var currentLineDashType = &quot;solid&quot;;

				if (ctx.setLineDash) {
					var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
					currentLineDashType = dataSeries.lineDashType;
					var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
					ctx.setLineDash(lineDashType);
				}

				var prevDataNull = false;
				for (; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax &amp;&amp; !(dataSeries.connectNullData &amp;&amp; prevDataNull)) {
						continue;
					}

					if (typeof (dataPoints[i].y) !== &quot;number&quot;) {
						if (i &gt; 0 &amp;&amp; !prevDataNull) {
							if (dataSeries.connectNullData) {
								if (ctx.setLineDash &amp;&amp; pixels.length &gt; 0 &amp;&amp; (dataSeries._options.nullDataLineDashType || !dataPoints[i - 1].lineDashType)) {
									pixels[pixels.length - 1].newLineDashArray = nullDataLineDashType;
									currentLineDashType = dataSeries.nullDataLineDashType;
								}
							}
							else {
								renderBezierArea();
								pixels = [];
							}
						}

						prevDataNull = true;
						continue;
					}

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;


					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
					};

					pixels[pixels.length] = {
						x: x, y: y
					};

					if (i &lt; dataPoints.length - 1 &amp;&amp; (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

						currentStrokeStyle = dataPoints[i].lineColor || lineColor;
						pixels[pixels.length - 1].newStrokeStyle = currentStrokeStyle;
						if (ctx.setLineDash)
							if (dataPoints[i].lineDashType) {
								currentLineDashType = dataPoints[i].lineDashType;
								pixels[pixels.length - 1].newLineDashArray = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
							}
							else {
								currentLineDashType = dataSeries.lineDashType;
								pixels[pixels.length - 1].newLineDashArray = lineDashType;
							}
					}

					//Render Marker
					if (dataPoints[i].markerSize !== 0) {
						if (dataPoints[i].markerSize &gt; 0 || dataSeries.markerSize &gt; 0) {
							var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
							markers.push(markerProps);

							//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
							//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
							//}

							var markerColor = intToHexColorString(id);

							if (isCanvasSupported) {
								markers.push({
									x: x, y: y, ctx: ghostCtx,
									type: markerProps.type,
									size: markerProps.size,
									color: markerColor,
									borderColor: markerColor,
									borderThickness: markerProps.borderThickness
								});
							}
						}
					}


					//Render Index Labels
					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;splineArea&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x, y: y
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							color: color
						});

					}

					isFirstDataPointInPlotArea = false;
					prevDataNull = false;
				}

				renderBezierArea();

				RenderHelper.drawMarkers(markers);
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		function renderBezierArea() {
			var bp = getBezierPoints(pixels, 2);

			if (bp.length &gt; 0) {

				if (dataSeries.lineThickness &gt; 0) {
					ctx.beginPath();
					ctx.moveTo(bp[0].x, bp[0].y);
					if (bp[0].newStrokeStyle)
						ctx.strokeStyle = bp[0].newStrokeStyle;
					if (bp[0].newLineDashArray)
						ctx.setLineDash(bp[0].newLineDashArray);

					for (var i = 0; i &lt; bp.length - 3; i += 3) {

						ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

						if (isCanvasSupported)
							ghostCtx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

						if (bp[i + 3].newStrokeStyle || bp[i + 3].newLineDashArray) {
							ctx.stroke();
							ctx.beginPath();
							ctx.moveTo(bp[i + 3].x, bp[i + 3].y);
							if (bp[i + 3].newStrokeStyle)
								ctx.strokeStyle = bp[i + 3].newStrokeStyle;
							if (bp[i + 3].newLineDashArray)
								ctx.setLineDash(bp[i + 3].newLineDashArray);
						}

					}

					ctx.stroke();
				}

				ctx.beginPath();
				ctx.moveTo(bp[0].x, bp[0].y);
				if (isCanvasSupported) {
					ghostCtx.beginPath();
					ghostCtx.moveTo(bp[0].x, bp[0].y);
				}

				for (var i = 0; i &lt; bp.length - 3; i += 3) {

					ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

					if (isCanvasSupported)
						ghostCtx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

				}

				if (plotUnit.axisY.viewportMinimum &lt;= 0 &amp;&amp; plotUnit.axisY.viewportMaximum &gt;= 0) {
					baseY = yZeroToPixel;
				}
				else if (plotUnit.axisY.viewportMaximum &lt; 0)
					baseY = axisYProps.y1;
				else if (plotUnit.axisY.viewportMinimum &gt; 0)
					baseY = axisXProps.y2;

				startPoint = {
					x: bp[0].x, y: bp[0].y
				};

				ctx.lineTo(bp[bp.length - 1].x, baseY);
				ctx.lineTo(startPoint.x, baseY);
				ctx.closePath();

				ctx.globalAlpha = dataSeries.fillOpacity;
				ctx.fill();
				ctx.globalAlpha = 1;

				if (isCanvasSupported) {
					ghostCtx.lineTo(bp[bp.length - 1].x, baseY);
					ghostCtx.lineTo(startPoint.x, baseY);
					ghostCtx.closePath();
					ghostCtx.fill();
				}
			}
		}

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
		};
		return animationInfo;
	}

	Chart.prototype.renderStepArea = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var ghostCtx = this._eventManager.ghostCtx;

		var axisXProps = plotUnit.axisX.lineCoordinates;
		var axisYProps = plotUnit.axisY.lineCoordinates;
		var markers = [];

		var plotArea = this.plotArea;
		ctx.save();

		if (isCanvasSupported)
			ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
			ghostCtx.beginPath();
			ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];

			var dataPoints = dataSeries.dataPoints;

			var seriesId = dataSeries.id;
			this._eventManager.objectMap[seriesId] = {
				objectType: &quot;dataSeries&quot;, dataSeriesIndex: dataSeriesIndex
			};

			var hexColor = intToHexColorString(seriesId);
			ghostCtx.fillStyle = hexColor;
			//ghostCtx.lineWidth = dataSeries.lineThickness;
			//ghostCtx.lineWidth = 20;

			markers = [];

			var isFirstDataPointInPlotArea = true;
			var i = 0, x, y;
			var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number back and forth.

			var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
			var baseY;

			var startPoint = null;

			var prevDataNull = false;
			if (dataPoints.length &gt; 0) {
				//ctx.strokeStyle = &quot;#4572A7 &quot;;                
				var color = dataSeries._colorSet[i % dataSeries._colorSet.length];
				var lineColor = dataSeries._options.lineColor || color;
				var currentStrokeStyle = lineColor;
				//ctx.strokeStyle = &quot;red&quot;;
				ctx.fillStyle = color;
				ctx.strokeStyle = lineColor;
				ctx.lineWidth = dataSeries.lineThickness;
				var currentLineDashType = &quot;solid&quot;;

				if (ctx.setLineDash) {
					var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
					currentLineDashType = dataSeries.lineDashType;
					var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
					ctx.setLineDash(lineDashType);
				}

				for (; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax &amp;&amp; !(dataSeries.connectNullData &amp;&amp; prevDataNull)) {
						continue;
					}

					var prevY = y;

					if (typeof (dataPoints[i].y) !== &quot;number&quot;) {
						if (!(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea))
							closeArea();

						prevDataNull = true;
						continue;
					}

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;



					if (isFirstDataPointInPlotArea || prevDataNull) {
						if (!isFirstDataPointInPlotArea &amp;&amp; dataSeries.connectNullData) {
							//Applying nullLineDshType If lineDashType at dataPoints not mentoioned in prevuous dataPoints
							if (ctx.setLineDash &amp;&amp; (dataSeries._options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType &amp;&amp; dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
								ctx.stroke();
								currentLineDashType = dataSeries.nullDataLineDashType;
								ctx.setLineDash(nullDataLineDashType);
							}
							ctx.lineTo(x, prevY);
							ctx.lineTo(x, y);
							if (isCanvasSupported) {
								ghostCtx.lineTo(x, prevY);
								ghostCtx.lineTo(x, y);
							}

						} else { //If connectNullData = false
							ctx.beginPath();
							ctx.moveTo(x, y);
							if (isCanvasSupported) {
								ghostCtx.beginPath();
								ghostCtx.moveTo(x, y);
							}
							startPoint = {
								x: x, y: y
							};
						}

						isFirstDataPointInPlotArea = false;
						prevDataNull = false;
					}
					else {

						ctx.lineTo(x, prevY);
						if (isCanvasSupported)
							ghostCtx.lineTo(x, prevY);

						ctx.lineTo(x, y);

						if (isCanvasSupported)
							ghostCtx.lineTo(x, y);

						if (i % 250 == 0) {
							closeArea();
						}
					}

					if (i &lt; dataPoints.length - 1 &amp;&amp; (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

						closeArea();

						currentStrokeStyle = dataPoints[i].lineColor || lineColor;
						ctx.strokeStyle = currentStrokeStyle;
						if (ctx.setLineDash)
							if (dataPoints[i].lineDashType) {
								currentLineDashType = dataPoints[i].lineDashType;
								ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
							}
							else {
								currentLineDashType = dataSeries.lineDashType;
								ctx.setLineDash(lineDashType);
							}
					}

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
					};

					//Render Marker
					if (dataPoints[i].markerSize !== 0) {
						if (dataPoints[i].markerSize &gt; 0 || dataSeries.markerSize &gt; 0) {
							var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
							markers.push(markerProps);

							//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
							//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
							//}

							var markerColor = intToHexColorString(id);

							if (isCanvasSupported) {
								markers.push({
									x: x, y: y, ctx: ghostCtx,
									type: markerProps.type,
									size: markerProps.size,
									color: markerColor,
									borderColor: markerColor,
									borderThickness: markerProps.borderThickness
								});
							}
						}
					}

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;stepArea&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x, y: y
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							color: color
						});

					}
				}

				closeArea();

				RenderHelper.drawMarkers(markers);
			}
		}

		ctx.restore();
		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		function closeArea() {

			if (!startPoint)
				return;

			if (dataSeries.lineThickness &gt; 0)
				ctx.stroke();

			if (plotUnit.axisY.viewportMinimum &lt;= 0 &amp;&amp; plotUnit.axisY.viewportMaximum &gt;= 0) {
				baseY = yZeroToPixel;
			}
			else if (plotUnit.axisY.viewportMaximum &lt; 0)
				baseY = axisYProps.y1;
			else if (plotUnit.axisY.viewportMinimum &gt; 0)
				baseY = axisXProps.y2;

			ctx.lineTo(x, baseY);
			ctx.lineTo(startPoint.x, baseY);
			ctx.closePath();

			ctx.globalAlpha = dataSeries.fillOpacity;
			ctx.fill();
			ctx.globalAlpha = 1;

			if (isCanvasSupported) {
				ghostCtx.lineTo(x, baseY);
				ghostCtx.lineTo(startPoint.x, baseY);
				ghostCtx.closePath();
				ghostCtx.fill();
			}

			ctx.beginPath();
			ctx.moveTo(x, y);
			ghostCtx.beginPath();
			ghostCtx.moveTo(x, y);

			startPoint = {
				x: x, y: y
			};
		}

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
		};
		return animationInfo;
	}

	Chart.prototype.renderStackedArea = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;
		var markers = [];

		var plotArea = this.plotArea;

		var offsetY = [];
		var currentBaseValues = [];

		var allXValues = [];
		//var offsetNegativeY = [];

		var i = 0, x, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number everytime it is accessed.

		//var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) &lt;&lt; 0;
		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

		var ghostCtx = this._eventManager.ghostCtx;

		if (isCanvasSupported)
			ghostCtx.beginPath();

		ctx.save();

		if (isCanvasSupported)
			ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
			ghostCtx.beginPath();
			ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			ghostCtx.clip();
		}

		var xValuePresent = [];
		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];
			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var xValue;

			dataSeries.dataPointIndexes = [];

			for (i = 0; i &lt; dataPoints.length; i++) {
				xValue = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;
				dataSeries.dataPointIndexes[xValue] = i;

				if (!xValuePresent[xValue]) {
					allXValues.push(xValue);
					xValuePresent[xValue] = true;
				}
			}

			allXValues.sort(compareNumbers);
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;

			currentBaseValues = [];


			var seriesId = dataSeries.id;
			this._eventManager.objectMap[seriesId] = {
				objectType: &quot;dataSeries&quot;, dataSeriesIndex: dataSeriesIndex
			};
			var hexColor = intToHexColorString(seriesId);
			ghostCtx.fillStyle = hexColor;



			if (allXValues.length &gt; 0) {

				color = dataSeries._colorSet[0];
				//ctx.strokeStyle = &quot;red&quot;;
				var lineColor = dataSeries._options.lineColor || color;
				var currentStrokeStyle = lineColor;
				ctx.fillStyle = color;
				ctx.strokeStyle = lineColor;
				ctx.lineWidth = dataSeries.lineThickness;
				var currentLineDashType = &quot;solid&quot;;

				if (ctx.setLineDash) {
					var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
					currentLineDashType = dataSeries.lineDashType;
					var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
					ctx.setLineDash(lineDashType);
				}

				var prevDataNull = true;
				for (i = 0; i &lt; allXValues.length; i++) {

					dataPointX = allXValues[i];
					var dataPoint = null;

					if (dataSeries.dataPointIndexes[dataPointX] &gt;= 0)
						dataPoint = dataPoints[dataSeries.dataPointIndexes[dataPointX]];
					else
						dataPoint = {
							x: dataPointX, y: null
						};

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax &amp;&amp; !(dataSeries.connectNullData &amp;&amp; prevDataNull)) {
						continue;
					}

					if (typeof (dataPoint.y) !== &quot;number&quot;) {
						if (!(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea))
							closeArea();

						prevDataNull = true;
						continue;
					}

					var x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					//var y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoint.y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
					var y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoint.y - plotUnit.axisY.conversionParameters.minimum));

					var offset = offsetY[dataPointX] ? offsetY[dataPointX] : 0;

					y = y - offset;
					currentBaseValues.push({ x: x, y: yZeroToPixel - offset });
					offsetY[dataPointX] = yZeroToPixel - y;

					if (isFirstDataPointInPlotArea || prevDataNull) {

						if (!isFirstDataPointInPlotArea &amp;&amp; dataSeries.connectNullData) {
							//Applying nullLineDshType If lineDashType at dataPoints not mentoioned in prevuous dataPoints
							if (ctx.setLineDash &amp;&amp; (dataSeries._options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType &amp;&amp; dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
								ctx.stroke();
								currentLineDashType = dataSeries.nullDataLineDashType;
								ctx.setLineDash(nullDataLineDashType);
							}

							ctx.lineTo(x, y);
							if (isCanvasSupported)
								ghostCtx.lineTo(x, y);

						} else {
							ctx.beginPath();
							ctx.moveTo(x, y);

							if (isCanvasSupported) {
								ghostCtx.beginPath();
								ghostCtx.moveTo(x, y);
							}
						}
						//currentBaseValues.push({ x: x, y: yZeroToPixel - offset });
						isFirstDataPointInPlotArea = false;
						prevDataNull = false;
					}
					else {

						ctx.lineTo(x, y);

						if (isCanvasSupported)
							ghostCtx.lineTo(x, y);

						if (i % 250 == 0) {

							closeArea();
							ctx.moveTo(x, y);

							if (isCanvasSupported) {
								ghostCtx.moveTo(x, y);
							}

							currentBaseValues.push({ x: x, y: yZeroToPixel - offset });
						}

					}

					if (i &lt; dataPoints.length - 1 &amp;&amp; (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

						closeArea();
						//ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(x, y);
						currentBaseValues.push({ x: x, y: yZeroToPixel - offset });

						currentStrokeStyle = dataPoints[i].lineColor || lineColor;
						ctx.strokeStyle = currentStrokeStyle;
						if (ctx.setLineDash)
							if (dataPoints[i].lineDashType) {
								currentLineDashType = dataPoints[i].lineDashType;
								ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
							}
							else {
								currentLineDashType = dataSeries.lineDashType;
								ctx.setLineDash(lineDashType);
							}
					}

					if (dataSeries.dataPointIndexes[dataPointX] &gt;= 0) {
						var id = dataSeries.dataPointIds[dataSeries.dataPointIndexes[dataPointX]];
						this._eventManager.objectMap[id] = {
							id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: dataSeries.dataPointIndexes[dataPointX], x1: x, y1: y
						};
					}

					//Render Marker
					if (dataSeries.dataPointIndexes[dataPointX] &gt;= 0 &amp;&amp; dataPoint.markerSize !== 0) {
						if (dataPoint.markerSize &gt; 0 || dataSeries.markerSize &gt; 0) {

							var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
							markers.push(markerProps);

							//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
							//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
							//}

							markerColor = intToHexColorString(id);

							if (isCanvasSupported) {
								markers.push({
									x: x, y: y, ctx: ghostCtx,
									type: markerProps.type,
									size: markerProps.size,
									color: markerColor,
									borderColor: markerColor,
									borderThickness: markerProps.borderThickness
								});
							}
						}
					}

					if (dataPoint.indexLabel || dataSeries.indexLabel || dataPoint.indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;stackedArea&quot;,
							dataPoint: dataPoint,
							dataSeries: dataSeries,
							point: {
								x: x, y: y
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							color: color
						});

					}
				}

				closeArea();
				ctx.moveTo(x, y);

				if (isCanvasSupported) {
					ghostCtx.moveTo(x, y);
				}
			}

			delete (dataSeries.dataPointIndexes);
		}

		RenderHelper.drawMarkers(markers);


		ctx.restore();

		if (isCanvasSupported)
			ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
		};
		return animationInfo;

		function closeArea() {

			if (currentBaseValues.length &lt; 1)
				return;

			if (dataSeries.lineThickness &gt; 0)
				ctx.stroke();

			while (currentBaseValues.length &gt; 0) {
				var point = currentBaseValues.pop();
				ctx.lineTo(point.x, point.y);

				if (isCanvasSupported)
					ghostCtx.lineTo(point.x, point.y);

			}

			ctx.closePath();

			ctx.globalAlpha = dataSeries.fillOpacity;
			ctx.fill();
			ctx.globalAlpha = 1;

			ctx.beginPath();

			if (isCanvasSupported) {
				ghostCtx.closePath();
				ghostCtx.fill();

				ghostCtx.beginPath();
			}
			currentBaseValues = [];
		}
	}

	Chart.prototype.renderStackedArea100 = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;
		var markers = [];

		var offsetY = [];
		var currentBaseValues = [];
		var allXValues = [];
		//var offsetNegativeY = [];

		var i = 0, x, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number everytime it is accessed.


		//var yZeroToPixel = (axisYProps.y2 - axisYProps.height / rangeY * Math.abs(0 - plotUnit.axisY.viewportMinimum) + .5) &lt;&lt; 0;
		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.width * .15 &lt;&lt; 0;
		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;
		var barWidth = (((plotArea.width / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) * .9) &lt;&lt; 0;

		var ghostCtx = this._eventManager.ghostCtx;

		ctx.save();

		if (isCanvasSupported)
			ghostCtx.save();


		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
			ghostCtx.beginPath();
			ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			ghostCtx.clip();
		}

		var xValuePresent = [];
		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];
			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var xValue;

			dataSeries.dataPointIndexes = [];

			for (i = 0; i &lt; dataPoints.length; i++) {
				xValue = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;
				dataSeries.dataPointIndexes[xValue] = i;

				if (!xValuePresent[xValue]) {
					allXValues.push(xValue);
					xValuePresent[xValue] = true;
				}
			}

			allXValues.sort(compareNumbers);
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;


			var seriesId = dataSeries.id;
			this._eventManager.objectMap[seriesId] = {
				objectType: &quot;dataSeries&quot;, dataSeriesIndex: dataSeriesIndex
			};
			var hexColor = intToHexColorString(seriesId);
			ghostCtx.fillStyle = hexColor;

			if (dataPoints.length == 1)
				barWidth = maxBarWidth;

			if (barWidth &lt; 1)
				barWidth = 1;
			else if (barWidth &gt; maxBarWidth)
				barWidth = maxBarWidth;

			currentBaseValues = [];

			if (allXValues.length &gt; 0) {

				color = dataSeries._colorSet[i % dataSeries._colorSet.length];
				//ctx.strokeStyle = &quot;red&quot;;
				var lineColor = dataSeries._options.lineColor || color;
				var currentStrokeStyle = lineColor;
				ctx.fillStyle = color;
				ctx.strokeStyle = lineColor;
				ctx.lineWidth = dataSeries.lineThickness;
				var currentLineDashType = &quot;solid&quot;;

				if (ctx.setLineDash) {
					var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
					currentLineDashType = dataSeries.lineDashType;
					var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
					ctx.setLineDash(lineDashType);
				}

				var bevelEnabled = (barWidth &gt; 5) ? false : false;

				//ctx.strokeStyle = &quot;#4572A7 &quot;;
				var prevDataNull = true;
				for (i = 0; i &lt; allXValues.length; i++) {

					dataPointX = allXValues[i];
					var dataPoint = null;

					if (dataSeries.dataPointIndexes[dataPointX] &gt;= 0)
						dataPoint = dataPoints[dataSeries.dataPointIndexes[dataPointX]];
					else
						dataPoint = {
							x: dataPointX, y: null
						};

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax &amp;&amp; !(dataSeries.connectNullData &amp;&amp; prevDataNull)) {
						continue;
					}

					if (typeof (dataPoint.y) !== &quot;number&quot;) {
						if (!(dataSeries.connectNullData || prevDataNull || isFirstDataPointInPlotArea))
							closeArea();

						prevDataNull = true;
						continue;
					}

					var yPercent;
					if (plotUnit.dataPointYSums[dataPointX] !== 0)
						yPercent = dataPoint.y / plotUnit.dataPointYSums[dataPointX] * 100;
					else
						yPercent = 0;

					var x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					var y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (yPercent - plotUnit.axisY.conversionParameters.minimum));

					var offset = offsetY[dataPointX] ? offsetY[dataPointX] : 0;

					y = y - offset;
					currentBaseValues.push({ x: x, y: yZeroToPixel - offset });
					offsetY[dataPointX] = yZeroToPixel - y;

					if (isFirstDataPointInPlotArea || prevDataNull) {

						if (!isFirstDataPointInPlotArea &amp;&amp; dataSeries.connectNullData) {
							//Applying nullLineDshType If lineDashType at dataPoints not mentoioned in prevuous dataPoints
							if (ctx.setLineDash &amp;&amp; (dataSeries._options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType &amp;&amp; dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
								ctx.stroke();
								currentLineDashType = dataSeries.nullDataLineDashType;
								ctx.setLineDash(nullDataLineDashType);
							}

							ctx.lineTo(x, y);
							if (isCanvasSupported)
								ghostCtx.lineTo(x, y);

						} else {
							ctx.beginPath();
							ctx.moveTo(x, y);

							if (isCanvasSupported) {
								ghostCtx.beginPath();
								ghostCtx.moveTo(x, y);
							}
						}
						isFirstDataPointInPlotArea = false;
						prevDataNull = false;
					}
					else {

						ctx.lineTo(x, y);

						if (isCanvasSupported)
							ghostCtx.lineTo(x, y);

						if (i % 250 == 0) {

							closeArea();
							ctx.moveTo(x, y);

							if (isCanvasSupported) {
								ghostCtx.moveTo(x, y);
							}

							currentBaseValues.push({ x: x, y: yZeroToPixel - offset });
						}
					}

					if (i &lt; dataPoints.length - 1 &amp;&amp; (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

						closeArea();
						//ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(x, y);
						currentBaseValues.push({ x: x, y: yZeroToPixel - offset });

						currentStrokeStyle = dataPoints[i].lineColor || lineColor;
						ctx.strokeStyle = currentStrokeStyle;
						if (ctx.setLineDash)
							if (dataPoints[i].lineDashType) {
								currentLineDashType = dataPoints[i].lineDashType;
								ctx.setLineDash(getLineDashArray(currentLineDashType, dataSeries.lineThickness));
							}
							else {
								currentLineDashType = dataSeries.lineDashType;
								ctx.setLineDash(lineDashType);
							}
					}


					if (dataSeries.dataPointIndexes[dataPointX] &gt;= 0) {
						var id = dataSeries.dataPointIds[dataSeries.dataPointIndexes[dataPointX]];
						this._eventManager.objectMap[id] = {
							id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: dataSeries.dataPointIndexes[dataPointX], x1: x, y1: y
						};
					}

					//Render Marker
					if (dataSeries.dataPointIndexes[dataPointX] &gt;= 0 &amp;&amp; dataPoint.markerSize !== 0) {
						if (dataPoint.markerSize &gt; 0 || dataSeries.markerSize &gt; 0) {
							var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);
							markers.push(markerProps);

							//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
							//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
							//}

							markerColor = intToHexColorString(id);

							if (isCanvasSupported) {
								markers.push({
									x: x, y: y, ctx: ghostCtx,
									type: markerProps.type,
									size: markerProps.size,
									color: markerColor,
									borderColor: markerColor,
									borderThickness: markerProps.borderThickness
								});
							}
						}
					}

					if (dataPoint.indexLabel || dataSeries.indexLabel || dataPoint.indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;stackedArea100&quot;,
							dataPoint: dataPoint,
							dataSeries: dataSeries,
							point: {
								x: x, y: y
							},
							direction: dataPoints[i].y &gt;= 0 ? 1 : -1,
							color: color
						});

					}
				}

				closeArea();
				ctx.moveTo(x, y);
				if (isCanvasSupported) {
					ghostCtx.moveTo(x, y);
				}
			}

			delete (dataSeries.dataPointIndexes);
		}

		RenderHelper.drawMarkers(markers);

		ctx.restore();

		if (isCanvasSupported)
			ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
		};
		return animationInfo;

		function closeArea() {
			if (dataSeries.lineThickness &gt; 0)
				ctx.stroke();

			while (currentBaseValues.length &gt; 0) {
				var point = currentBaseValues.pop();
				ctx.lineTo(point.x, point.y);

				if (isCanvasSupported)
					ghostCtx.lineTo(point.x, point.y);
			}

			ctx.closePath();

			ctx.globalAlpha = dataSeries.fillOpacity;
			ctx.fill();
			ctx.globalAlpha = 1;

			ctx.beginPath();

			if (isCanvasSupported) {
				ghostCtx.closePath();
				ghostCtx.fill();
				ghostCtx.beginPath();
			}

			currentBaseValues = [];
		}
	}

	Chart.prototype.renderBubble = function (plotUnit) {

		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var i = 0, x, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number from dataTime everytime it is used.

		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.width * .15 &lt;&lt; 0;
		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;
		var barWidth = (((plotArea.width / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / totalDataSeries * .9) &lt;&lt; 0;


		ctx.save();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    this._eventManager.ghostCtx.beginPath();
			this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			this._eventManager.ghostCtx.clip();
		}

		var maxZ = -Infinity;
		var minZ = Infinity;

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];
			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var z = 0;

			for (var i = 0; i &lt; dataPoints.length; i++) {

				dataPointX = dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

				if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
					continue;
				}

				if (typeof (dataPoints[i].z) !== &quot;undefined&quot;) {

					z = dataPoints[i].z;

					if (z &gt; maxZ)
						maxZ = z;

					if (z &lt; minZ)
						minZ = z;
				}
			}
		}

		var minArea = Math.PI * 5 * 5;
		var maxArea = Math.max(Math.pow(Math.min(plotArea.height, plotArea.width) * .25 / 2, 2) * Math.PI, minArea);

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;

			if (dataPoints.length == 1)
				barWidth = maxBarWidth;

			if (barWidth &lt; 1)
				barWidth = 1;
			else if (barWidth &gt; maxBarWidth)
				barWidth = maxBarWidth;

			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);
				//var bevelEnabled = (barWidth &gt; 5) ? false : false;

				ctx.strokeStyle = &quot;#4572A7 &quot;;



				for (var i = 0; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (typeof (dataPoints[i].y) !== &quot;number&quot;)
						continue;

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					var z = dataPoints[i].z;

					var area = (maxZ === minZ) ? maxArea / 2 : minArea + (maxArea - minArea) / (maxZ - minZ) * (z - minZ);
					var radius = Math.max(Math.sqrt(area / Math.PI) &lt;&lt; 0, 1);

					var markerSize = radius * 2;
					var markerProps = dataSeries.getMarkerProperties(i, ctx);
					markerProps.size = markerSize;


					ctx.globalAlpha = dataSeries.fillOpacity;
					RenderHelper.drawMarker(x, y, ctx, markerProps.type, markerProps.size, markerProps.color, markerProps.borderColor, markerProps.borderThickness);
					ctx.globalAlpha = 1;

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y, size: markerSize
					};
					var markerColor = intToHexColorString(id);
					//RenderHelper.drawMarker(x, y, this._eventManager.ghostCtx, markerType, markerSize, markerColor, markerColor, dataSeries.markerBorderThickness);
					if (isCanvasSupported)
						RenderHelper.drawMarker(x, y, this._eventManager.ghostCtx, markerProps.type, markerProps.size, markerColor, markerColor, markerProps.borderThickness);


					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;bubble&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x, y: y
							},
							direction: 1,
							bounds: {
								x1: x - markerProps.size / 2, y1: y - markerProps.size / 2, x2: x + markerProps.size / 2, y2: y + markerProps.size / 2
							},
							color: color
						});
					}
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0
		};
		return animationInfo;
	}

	Chart.prototype.renderScatter = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var i = 0, x, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number from dataTime everytime it is used.

		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.width * .15 &lt;&lt; 0;
		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;
		var barWidth = (((plotArea.width / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / totalDataSeries * .9) &lt;&lt; 0;


		ctx.save();
		if (isCanvasSupported)
			this._eventManager.ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    this._eventManager.ghostCtx.beginPath();
			this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			this._eventManager.ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;

			if (dataPoints.length == 1)
				barWidth = maxBarWidth;

			if (barWidth &lt; 1)
				barWidth = 1;
			else if (barWidth &gt; maxBarWidth)
				barWidth = maxBarWidth;

			if (dataPoints.length &gt; 0) {
				//var bevelEnabled = (barWidth &gt; 5) ? false : false;

				ctx.strokeStyle = &quot;#4572A7 &quot;;

				var maxArea = Math.pow(Math.min(plotArea.height, plotArea.width) * .3 / 2, 2) * Math.PI;

				var prevDataPointX = 0;
				var prevDataPointY = 0;

				for (var i = 0; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (typeof (dataPoints[i].y) !== &quot;number&quot;)
						continue;

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);

					ctx.globalAlpha = dataSeries.fillOpacity;
					RenderHelper.drawMarker(markerProps.x, markerProps.y, markerProps.ctx, markerProps.type, markerProps.size, markerProps.color, markerProps.borderColor, markerProps.borderThickness);
					ctx.globalAlpha = 1;


					//if (Math.abs(prevDataPointX - x) &lt; markerProps.size / 2 &amp;&amp; Math.abs(prevDataPointY - y) &lt; markerProps.size / 2) {
					//    continue;
					//}

					//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
					//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
					//}

					if ((Math.sqrt((prevDataPointX - x) * (prevDataPointX - x) + (prevDataPointY - y) * (prevDataPointY - y)) &lt; Math.min(markerProps.size, 5))
						&amp;&amp; dataPoints.length &gt; (Math.min(this.plotArea.width, this.plotArea.height))) {
						continue;
					}

					//Render ID on Ghost Canvas - for event handling
					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y
					};
					var markerColor = intToHexColorString(id);

					if (isCanvasSupported) {
						RenderHelper.drawMarker(
								markerProps.x, markerProps.y, this._eventManager.ghostCtx,
								markerProps.type,
								markerProps.size,
								markerColor,
								markerColor,
								markerProps.borderThickness
							);
					}
					//markers.push();

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;scatter&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x, y: y
							},
							direction: 1,
							bounds: {
								x1: x - markerProps.size / 2, y1: y - markerProps.size / 2, x2: x + markerProps.size / 2, y2: y + markerProps.size / 2
							},
							color: color
						});
					}

					prevDataPointX = x;
					prevDataPointY = y;
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0
		};
		return animationInfo;
	}

	Chart.prototype.renderCandlestick = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var ghostCtx = this._eventManager.ghostCtx;

		var totalDataSeries = plotUnit.dataSeriesIndexes.length;
		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var i = 0, x, y1, y2, y3, y4;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number from dataTime everytime it is used.

		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : (this.width * .015);

		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

		if (!isFinite(xMinDiff)) {
			xMinDiff = Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum) * .3;
		}

		var barWidth = this.dataPointWidth ? this.dataPointWidth : (((plotArea.width / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) * .7) &lt;&lt; 0;

		if (this.dataPointMaxWidth &amp;&amp; minBarWidth &gt; maxBarWidth)
			minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

		if (!this.dataPointMaxWidth &amp;&amp; this.dataPointMinWidth &amp;&amp; maxBarWidth &lt; minBarWidth)
			maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

		if (barWidth &lt; minBarWidth)
			barWidth = minBarWidth;

		if (barWidth &gt; maxBarWidth)
			barWidth = maxBarWidth;

		ctx.save();
		if (isCanvasSupported)
			ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    ghostCtx.beginPath();
			ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			ghostCtx.clip();
		}
		//ctx.beginPath();

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;


			// Reducing pixelPerUnit by 1 just to overcome any problems due to rounding off of pixels.
			//dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);

			//var offsetX = barWidth * plotUnit.index &lt;&lt; 0;


			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				var bevelEnabled = (barWidth &gt; 5) &amp;&amp; dataSeries.bevelEnabled ? true : false;

				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (dataPoints[i].y === null || !dataPoints[i].y.length
						|| typeof (dataPoints[i].y[0]) !== &quot;number&quot; || typeof (dataPoints[i].y[1]) !== &quot;number&quot;
						|| typeof (dataPoints[i].y[2]) !== &quot;number&quot; || typeof (dataPoints[i].y[3]) !== &quot;number&quot;)
						continue;

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y1 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[0] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y2 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[1] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					y3 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[2] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y4 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[3] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					var x1 = (x - barWidth / 2) &lt;&lt; 0;
					var x2 = (x1 + barWidth) &lt;&lt; 0;


					color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[0];


					//var borderThickness = Math.max(2, ((barWidth * .1) / 2 &lt;&lt; 0) * 2); // Set only even numbers for border
					var borderThickness = Math.round(Math.max(1, (barWidth * .15)));
					//borderThickness = (borderThickness / 2 &lt;&lt; 0) * 2;
					//borderThickness = 2;
					var offset = borderThickness % 2 === 0 ? 0 : .5;


					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2,
						x3: x, y3: y3, x4: x, y4: y4, borderThickness: borderThickness, color: color
					};

					ctx.strokeStyle = color;
					ctx.beginPath();
					ctx.lineWidth = borderThickness;
					ghostCtx.lineWidth = Math.max(borderThickness, 4);

					if (dataSeries.type === &quot;candlestick&quot;) {

						ctx.moveTo(x - offset, y2);
						ctx.lineTo(x - offset, Math.min(y1, y4));
						ctx.stroke();
						ctx.moveTo(x - offset, Math.max(y1, y4));
						ctx.lineTo(x - offset, y3);
						ctx.stroke();

						drawRect(ctx, x1, Math.min(y1, y4), x2, Math.max(y1, y4), dataPoints[i].y[0] &lt;= dataPoints[i].y[3] ? dataSeries.risingColor : color, borderThickness, color, bevelEnabled, bevelEnabled, false, false, dataSeries.fillOpacity);


						if (isCanvasSupported) {
							color = intToHexColorString(id);
							ghostCtx.strokeStyle = color;

							ghostCtx.moveTo(x - offset, y2);
							ghostCtx.lineTo(x - offset, Math.min(y1, y4));
							ghostCtx.stroke();
							ghostCtx.moveTo(x - offset, Math.max(y1, y4));
							ghostCtx.lineTo(x - offset, y3);
							ghostCtx.stroke();
							drawRect(ghostCtx, x1, Math.min(y1, y4), x2, Math.max(y1, y4), color, 0, null, false, false, false, false);
						}
					}
					else if (dataSeries.type === &quot;ohlc&quot;) {

						ctx.moveTo(x - offset, y2);
						ctx.lineTo(x - offset, y3);
						ctx.stroke();

						ctx.beginPath();
						ctx.moveTo(x, y1);
						ctx.lineTo(x1, y1);
						ctx.stroke();

						ctx.beginPath();
						ctx.moveTo(x, y4);
						ctx.lineTo(x2, y4);
						ctx.stroke();

						if (isCanvasSupported) {

							color = intToHexColorString(id);
							ghostCtx.strokeStyle = color;

							ghostCtx.moveTo(x - offset, y2);
							ghostCtx.lineTo(x - offset, y3);
							ghostCtx.stroke();

							ghostCtx.beginPath();
							ghostCtx.moveTo(x, y1);
							ghostCtx.lineTo(x1, y1);
							ghostCtx.stroke();

							ghostCtx.beginPath();
							ghostCtx.moveTo(x, y4);
							ghostCtx.lineTo(x2, y4);
							ghostCtx.stroke();
						}
					}

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: dataSeries.type,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							point: {
								x: x1 + (x2 - x1) / 2, y: y2
							},
							direction: 1,
							bounds: {
								x1: x1, y1: Math.min(y2, y3), x2: x2, y2: Math.max(y2, y3)
							},
							color: color
						});

					}
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0
		};
		return animationInfo;
	}

	Chart.prototype.renderRangeColumn = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var i = 0, x, y1, y2;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number from dataTime everytime it is used.

		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : (this.width * .03);
		//var maxBarWidth = (this.width * .015);
		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

		if (!isFinite(xMinDiff)) {
			xMinDiff = Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum) * .3;
		}

		//var barWidth = (((plotArea.width / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) * .9) &lt;&lt; 0;
		var barWidth = this.dataPointWidth ? this.dataPointWidth : (((plotArea.width / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / plotUnit.plotType.totalDataSeries * .9) &lt;&lt; 0;

		if (this.dataPointMaxWidth &amp;&amp; minBarWidth &gt; maxBarWidth)
			minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

		if (!this.dataPointMaxWidth &amp;&amp; this.dataPointMinWidth &amp;&amp; maxBarWidth &lt; minBarWidth)
			maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

		if (barWidth &lt; minBarWidth)
			barWidth = minBarWidth;

		if (barWidth &gt; maxBarWidth)
			barWidth = maxBarWidth;

		ctx.save();
		if (isCanvasSupported)
			this._eventManager.ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    this._eventManager.ghostCtx.beginPath();
			this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			this._eventManager.ghostCtx.clip();
		}
		//ctx.beginPath();

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;


			// Reducing pixelPerUnit by 1 just to overcome any problems due to rounding off of pixels.
			//dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);

			//var offsetX = barWidth * plotUnit.index &lt;&lt; 0;


			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				var bevelEnabled = (barWidth &gt; 5) &amp;&amp; dataSeries.bevelEnabled ? true : false;

				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (dataPoints[i].y === null || !dataPoints[i].y.length
						|| typeof (dataPoints[i].y[0]) !== &quot;number&quot; || typeof (dataPoints[i].y[1]) !== &quot;number&quot;)
						continue;

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y1 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[0] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y2 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[1] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					//var x1 = x - barWidth / 2 &lt;&lt; 0;
					var x1 = x - (plotUnit.plotType.totalDataSeries * barWidth / 2) + ((plotUnit.previousDataSeriesCount + j) * barWidth) &lt;&lt; 0;
					var x2 = x1 + barWidth &lt;&lt; 0;
					var y1;
					var y2;


					color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];

					if (y1 &gt; y2) {
						var temp = y1;
						y1 = y2;
						y2 = temp;
					}

					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
					};

					//var borderThickness = Math.max(1, (barWidth * .1 &lt;&lt; 0));
					var borderThickness = 0;

					drawRect(ctx, x1, y1, x2, y2, color, borderThickness, color, bevelEnabled, bevelEnabled, false, false, dataSeries.fillOpacity);
					color = intToHexColorString(id);

					if (isCanvasSupported)
						drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);


					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;rangeColumn&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							indexKeyword: 0,
							point: {
								x: x1 + (x2 - x1) / 2, y: dataPoints[i].y[1] &gt;= dataPoints[i].y[0] ? y2 : y1
							},
							direction: dataPoints[i].y[1] &gt;= dataPoints[i].y[0] ? -1 : 1,
							bounds: {
								x1: x1, y1: Math.min(y1, y2), x2: x2, y2: Math.max(y1, y2)
							},
							color: color
						});

						this._indexLabels.push({
							chartType: &quot;rangeColumn&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							indexKeyword: 1,
							point: {
								x: x1 + (x2 - x1) / 2, y: dataPoints[i].y[1] &gt;= dataPoints[i].y[0] ? y1 : y2
							},
							direction: dataPoints[i].y[1] &gt;= dataPoints[i].y[0] ? 1 : -1,
							bounds: {
								x1: x1, y1: Math.min(y1, y2), x2: x2, y2: Math.max(y1, y2)
							},
							color: color
						});

					}
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();


		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0
		};
		return animationInfo;
	}

	Chart.prototype.renderRangeBar = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var color = null;

		var plotArea = this.plotArea;

		var i = 0, x1, x2, y;
		var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number from dataTime everytime it is used.

		//In case of Bar Chart, yZeroToPixel is x co-ordinate!
		var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum)) &lt;&lt; 0;

		var minBarWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
		var maxBarWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min((this.height * .15), this.plotArea.height / plotUnit.plotType.totalDataSeries * .9) &lt;&lt; 0;
		var xMinDiff = plotUnit.axisX.dataInfo.minDiff;

		if (!isFinite(xMinDiff)) {
			xMinDiff = Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum) * .3;
		}

		//var barWidth = (((plotArea.height / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / totalDataSeries * .9) &lt;&lt; 0;

		var barWidth = this.dataPointWidth ? this.dataPointWidth : (((plotArea.height / Math.abs(plotUnit.axisX.viewportMaximum - plotUnit.axisX.viewportMinimum)) * Math.abs(xMinDiff)) / plotUnit.plotType.totalDataSeries * .9) &lt;&lt; 0;

		if (this.dataPointMaxWidth &amp;&amp; minBarWidth &gt; maxBarWidth)
			minBarWidth = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, maxBarWidth);

		if (!this.dataPointMaxWidth &amp;&amp; this.dataPointMinWidth &amp;&amp; maxBarWidth &lt; minBarWidth)
			maxBarWidth = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, minBarWidth);

		if (barWidth &lt; minBarWidth)
			barWidth = minBarWidth;

		if (barWidth &gt; maxBarWidth)
			barWidth = maxBarWidth;

		ctx.save();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
		    this._eventManager.ghostCtx.beginPath();
			this._eventManager.ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			this._eventManager.ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];
			var dataPoints = dataSeries.dataPoints;
			var isFirstDataPointInPlotArea = true;


			//dataSeries.maxWidthInX = barWidth / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);


			if (dataPoints.length &gt; 0) {
				//var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);

				var bevelEnabled = (barWidth &gt; 5) &amp;&amp; dataSeries.bevelEnabled ? true : false;

				ctx.strokeStyle = &quot;#4572A7 &quot;;

				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPoints[i].getTime ? dataPointX = dataPoints[i].x.getTime() : dataPointX = dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax) {
						continue;
					}

					if (dataPoints[i].y === null || !dataPoints[i].y.length
						|| typeof (dataPoints[i].y[0]) !== &quot;number&quot; || typeof (dataPoints[i].y[1]) !== &quot;number&quot;)
						continue;

					//x and y are pixel co-ordinates of point and should not be confused with X and Y values
					x1 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[0] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
					x2 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[1] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					y = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;


					var y1 = (y - (plotUnit.plotType.totalDataSeries * barWidth / 2) + ((plotUnit.previousDataSeriesCount + j) * barWidth)) &lt;&lt; 0;
					var y2 = y1 + barWidth &lt;&lt; 0;

					if (x1 &gt; x2) {
						var temp = x1;
						x1 = x2;
						x2 = temp;
					}

					//drawRect(ctx, x1, y1, plotArea.x2, y2, &quot;#EEEEEE&quot;, 0, null, false, false, false, false);
					//drawRect(ctx, x1, y1, plotArea.x2, y2, &quot;#BDCED3&quot;, 0, null, false, false, false, false);

					color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
					//color = &quot;#1B4962&quot;;
					drawRect(ctx, x1, y1, x2, y2, color, 0, null, bevelEnabled, false, false, false, dataSeries.fillOpacity);


					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x1, y1: y1, x2: x2, y2: y2
					};
					color = intToHexColorString(id);

					if (isCanvasSupported)
						drawRect(this._eventManager.ghostCtx, x1, y1, x2, y2, color, 0, null, false, false, false, false);


					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;rangeBar&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							indexKeyword: 0,
							point: {
								x: dataPoints[i].y[1] &gt;= dataPoints[i].y[0] ? x1 : x2, y: y1 + (y2 - y1) / 2
							},
							direction: dataPoints[i].y[1] &gt;= dataPoints[i].y[0] ? -1 : 1,
							bounds: {
								x1: Math.min(x1, x2), y1: y1, x2: Math.max(x1, x2), y2: y2
							},
							color: color
						});

						this._indexLabels.push({
							chartType: &quot;rangeBar&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							indexKeyword: 1,
							point: {
								x: dataPoints[i].y[1] &gt;= dataPoints[i].y[0] ? x2 : x1, y: y1 + (y2 - y1) / 2
							},
							direction: dataPoints[i].y[1] &gt;= dataPoints[i].y[0] ? 1 : -1,
							bounds: {
								x1: Math.min(x1, x2), y1: y1, x2: Math.max(x1, x2), y2: y2
							},
							color: color
						});
					}
				}
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.fadeInAnimation, easingFunction: AnimationHelper.easing.easeInQuad, animationBase: 0
		};
		return animationInfo;
	}

	Chart.prototype.renderRangeArea = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var ghostCtx = this._eventManager.ghostCtx;

		var axisXProps = plotUnit.axisX.lineCoordinates;
		var axisYProps = plotUnit.axisY.lineCoordinates;
		var markers = [];

		var plotArea = this.plotArea;
		ctx.save();

		if (isCanvasSupported)
			ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
			ghostCtx.beginPath();
			ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var closingPath = [];

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];

			var dataPoints = dataSeries.dataPoints;

			var seriesId = dataSeries.id;
			this._eventManager.objectMap[seriesId] = {
				objectType: &quot;dataSeries&quot;, dataSeriesIndex: dataSeriesIndex
			};

			var hexColor = intToHexColorString(seriesId);
			ghostCtx.fillStyle = hexColor;
			//ghostCtx.lineWidth = dataSeries.lineThickness;
			//ghostCtx.lineWidth = 20;

			markers = [];

			var isFirstDataPointInPlotArea = true;
			var i = 0, x, y1, y2;
			var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number back and forth.

			var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
			var baseY;

			var startPoint = null;

			if (dataPoints.length &gt; 0) {
				//ctx.strokeStyle = &quot;#4572A7 &quot;;                
				var color = dataSeries._colorSet[i % dataSeries._colorSet.length];
				//ctx.strokeStyle = &quot;red&quot;;
				var lineColor = dataSeries._options.lineColor || color;
				var currentStrokeStyle = lineColor;
				ctx.fillStyle = color;
				ctx.strokeStyle = lineColor;
				ctx.lineWidth = dataSeries.lineThickness;
				var currentLineDashType = &quot;solid&quot;;

				if (ctx.setLineDash) {
					var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
					currentLineDashType = dataSeries.lineDashType;
					var lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
					ctx.setLineDash(lineDashType);
				}

				var prevDataNull = true;
				for (; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax &amp;&amp; !(dataSeries.connectNullData &amp;&amp; prevDataNull)) {
						continue;
					}

					if (dataPoints[i].y === null || !dataPoints[i].y.length
						|| typeof (dataPoints[i].y[0]) !== &quot;number&quot; || typeof (dataPoints[i].y[1]) !== &quot;number&quot;) {

						if (!(prevDataNull || isFirstDataPointInPlotArea))
							closeArea();

						prevDataNull = true;
						continue;
					}

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;

					y1 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[0] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y2 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[1] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;

					if (isFirstDataPointInPlotArea || prevDataNull) {

						if (dataSeries.connectNullData &amp;&amp; !isFirstDataPointInPlotArea) {
							if (ctx.setLineDash &amp;&amp; (dataSeries._options.nullDataLineDashType || (currentLineDashType === dataSeries.lineDashType &amp;&amp; dataSeries.lineDashType !== dataSeries.nullDataLineDashType))) {
								closingPath[closingPath.length - 1].newLineDashArray = lineDashType;
								currentLineDashType = dataSeries.nullDataLineDashType;
								ctx.setLineDash(nullDataLineDashType);
							}

							ctx.lineTo(x, y1);
							if (isCanvasSupported)
								ghostCtx.lineTo(x, y1);
							closingPath.push({ x: x, y: y2 });

						} else {

							ctx.beginPath();
							ctx.moveTo(x, y1);
							startPoint = {
								x: x, y: y1
							};
							closingPath = [];
							closingPath.push({ x: x, y: y2 });

							if (isCanvasSupported) {
								ghostCtx.beginPath();
								ghostCtx.moveTo(x, y1);
							}
						}

						isFirstDataPointInPlotArea = false;
						prevDataNull = false;

					}
					else {

						ctx.lineTo(x, y1);
						closingPath.push({ x: x, y: y2 });

						if (isCanvasSupported)
							ghostCtx.lineTo(x, y1);

						if (i % 250 == 0) {
							closeArea();
						}
					}


					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y1, y2: y2
					};

					if (i &lt; dataPoints.length - 1) {

						if (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType)) { //Applieng new ctx on DataPoint

							closeArea();

							currentStrokeStyle = dataPoints[i].lineColor || lineColor;
							closingPath[closingPath.length - 1].newStrokeStyle = currentStrokeStyle;
							ctx.strokeStyle = currentStrokeStyle;

							if (ctx.setLineDash)
								if (dataPoints[i].lineDashType) {
									currentLineDashType = dataPoints[i].lineDashType;
									closingPath[closingPath.length - 1].newLineDashArray = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
									ctx.setLineDash(closingPath[closingPath.length - 1].newLineDashArray);
								}
								else {
									currentLineDashType = dataSeries.lineDashType;
									closingPath[closingPath.length - 1].newLineDashArray = lineDashType;
									ctx.setLineDash(lineDashType);
								}
						}
					}

					//Render Marker
					if (dataPoints[i].markerSize !== 0) {
						if (dataPoints[i].markerSize &gt; 0 || dataSeries.markerSize &gt; 0) {
							var markerProps = dataSeries.getMarkerProperties(i, x, y2, ctx);
							markers.push(markerProps);

							//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
							//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
							//}

							var markerColor = intToHexColorString(id);

							if (isCanvasSupported) {
								markers.push({
									x: x, y: y2, ctx: ghostCtx,
									type: markerProps.type,
									size: markerProps.size,
									color: markerColor,
									borderColor: markerColor,
									borderThickness: markerProps.borderThickness
								});
							}

							markerProps = dataSeries.getMarkerProperties(i, x, y1, ctx);
							markers.push(markerProps);



							var markerColor = intToHexColorString(id);

							if (isCanvasSupported) {
								markers.push({
									x: x, y: y1, ctx: ghostCtx,
									type: markerProps.type,
									size: markerProps.size,
									color: markerColor,
									borderColor: markerColor,
									borderThickness: markerProps.borderThickness
								});
							}
						}
					}

					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;rangeArea&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							indexKeyword: 0,
							point: {
								x: x, y: y1
							},
							direction: dataPoints[i].y[0] &lt;= dataPoints[i].y[1] ? -1 : 1,
							color: color
						});

						this._indexLabels.push({
							chartType: &quot;rangeArea&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							indexKeyword: 1,
							point: {
								x: x, y: y2
							},
							direction: dataPoints[i].y[0] &lt;= dataPoints[i].y[1] ? 1 : -1,
							color: color
						});

					}

					//alert(&quot;hi&quot;);
				}

				closeArea();

				//startPoint = { x: x, y: y };
				RenderHelper.drawMarkers(markers);
			}
		}

		ctx.restore();
		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		function closeArea() {

			if (!startPoint)
				return;

			var point = null;

			if (dataSeries.lineThickness &gt; 0)
				ctx.stroke();

			for (var i = closingPath.length - 1; i &gt;= 0; i--) {
				point = closingPath[i];
				ctx.lineTo(point.x, point.y);
				ghostCtx.lineTo(point.x, point.y);
			}



			ctx.closePath();
			//ctx.lineTo(startPoint.x, startPoint.y);

			ctx.globalAlpha = dataSeries.fillOpacity;
			ctx.fill();
			ctx.globalAlpha = 1;

			ghostCtx.fill();

			//if (isCanvasSupported) {
			//	ghostCtx.lineTo(x, baseY);
			//	ghostCtx.lineTo(startPoint.x, baseY);
			//	ghostCtx.closePath();
			//	ghostCtx.fill();
			//}

			if (dataSeries.lineThickness &gt; 0) {
				ctx.beginPath();
				ctx.moveTo(point.x, point.y);
				for (var i = 0; i &lt; closingPath.length; i++) {
					point = closingPath[i];
					ctx.lineTo(point.x, point.y);
				}

				ctx.stroke();
			}


			ctx.beginPath();
			ctx.moveTo(x, y1);
			ghostCtx.beginPath();
			ghostCtx.moveTo(x, y1);

			startPoint = {
				x: x, y: y1
			};
			closingPath = [];
			closingPath.push({ x: x, y: y2 });
		}

		//ctx.beginPath();
		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
		};
		return animationInfo;
	}


	Chart.prototype.renderRangeSplineArea = function (plotUnit) {
		var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var ghostCtx = this._eventManager.ghostCtx;

		var axisXProps = plotUnit.axisX.lineCoordinates;
		var axisYProps = plotUnit.axisY.lineCoordinates;
		var markers = [];

		var plotArea = this.plotArea;
		ctx.save();

		if (isCanvasSupported)
			ghostCtx.save();

		ctx.beginPath();
		ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
		ctx.clip();

		if (isCanvasSupported) {
			ghostCtx.beginPath();
			ghostCtx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			ghostCtx.clip();
		}

		for (var j = 0; j &lt; plotUnit.dataSeriesIndexes.length; j++) {

			var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];

			var dataSeries = this.data[dataSeriesIndex];

			var dataPoints = dataSeries.dataPoints;

			var seriesId = dataSeries.id;
			this._eventManager.objectMap[seriesId] = {
				objectType: &quot;dataSeries&quot;, dataSeriesIndex: dataSeriesIndex
			};

			var hexColor = intToHexColorString(seriesId);
			ghostCtx.fillStyle = hexColor;
			//ghostCtx.lineWidth = dataSeries.lineThickness;
			//ghostCtx.lineWidth = 20;

			markers = [];

			var isFirstDataPointInPlotArea = true;
			var i = 0, x, y1, y2;
			var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn&#x27;t get converted to number back and forth.

			var yZeroToPixel = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (0 - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
			var baseY;

			var startPoint = null;

			var pixelsY1 = [];
			var pixelsY2 = [];

			if (dataPoints.length &gt; 0) {
				//ctx.strokeStyle = &quot;#4572A7 &quot;;                
				var color = dataSeries._colorSet[i % dataSeries._colorSet.length];
				//ctx.strokeStyle = &quot;red&quot;;
				var lineColor = dataSeries._options.lineColor || color;
				var currentStrokeStyle = lineColor;
				ctx.fillStyle = color;
				//ctx.strokeStyle = lineColor;
				ctx.lineWidth = dataSeries.lineThickness;
				var currentLineDashType = &quot;solid&quot;;
				var lineDashType;

				if (ctx.setLineDash) {
					var nullDataLineDashType = getLineDashArray(dataSeries.nullDataLineDashType, dataSeries.lineThickness);
					currentLineDashType = dataSeries.lineDashType;
					lineDashType = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
					//ctx.setLineDash(lineDashType);
				}

				var prevDataNull = false;

				for (; i &lt; dataPoints.length; i++) {

					dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;

					if (dataPointX &lt; plotUnit.axisX.dataInfo.viewPortMin || dataPointX &gt; plotUnit.axisX.dataInfo.viewPortMax &amp;&amp; !(dataSeries.connectNullData &amp;&amp; prevDataNull)) {
						continue;
					}

					if (dataPoints[i].y === null || !dataPoints[i].y.length || typeof (dataPoints[i].y[0]) !== &quot;number&quot; || typeof (dataPoints[i].y[1]) !== &quot;number&quot;) {
						if (i &gt; 0 &amp;&amp; !prevDataNull) {
							if (dataSeries.connectNullData) {
								if (ctx.setLineDash &amp;&amp; pixelsY1.length &gt; 0 &amp;&amp; (dataSeries._options.nullDataLineDashType || !dataPoints[i - 1].lineDashType)) {
									pixelsY1[pixelsY1.length - 1].newLineDashArray = nullDataLineDashType;
									currentLineDashType = dataSeries.nullDataLineDashType;
								}
							}
							else {
								renderBezierArea(lineDashType, lineColor);
								pixelsY1 = [];
								pixelsY2 = [];
							}
						}
						prevDataNull = true;
						continue;
					}

					x = (plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y1 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[0] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;
					y2 = (plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y[1] - plotUnit.axisY.conversionParameters.minimum) + .5) &lt;&lt; 0;


					var id = dataSeries.dataPointIds[i];
					this._eventManager.objectMap[id] = {
						id: id, objectType: &quot;dataPoint&quot;, dataSeriesIndex: dataSeriesIndex, dataPointIndex: i, x1: x, y1: y1, y2: y2
					};

					pixelsY1[pixelsY1.length] = {
						x: x, y: y1
					};
					pixelsY2[pixelsY2.length] = {
						x: x, y: y2
					};

					if (i &lt; dataPoints.length - 1 &amp;&amp; (currentStrokeStyle !== (dataPoints[i].lineColor || lineColor) || currentLineDashType !== (dataPoints[i].lineDashType || dataSeries.lineDashType))) { //Applieng new ctx on DataPoint

						currentStrokeStyle = dataPoints[i].lineColor || lineColor;
						pixelsY1[pixelsY1.length - 1].newStrokeStyle = currentStrokeStyle;
						if (ctx.setLineDash)
							if (dataPoints[i].lineDashType) {
								currentLineDashType = dataPoints[i].lineDashType;
								pixelsY1[pixelsY1.length - 1].newLineDashArray = getLineDashArray(currentLineDashType, dataSeries.lineThickness);
							}
							else {
								currentLineDashType = dataSeries.lineDashType;
								pixelsY1[pixelsY1.length - 1].newLineDashArray = lineDashType;
							}
					}

					//Render Marker
					if (dataPoints[i].markerSize !== 0) {
						if (dataPoints[i].markerSize &gt; 0 || dataSeries.markerSize &gt; 0) {
							var markerProps = dataSeries.getMarkerProperties(i, x, y1, ctx);
							markers.push(markerProps);

							//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
							//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
							//}

							var markerColor = intToHexColorString(id);

							if (isCanvasSupported) {
								markers.push({
									x: x, y: y1, ctx: ghostCtx,
									type: markerProps.type,
									size: markerProps.size,
									color: markerColor,
									borderColor: markerColor,
									borderThickness: markerProps.borderThickness
								});
							}

							var markerProps = dataSeries.getMarkerProperties(i, x, y2, ctx);
							markers.push(markerProps);

							//if (!dataSeries.maxWidthInX || markerProps.size &gt; dataSeries.maxWidthInX) {
							//	dataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit &gt; 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);
							//}

							var markerColor = intToHexColorString(id);

							if (isCanvasSupported) {
								markers.push({
									x: x, y: y2, ctx: ghostCtx,
									type: markerProps.type,
									size: markerProps.size,
									color: markerColor,
									borderColor: markerColor,
									borderThickness: markerProps.borderThickness
								});
							}
						}
					}


					//Render Index Labels
					if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {

						this._indexLabels.push({
							chartType: &quot;splineArea&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							indexKeyword: 0,
							point: {
								x: x, y: y1
							},
							direction: dataPoints[i].y[0] &lt;= dataPoints[i].y[1] ? -1 : 1,
							color: color
						});

						this._indexLabels.push({
							chartType: &quot;splineArea&quot;,
							dataPoint: dataPoints[i],
							dataSeries: dataSeries,
							indexKeyword: 1,
							point: {
								x: x, y: y2
							},
							direction: dataPoints[i].y[0] &lt;= dataPoints[i].y[1] ? 1 : -1,
							color: color
						});

					}

					isFirstDataPointInPlotArea = false;
					prevDataNull = false;
				}

				renderBezierArea(lineDashType, lineColor);

				RenderHelper.drawMarkers(markers);
			}
		}

		ctx.restore();

		if (isCanvasSupported)
			this._eventManager.ghostCtx.restore();

		function renderBezierArea(lineDashType, lineColor) {

			var bp = getBezierPoints(pixelsY1, 2);

			if (bp.length &gt; 0) {

				if (dataSeries.lineThickness &gt; 0) {
					ctx.strokeStyle = lineColor;
					if (ctx.setLineDash)
						ctx.setLineDash(lineDashType);
					ctx.beginPath();
					ctx.moveTo(bp[0].x, bp[0].y);
					for (var i = 0; i &lt; bp.length - 3; i += 3) {

						if (bp[i].newStrokeStyle || bp[i].newLineDashArray) {
							ctx.stroke();
							ctx.beginPath();
							ctx.moveTo(bp[i].x, bp[i].y);
							if (bp[i].newStrokeStyle)
								ctx.strokeStyle = bp[i].newStrokeStyle;
							if (bp[i].newLineDashArray)
								ctx.setLineDash(bp[i].newLineDashArray);
						}

						ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

					}
					ctx.stroke();
				}

				ctx.beginPath();
				ctx.moveTo(bp[0].x, bp[0].y);

				if (isCanvasSupported) {
					ghostCtx.beginPath();
					ghostCtx.moveTo(bp[0].x, bp[0].y);
				}

				for (var i = 0; i &lt; bp.length - 3; i += 3) {

					ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

					if (isCanvasSupported)
						ghostCtx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);
				}




				bp = getBezierPoints(pixelsY2, 2);

				ctx.lineTo(pixelsY2[pixelsY2.length - 1].x, pixelsY2[pixelsY2.length - 1].y);

				for (var i = bp.length - 1; i &gt; 2; i -= 3) {

					ctx.bezierCurveTo(bp[i - 1].x, bp[i - 1].y, bp[i - 2].x, bp[i - 2].y, bp[i - 3].x, bp[i - 3].y);

					if (isCanvasSupported)
						ghostCtx.bezierCurveTo(bp[i - 1].x, bp[i - 1].y, bp[i - 2].x, bp[i - 2].y, bp[i - 3].x, bp[i - 3].y);
				}

				ctx.closePath();

				ctx.globalAlpha = dataSeries.fillOpacity;
				ctx.fill();
				if (isCanvasSupported) {
					ghostCtx.closePath();
					ghostCtx.fill();
				}

				ctx.globalAlpha = 1;


				if (dataSeries.lineThickness &gt; 0) {
					ctx.strokeStyle = lineColor;
					if (ctx.setLineDash)
						ctx.setLineDash(lineDashType);
					ctx.beginPath();
					ctx.moveTo(bp[0].x, bp[0].y);
					for (var i = 0, j = 0; i &lt; bp.length - 3; i += 3, j++) {

						if (pixelsY1[j].newStrokeStyle || pixelsY1[j].newLineDashArray) {
							ctx.stroke();
							ctx.beginPath();
							ctx.moveTo(bp[i].x, bp[i].y);
							if (pixelsY1[j].newStrokeStyle)
								ctx.strokeStyle = pixelsY1[j].newStrokeStyle;
							if (pixelsY1[j].newLineDashArray)
								ctx.setLineDash(pixelsY1[j].newLineDashArray);
						}

						ctx.bezierCurveTo(bp[i + 1].x, bp[i + 1].y, bp[i + 2].x, bp[i + 2].y, bp[i + 3].x, bp[i + 3].y);

					}
					ctx.stroke();
				}

				ctx.beginPath();



			}
		}

		//source and dest would be same when animation is not enabled
		var animationInfo = {
			source: ctx, dest: this.plotArea.ctx, animationCallback: AnimationHelper.xClipAnimation, easingFunction: AnimationHelper.easing.linear, animationBase: 0
		};
		return animationInfo;
	}
	//#region pieChart

	var drawSegment = function (ctx, center, radius, color, type, theta1, theta2, fillOpacity, percentInnerRadius) {
		if (radius &lt; 0)
			return;
		if (typeof (fillOpacity) === &quot;undefined&quot;)
			fillOpacity = 1;

		//IE8- FIX: In IE8- segment doesn&#x27;t get draw if theta2 is equal to theta1 + 2*PI.
		if (!isCanvasSupported) {
			var theta2Mod = Number((theta2 % (2 * Math.PI)).toFixed(8));
			var theta1Mod = Number((theta1 % (2 * Math.PI)).toFixed(8));
			if (theta1Mod === theta2Mod)
				theta2 -= .0001;
		}

		ctx.save();
		ctx.globalAlpha = fillOpacity;

		if (type === &quot;pie&quot;) {
			ctx.beginPath();
			ctx.moveTo(center.x, center.y);
			ctx.arc(center.x, center.y, radius, theta1, theta2, false);
			ctx.fillStyle = color;
			ctx.strokeStyle = &quot;white&quot;;
			ctx.lineWidth = 2;
			//    ctx.shadowOffsetX = 2;
			//    ctx.shadowOffsetY = 1;
			//     ctx.shadowBlur = 2;
			//    ctx.shadowColor = &#x27;#BFBFBF&#x27;;
			ctx.closePath();
			//ctx.stroke();
			ctx.fill();
		}
		else if (type === &quot;doughnut&quot;) {
			ctx.beginPath();
			ctx.arc(center.x, center.y, radius, theta1, theta2, false);
			if (percentInnerRadius &gt;= 0)
				ctx.arc(center.x, center.y, percentInnerRadius * radius, theta2, theta1, true);
			ctx.closePath();
			ctx.fillStyle = color;
			ctx.strokeStyle = &quot;white&quot;;
			ctx.lineWidth = 2;
			// shadow properties
			//     ctx.shadowOffsetX = 1;
			//    ctx.shadowOffsetY = 1;
			//     ctx.shadowBlur = 1;
			//    ctx.shadowColor = &#x27;#BFBFBF&#x27;;  //grey shadow
			//ctx.stroke();
			ctx.fill();
		}

		ctx.globalAlpha = 1;

		ctx.restore();
	};

	function convertPercentToValue(input, referenceValue) {
		//input can be a number or string
		if (input === null || typeof (input) === &quot;undefined&quot;)
			return referenceValue;

		var result = parseFloat(input.toString()) * (input.toString().indexOf(&quot;%&quot;) &gt;= 0 ? referenceValue / 100 : 1);

		// limit to plot area
		if (!isNaN(result) &amp;&amp; result &lt;= referenceValue &amp;&amp; result &gt;= 0)
			return result;

		return referenceValue;
	}

	Chart.prototype.renderPie = function (plotUnit) {

		var _this = this;
		var totalDataSeries = plotUnit.dataSeriesIndexes.length;

		if (totalDataSeries &lt;= 0)
			return;

		var dataSeriesIndex = plotUnit.dataSeriesIndexes[0];
		var dataSeries = this.data[dataSeriesIndex];
		var dataPoints = dataSeries.dataPoints;
		var indexLabelLineEdgeLength = 10;
		var explodeDuration = 500;

		var plotArea = this.plotArea;

		//var maxFrame = isCanvasSupported ? 300 : 4;
		//var totalRecursions = 0;
		var dataPointEOs = []; //dataPoint Extension Objects Behaves like a storage place for all additional data relating to dataPoints. Requred because actual dataPoints should not be modified.

		var minDistanceBetweenLabels = 2;
		var indexLabelRadius;
		var indexLabelRadiusToRadiusRatio = 1.3;
		var poleAnglularDistance = (20 / 180) * Math.PI; //Anglular Distance from 90 &amp; 270 to be considered pole
		var precision = 6;

		var center = {
			x: (plotArea.x2 + plotArea.x1) / 2, y: (plotArea.y2 + plotArea.y1) / 2
		};

		var sum = 0;
		var isIndexLabelPresent = false;
		for (var j = 0; j &lt; dataPoints.length; j++) {
			sum += Math.abs(dataPoints[j].y);

			if (!isIndexLabelPresent &amp;&amp; typeof (dataPoints[j].indexLabel) !== &quot;undefined&quot; &amp;&amp; dataPoints[j].indexLabel !== null &amp;&amp; dataPoints[j].indexLabel.toString().length &gt; 0)
				isIndexLabelPresent = true;

			if (!isIndexLabelPresent &amp;&amp; typeof (dataPoints[j].label) !== &quot;undefined&quot; &amp;&amp; dataPoints[j].label !== null &amp;&amp; dataPoints[j].label.toString().length &gt; 0)
				isIndexLabelPresent = true;
		}

		if (sum === 0)
			return;

		isIndexLabelPresent = isIndexLabelPresent || (typeof (dataSeries.indexLabel) !== &quot;undefined&quot; &amp;&amp; dataSeries.indexLabel !== null &amp;&amp; dataSeries.indexLabel.toString().length &gt; 0);

		var outerRadius = dataSeries.indexLabelPlacement !== &quot;inside&quot; &amp;&amp; isIndexLabelPresent ? (Math.min(plotArea.width, plotArea.height) * 0.75) / 2 : (Math.min(plotArea.width, plotArea.height) * .92) / 2;

		if (dataSeries.radius)
			outerRadius = convertPercentToValue(dataSeries.radius, outerRadius);


		var innerRadius = (typeof dataSeries.innerRadius !== &#x27;undefined&#x27; &amp;&amp; dataSeries.innerRadius !== null) ? convertPercentToValue(dataSeries.innerRadius, outerRadius) : 0.7 * outerRadius;

		var percentInnerRadius = Math.min(innerRadius / outerRadius, (outerRadius - 1) / outerRadius);

		function initLabels() {

			if (!dataSeries || !dataPoints)
				return;


			var noDPNearSouthPole = 0;
			var noDPNearNorthPole = 0;
			var firstDPCloseToSouth = 0;
			var firstDPCloseToNorth = 0;

			for (var j = 0; j &lt; dataPoints.length; j++) {

				var dataPoint = dataPoints[j];
				var id = dataSeries.dataPointIds[j];

				var dataPointEO = {
					id: id, objectType: &quot;dataPoint&quot;, dataPointIndex: j, dataSeriesIndex: 0
				};
				dataPointEOs.push(dataPointEO);

				var percentAndTotal = {
					percent: null, total: null
				};
				var formatterParameter = null;

				percentAndTotal = _this.getPercentAndTotal(dataSeries, dataPoint);

				if (dataSeries.indexLabelFormatter || dataPoint.indexLabelFormatter)
					formatterParameter = {
						chart: _this._options, dataSeries: dataSeries, dataPoint: dataPoint, total: percentAndTotal.total, percent: percentAndTotal.percent
					};

				var indexLabelText = dataPoint.indexLabelFormatter ? dataPoint.indexLabelFormatter(formatterParameter)
                    : dataPoint.indexLabel ? _this.replaceKeywordsWithValue(dataPoint.indexLabel, dataPoint, dataSeries, j)
                    : dataSeries.indexLabelFormatter ? dataSeries.indexLabelFormatter(formatterParameter)
                    : dataSeries.indexLabel ? _this.replaceKeywordsWithValue(dataSeries.indexLabel, dataPoint, dataSeries, j) : dataPoint.label ? dataPoint.label : &#x27;&#x27;;


				_this._eventManager.objectMap[id] = dataPointEO;

				//dataPointEO.indexLabelText = j.toString() + &quot; &quot; + &quot;kingfisher: &quot; + dataPoint.y.toString();;
				dataPointEO.center = {
					x: center.x, y: center.y
				};
				dataPointEO.y = dataPoint.y;
				dataPointEO.radius = outerRadius;
				dataPointEO.percentInnerRadius = percentInnerRadius;
				dataPointEO.indexLabelText = indexLabelText;
				dataPointEO.indexLabelPlacement = dataSeries.indexLabelPlacement;
				dataPointEO.indexLabelLineColor = dataPoint.indexLabelLineColor ? dataPoint.indexLabelLineColor : dataSeries.indexLabelLineColor ? dataSeries.indexLabelLineColor : dataPoint.color ? dataPoint.color : dataSeries._colorSet[j % dataSeries._colorSet.length];
				dataPointEO.indexLabelLineThickness = (!isNullOrUndefined(dataPoint.indexLabelLineThickness)) ? dataPoint.indexLabelLineThickness : dataSeries.indexLabelLineThickness;
				dataPointEO.indexLabelLineDashType = dataPoint.indexLabelLineDashType ? dataPoint.indexLabelLineDashType : dataSeries.indexLabelLineDashType;
				dataPointEO.indexLabelFontColor = dataPoint.indexLabelFontColor ? dataPoint.indexLabelFontColor : dataSeries.indexLabelFontColor;
				dataPointEO.indexLabelFontStyle = dataPoint.indexLabelFontStyle ? dataPoint.indexLabelFontStyle : dataSeries.indexLabelFontStyle;
				dataPointEO.indexLabelFontWeight = dataPoint.indexLabelFontWeight ? dataPoint.indexLabelFontWeight : dataSeries.indexLabelFontWeight;
				dataPointEO.indexLabelFontSize = dataPoint.indexLabelFontSize ? dataPoint.indexLabelFontSize : dataSeries.indexLabelFontSize;
				dataPointEO.indexLabelFontFamily = dataPoint.indexLabelFontFamily ? dataPoint.indexLabelFontFamily : dataSeries.indexLabelFontFamily;
				dataPointEO.indexLabelBackgroundColor = dataPoint.indexLabelBackgroundColor ? dataPoint.indexLabelBackgroundColor : dataSeries.indexLabelBackgroundColor ? dataSeries.indexLabelBackgroundColor : null;
				dataPointEO.indexLabelMaxWidth = dataPoint.indexLabelMaxWidth ? dataPoint.indexLabelMaxWidth : dataSeries.indexLabelMaxWidth ? dataSeries.indexLabelMaxWidth : plotArea.width * .33;
				dataPointEO.indexLabelWrap = typeof (dataPoint.indexLabelWrap) !== &quot;undefined&quot; ? dataPoint.indexLabelWrap : dataSeries.indexLabelWrap;

				dataPointEO.startAngle = j === 0 ? dataSeries.startAngle ? (dataSeries.startAngle / 180) * Math.PI : 0 : dataPointEOs[j - 1].endAngle;

				dataPointEO.startAngle = (dataPointEO.startAngle + (2 * Math.PI)) % (2 * Math.PI);

				dataPointEO.endAngle = dataPointEO.startAngle + ((2 * Math.PI / sum) * Math.abs(dataPoint.y));

				//var midAngle = dataPointEO.startAngle + Math.abs(dataPointEO.endAngle - dataPointEO.startAngle) / 2;
				var midAngle = (dataPointEO.endAngle + dataPointEO.startAngle) / 2;

				//var midAngle = (180 / Math.PI * midAngle);

				midAngle = (midAngle + (2 * Math.PI)) % (2 * Math.PI);

				dataPointEO.midAngle = midAngle;

				if (dataPointEO.midAngle &gt; (Math.PI / 2) - poleAnglularDistance &amp;&amp; dataPointEO.midAngle &lt; (Math.PI / 2) + poleAnglularDistance) {
					if (noDPNearSouthPole === 0 || dataPointEOs[firstDPCloseToSouth].midAngle &gt; dataPointEO.midAngle)
						firstDPCloseToSouth = j;

					noDPNearSouthPole++;
				}
				else if (dataPointEO.midAngle &gt; (3 * Math.PI / 2) - poleAnglularDistance &amp;&amp; dataPointEO.midAngle &lt; (3 * Math.PI / 2) + poleAnglularDistance) {
					if (noDPNearNorthPole === 0 || dataPointEOs[firstDPCloseToNorth].midAngle &gt; dataPointEO.midAngle)
						firstDPCloseToNorth = j;

					noDPNearNorthPole++;
				}


				if (midAngle &gt; (Math.PI / 2) &amp;&amp; midAngle &lt;= (3 * Math.PI / 2))
					dataPointEO.hemisphere = &quot;left&quot;;
				else
					dataPointEO.hemisphere = &quot;right&quot;;

				//dataPointEO.indexLabelText = j.toString() + &quot;; &quot; + dataPoint.y.toString() + &quot;; &quot; + midAngle.toString() + &quot;; junk&quot;;				
				dataPointEO.indexLabelTextBlock = new TextBlock(_this.plotArea.ctx, {
					fontSize: dataPointEO.indexLabelFontSize, fontFamily: dataPointEO.indexLabelFontFamily, fontColor: dataPointEO.indexLabelFontColor,
					fontStyle: dataPointEO.indexLabelFontStyle, fontWeight: dataPointEO.indexLabelFontWeight,
					horizontalAlign: &quot;left&quot;,
					backgroundColor: dataPointEO.indexLabelBackgroundColor,
					maxWidth: dataPointEO.indexLabelMaxWidth, maxHeight: dataPointEO.indexLabelWrap ? dataPointEO.indexLabelFontSize * 5 : dataPointEO.indexLabelFontSize * 1.5,
					text: dataPointEO.indexLabelText,
					padding: 0,
					//textBaseline: dataPointEO.indexLabelBackgroundColor ? &quot;middle&quot; : &quot;top&quot;
					textBaseline: &quot;top&quot;
				});

				dataPointEO.indexLabelTextBlock.measureText();

				//dataPoint.labelWidth = ctx.measureText(j.toString() + &quot;; &quot; + dataPoint.label).width;

				//console.log(dataPoint.label);
			}

			var noOfDPToRightOfSouthPole = 0;
			var noOfDPToLeftOfNorthPole = 0;
			var keepSameDirection = false; // once a dataPoint&#x27;s hemisphere is changed, others should follow the same so that there are no labes near pole pointing in opposite direction.

			for (var j = 0; j &lt; dataPoints.length; j++) {

				var dataPointEO = dataPointEOs[(firstDPCloseToSouth + j) % dataPoints.length];

				if (noDPNearSouthPole &gt; 1 &amp;&amp; dataPointEO.midAngle &gt; (Math.PI / 2) - poleAnglularDistance &amp;&amp; dataPointEO.midAngle &lt; (Math.PI / 2) + poleAnglularDistance) {

					if (noOfDPToRightOfSouthPole &lt;= noDPNearSouthPole / 2 &amp;&amp; !keepSameDirection) {
						dataPointEO.hemisphere = &quot;right&quot;;
						noOfDPToRightOfSouthPole++;
					}
					else {
						dataPointEO.hemisphere = &quot;left&quot;;
						keepSameDirection = true;
					}
				}
			}

			keepSameDirection = false;
			for (var j = 0; j &lt; dataPoints.length; j++) {

				var dataPointEO = dataPointEOs[(firstDPCloseToNorth + j) % dataPoints.length];

				//if (dataPoint.hemisphere = &quot;right&quot;)
				//	break;

				if (noDPNearNorthPole &gt; 1 &amp;&amp; dataPointEO.midAngle &gt; (3 * Math.PI / 2) - poleAnglularDistance &amp;&amp; dataPointEO.midAngle &lt; (3 * Math.PI / 2) + poleAnglularDistance) {

					if (noOfDPToLeftOfNorthPole &lt;= noDPNearNorthPole / 2 &amp;&amp; !keepSameDirection) {
						dataPointEO.hemisphere = &quot;left&quot;;
						noOfDPToLeftOfNorthPole++;
					}
					else {
						dataPointEO.hemisphere = &quot;right&quot;;
						keepSameDirection = true;
					}
				}
			}
		}//End of initLabels()

		function renderLabels() {

			var ctx = _this.plotArea.ctx;
			ctx.save();

			ctx.fillStyle = &quot;black&quot;;
			ctx.strokeStyle = &quot;grey&quot;;
			var fontSize = 16;
			//ctx.font = fontSize + &quot;px Arial&quot;;
			ctx.textBaseline = &quot;middle&quot;;
			ctx.lineJoin = &quot;round&quot;;
			var i = 0, j = 0;

			for (i = 0; i &lt; dataPoints.length; i++) {
				var dataPointEO = dataPointEOs[i];

				if (!dataPointEO.indexLabelText)
					continue;

				dataPointEO.indexLabelTextBlock.y -= dataPointEO.indexLabelTextBlock.height / 2;

				var xOffset = 0;

				if (dataPointEO.hemisphere === &quot;left&quot;) {
					var xOffset = dataSeries.indexLabelPlacement !== &quot;inside&quot; ? -(dataPointEO.indexLabelTextBlock.width + indexLabelLineEdgeLength) : -dataPointEO.indexLabelTextBlock.width / 2;
				}
				else {
					var xOffset = dataSeries.indexLabelPlacement !== &quot;inside&quot; ? indexLabelLineEdgeLength : -dataPointEO.indexLabelTextBlock.width / 2;
				}

				dataPointEO.indexLabelTextBlock.x += xOffset;
				dataPointEO.indexLabelTextBlock.render(true);
				dataPointEO.indexLabelTextBlock.x -= xOffset;

				//if (i &lt; 4)
				//	customPrompt(i + &quot;; &quot; + center.y + &quot;; &quot; + dataPointEO.indexLabelTextBlock.y.toFixed(2));

				dataPointEO.indexLabelTextBlock.y += dataPointEO.indexLabelTextBlock.height / 2;

				if (dataPointEO.indexLabelPlacement !== &quot;inside&quot; &amp;&amp; dataPointEO.indexLabelLineThickness &gt; 0) {
					var indexLabelLineStartX = dataPointEO.center.x + outerRadius * Math.cos(dataPointEO.midAngle);
					var indexLabelLineStartY = dataPointEO.center.y + outerRadius * Math.sin(dataPointEO.midAngle);

					//ctx.strokeStyle = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];
					ctx.strokeStyle = dataPointEO.indexLabelLineColor;
					ctx.lineWidth = dataPointEO.indexLabelLineThickness;

					if (ctx.setLineDash) {
						ctx.setLineDash(getLineDashArray(dataPointEO.indexLabelLineDashType, dataPointEO.indexLabelLineThickness));
					}

					//ctx.lineWidth = 4;
					ctx.beginPath();
					ctx.moveTo(indexLabelLineStartX, indexLabelLineStartY);
					ctx.lineTo(dataPointEO.indexLabelTextBlock.x, dataPointEO.indexLabelTextBlock.y);
					ctx.lineTo(dataPointEO.indexLabelTextBlock.x + (dataPointEO.hemisphere === &quot;left&quot; ? -indexLabelLineEdgeLength : indexLabelLineEdgeLength), dataPointEO.indexLabelTextBlock.y);
					ctx.stroke();
					//ctx.closePath();
					//window.alert(&quot;contine??&quot;);
					//animate();
				}

				ctx.lineJoin = &quot;miter&quot;;
			}

			ctx.save();
		}

		function animate(fractionComplete) {

			var ctx = _this.plotArea.ctx;

			ctx.clearRect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			ctx.fillStyle = _this.backgroundColor;
			ctx.fillRect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);

			var maxAngle = dataPointEOs[0].startAngle + (2 * Math.PI * fractionComplete);

			for (var i = 0; i &lt; dataPoints.length; i++) {

				var startAngle = i === 0 ? dataPointEOs[i].startAngle : endAngle;
				var endAngle = startAngle + (dataPointEOs[i].endAngle - dataPointEOs[i].startAngle);

				var shouldBreak = false;

				if (endAngle &gt; maxAngle) {
					endAngle = maxAngle;
					shouldBreak = true;
				}

				var color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];

				if (endAngle &gt; startAngle)
					drawSegment(_this.plotArea.ctx, dataPointEOs[i].center, dataPointEOs[i].radius, color, dataSeries.type, startAngle, endAngle, dataSeries.fillOpacity, dataPointEOs[i].percentInnerRadius);

				if (shouldBreak)
					break;
			}
		}

		function explodeToggle(fractionComplete) {

			var ctx = _this.plotArea.ctx;

			ctx.clearRect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);
			ctx.fillStyle = _this.backgroundColor;
			ctx.fillRect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);

			for (var i = 0; i &lt; dataPoints.length; i++) {

				var startAngle = dataPointEOs[i].startAngle;
				var endAngle = dataPointEOs[i].endAngle;

				if (endAngle &gt; startAngle) {


					var offsetX = (outerRadius * .07 * Math.cos(dataPointEOs[i].midAngle));
					var offsetY = (outerRadius * .07 * Math.sin(dataPointEOs[i].midAngle));
					var isInTransition = false;

					if (dataPoints[i].exploded) {
						if (Math.abs(dataPointEOs[i].center.x - (center.x + offsetX)) &gt; 0.000000001 || Math.abs(dataPointEOs[i].center.y - (center.y + offsetY)) &gt; 0.000000001) {

							dataPointEOs[i].center.x = center.x + offsetX * fractionComplete;
							dataPointEOs[i].center.y = center.y + offsetY * fractionComplete;

							isInTransition = true;
						}
					} else if (Math.abs(dataPointEOs[i].center.x - center.x) &gt; 0 || Math.abs(dataPointEOs[i].center.y - center.y) &gt; 0) {
						dataPointEOs[i].center.x = center.x + offsetX * (1 - fractionComplete);
						dataPointEOs[i].center.y = center.y + offsetY * (1 - fractionComplete);

						isInTransition = true;
					}

					if (isInTransition) {
						var entry = {
						};
						entry.dataSeries = dataSeries;
						entry.dataPoint = dataSeries.dataPoints[i];
						entry.index = i;
						_this._toolTip.highlightObjects([entry]);
					}

					var color = dataPoints[i].color ? dataPoints[i].color : dataSeries._colorSet[i % dataSeries._colorSet.length];

					drawSegment(_this.plotArea.ctx, dataPointEOs[i].center, dataPointEOs[i].radius, color, dataSeries.type, startAngle, endAngle, dataSeries.fillOpacity, dataPointEOs[i].percentInnerRadius);
				}
			}

			//window.alert(&quot;next??&quot;);
			renderLabels();
		}

		function areDataPointsTooClose(first, second) {

			var label1 = {
				x1: first.indexLabelTextBlock.x, y1: first.indexLabelTextBlock.y - first.indexLabelTextBlock.height / 2, x2: first.indexLabelTextBlock.x + first.indexLabelTextBlock.width, y2: first.indexLabelTextBlock.y + first.indexLabelTextBlock.height / 2
			};
			var label2 = {
				x1: second.indexLabelTextBlock.x, y1: second.indexLabelTextBlock.y - second.indexLabelTextBlock.height / 2, x2: second.indexLabelTextBlock.x + second.indexLabelTextBlock.width, y2: second.indexLabelTextBlock.y + second.indexLabelTextBlock.height / 2
			};

			if (label1.x2 &lt; label2.x1 - indexLabelLineEdgeLength || label1.x1 &gt; label2.x2 + indexLabelLineEdgeLength || label1.y1 &gt; label2.y2 + indexLabelLineEdgeLength || label1.y2 &lt; label2.y1 - indexLabelLineEdgeLength)
				return false;

			return true;
		}

		function getVerticalDistanceBetweenLabels(first, second) {

			var distance = 0;
			var label1 = {
				y: first.indexLabelTextBlock.y, y1: first.indexLabelTextBlock.y - first.indexLabelTextBlock.height / 2, y2: first.indexLabelTextBlock.y + first.indexLabelTextBlock.height / 2
			};
			var label2 = {
				y: second.indexLabelTextBlock.y, y1: second.indexLabelTextBlock.y - second.indexLabelTextBlock.height / 2, y2: second.indexLabelTextBlock.y + second.indexLabelTextBlock.height / 2
			};

			if (label2.y &gt; label1.y) {
				distance = label2.y1 - label1.y2;
			}
			else {
				distance = label1.y1 - label2.y2;
			}

			return distance;
		}

		function getNextLabelIndex(currentLabelIndex) {
			var nextLabelIndex = null;

			for (var i = 1; i &lt; dataPoints.length; i++) {

				nextLabelIndex = (currentLabelIndex + i + dataPointEOs.length) % dataPointEOs.length;

				if (dataPointEOs[nextLabelIndex].hemisphere !== dataPointEOs[currentLabelIndex].hemisphere) {
					nextLabelIndex = null;
					break;
				}
				else if ((dataPointEOs[nextLabelIndex].indexLabelText) &amp;&amp; (nextLabelIndex !== currentLabelIndex)
					&amp;&amp; ((getVerticalDistanceBetweenLabels(dataPointEOs[nextLabelIndex], dataPointEOs[currentLabelIndex]) &lt; 0) || (dataPointEOs[currentLabelIndex].hemisphere === &quot;right&quot; ? dataPointEOs[nextLabelIndex].indexLabelTextBlock.y &gt;= dataPointEOs[currentLabelIndex].indexLabelTextBlock.y : dataPointEOs[nextLabelIndex].indexLabelTextBlock.y &lt;= dataPointEOs[currentLabelIndex].indexLabelTextBlock.y)))
					break;
				else {
					nextLabelIndex = null;
				}
			}

			return nextLabelIndex;
		}

		function getPreviousLabelIndex(currentLabelIndex) {
			var prevLabelIndex = null;

			for (var i = 1; i &lt; dataPoints.length; i++) {

				prevLabelIndex = (currentLabelIndex - i + dataPointEOs.length) % dataPointEOs.length;

				if (dataPointEOs[prevLabelIndex].hemisphere !== dataPointEOs[currentLabelIndex].hemisphere) {
					prevLabelIndex = null;
					break;
				}
				else if ((dataPointEOs[prevLabelIndex].indexLabelText) &amp;&amp; (dataPointEOs[prevLabelIndex].hemisphere === dataPointEOs[currentLabelIndex].hemisphere) &amp;&amp; (prevLabelIndex !== currentLabelIndex)
					&amp;&amp; ((getVerticalDistanceBetweenLabels(dataPointEOs[prevLabelIndex], dataPointEOs[currentLabelIndex]) &lt; 0) || (dataPointEOs[currentLabelIndex].hemisphere === &quot;right&quot; ? dataPointEOs[prevLabelIndex].indexLabelTextBlock.y &lt;= dataPointEOs[currentLabelIndex].indexLabelTextBlock.y : dataPointEOs[prevLabelIndex].indexLabelTextBlock.y &gt;= dataPointEOs[currentLabelIndex].indexLabelTextBlock.y)))
					break;
				else {
					prevLabelIndex = null;
				}

			}

			return prevLabelIndex;
		}

		function rePositionLabels(dataPointIndex, offset, recursionCount) {
			recursionCount = (recursionCount || 0) + 1;

			if (recursionCount &gt; 1000)
				return 0;

			offset = offset || 0;

			var actualOffset = 0;

			//var labelYMin = 2;
			//var labelYMax = ctx.canvas.height - 2;
			//var labelYMin = _this.plotArea.ctx.canvas.height / 2 - indexLabelRadius * 1;
			//var labelYMax = _this.plotArea.ctx.canvas.height / 2 + indexLabelRadius * 1;

			var labelYMin = center.y - indexLabelRadius * 1;
			var labelYMax = center.y + indexLabelRadius * 1;

			//console.log(totalRecursions);

			if (dataPointIndex &gt;= 0 &amp;&amp; dataPointIndex &lt; dataPoints.length) {

				var dataPointEO = dataPointEOs[dataPointIndex];
				//if (dataPointIndex === 0)
				//	customPrompt(labelYMin.toFixed(2) + &quot;; &quot; + labelYMax.toFixed(2) + &quot;; &quot; + dataPointEO.indexLabelTextBlock.y.toFixed(2));

				// If label is already outside the bounds, return
				if ((offset &lt; 0 &amp;&amp; dataPointEO.indexLabelTextBlock.y &lt; labelYMin) || (offset &gt; 0 &amp;&amp; dataPointEO.indexLabelTextBlock.y &gt; labelYMax))
					return 0;


				var validOffset = offset;


				//Check if the offset falls within the bounds (labelYMin, labelYMax, tangential bounds) without considering overlap. Else use the closest offset that is possible - validOffset.
				{
					var distFromIndexLineStart = 0;
					var indexLabelLineStartX = 0;
					var indexLabelLineStartY = 0;
					var indexLabelAngle = 0;
					var indexLabelAngleWhenTangent = 0;

					if (validOffset &lt; 0) {
						if (dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2 &gt; labelYMin &amp;&amp; dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2 + validOffset &lt; labelYMin)
							validOffset = -(labelYMin - (dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2 + validOffset));
					} else {
						if (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 &lt; labelYMin &amp;&amp; dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 + validOffset &gt; labelYMax)
							validOffset = (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 + validOffset) - labelYMax;
					}

					var newlabelY = dataPointEO.indexLabelTextBlock.y + validOffset;
					var newlabelX = 0;

					if (dataPointEO.hemisphere === &quot;right&quot;) {
						newlabelX = center.x + Math.sqrt(Math.pow(indexLabelRadius, 2) - Math.pow(newlabelY - center.y, 2));
					}
					else
						newlabelX = center.x - Math.sqrt(Math.pow(indexLabelRadius, 2) - Math.pow(newlabelY - center.y, 2));


					indexLabelLineStartX = center.x + outerRadius * Math.cos(dataPointEO.midAngle);
					indexLabelLineStartY = center.y + outerRadius * Math.sin(dataPointEO.midAngle);

					distFromIndexLineStart = Math.sqrt(Math.pow(newlabelX - indexLabelLineStartX, 2) + Math.pow(newlabelY - indexLabelLineStartY, 2));

					indexLabelAngleWhenTangent = Math.acos(outerRadius / indexLabelRadius);

					//indexLabelAngle = Math.acos((outerRadius * outerRadius + distFromIndexLineStart * distFromIndexLineStart - indexLabelRadius * indexLabelRadius) / (2 * outerRadius * distFromIndexLineStart));
					indexLabelAngle = Math.acos((indexLabelRadius * indexLabelRadius + outerRadius * outerRadius - distFromIndexLineStart * distFromIndexLineStart) / (2 * outerRadius * indexLabelRadius));

					if (indexLabelAngle &lt; indexLabelAngleWhenTangent) {
						validOffset = newlabelY - dataPointEO.indexLabelTextBlock.y;
						//dataPointEO.indexLabelTextBlock.x = newlabelX;
					}
					else {

						validOffset = 0;

						//dataPointEO.indexLabelTextBlock.x = newlabelX;

						//Index Line is overlapping the pie. So lets find out the point where indexline becomes a tangent.

						//distFromIndexLineStart = Math.sqrt(indexLabelRadius * indexLabelRadius - outerRadius * outerRadius);
						////distFromIndexLineStart *= offset &lt; 0 ? -1 : 1;
						////indexLabelAngle = Math.acos((indexLabelRadius * indexLabelRadius + outerRadius * outerRadius - distFromIndexLineStart * distFromIndexLineStart) / (2 * outerRadius * indexLabelRadius));
						//indexLabelAngle = Math.atan2(distFromIndexLineStart, outerRadius);

						//newlabelX = center.x + indexLabelRadius * Math.cos(indexLabelAngle);
						//newlabelY = center.y + indexLabelRadius * Math.sin(indexLabelAngle);

						//actualOffset = newlabelY - dataPointEO.indexLabelTextBlock.y;

						//dataPointEO.indexLabelTextBlock.y = newlabelY;
						//dataPointEO.indexLabelTextBlock.x = newlabelX;

					}

				}

				//var tempIndex = (dataPointIndex + dataPointEOs.length - 1) % dataPointEOs.length;

				//var prevDataPointIndex = dataPointEOs[tempIndex].hemisphere === dataPointEO.hemisphere ? tempIndex : null;

				var prevDataPointIndex = getPreviousLabelIndex(dataPointIndex);

				//tempIndex = (dataPointIndex + dataPointEOs.length + 1) % dataPointEOs.length;

				//var nextDataPointIndex = dataPointEOs[tempIndex].hemisphere === dataPointEO.hemisphere ? tempIndex : null;

				var nextDataPointIndex = getNextLabelIndex(dataPointIndex);

				var otherdataPointEO, otherDataPointIndex, distanceFromOtherLabel;
				var otherDataPointOffset = 0;
				var otherDataPointActualOffset = 0;


				if (validOffset &lt; 0) {

					otherDataPointIndex = dataPointEO.hemisphere === &quot;right&quot; ? prevDataPointIndex : nextDataPointIndex;

					actualOffset = validOffset;

					if (otherDataPointIndex !== null) {

						//if (dataPointIndex &lt; 4)
						//	customPrompt(&quot;valid: &quot; + validOffset);

						var tempOffset = -validOffset;

						var distanceFromOtherLabel = (dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2) - (dataPointEOs[otherDataPointIndex].indexLabelTextBlock.y + dataPointEOs[otherDataPointIndex].indexLabelTextBlock.height / 2);

						if (distanceFromOtherLabel - tempOffset &lt; minDistanceBetweenLabels) {
							otherDataPointOffset = -tempOffset;
							//totalRecursions++;                            
							otherDataPointActualOffset = rePositionLabels(otherDataPointIndex, otherDataPointOffset, recursionCount + 1);

							//if (dataPointIndex &lt; 4)
							//	customPrompt(dataPointIndex + &quot;; &quot; + &quot;offset: &quot; + otherDataPointOffset);


							if (+otherDataPointActualOffset.toFixed(precision) &gt; +otherDataPointOffset.toFixed(precision)) {

								if (distanceFromOtherLabel &gt; minDistanceBetweenLabels)
									actualOffset = -(distanceFromOtherLabel - minDistanceBetweenLabels);
									//else
									//	actualOffset = 0;
								else
									actualOffset = -(tempOffset - (otherDataPointActualOffset - otherDataPointOffset));
							}

							//if (dataPointIndex &lt; 4)
							//	customPrompt(&quot;actual: &quot; + actualOffset);
						}

					}

				} else if (validOffset &gt; 0) {

					otherDataPointIndex = dataPointEO.hemisphere === &quot;right&quot; ? nextDataPointIndex : prevDataPointIndex;

					actualOffset = validOffset;

					if (otherDataPointIndex !== null) {

						var tempOffset = validOffset;

						var distanceFromOtherLabel = (dataPointEOs[otherDataPointIndex].indexLabelTextBlock.y - dataPointEOs[otherDataPointIndex].indexLabelTextBlock.height / 2) - (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2);

						if (distanceFromOtherLabel - tempOffset &lt; minDistanceBetweenLabels) {
							otherDataPointOffset = tempOffset;
							//totalRecursions++;                            
							otherDataPointActualOffset = rePositionLabels(otherDataPointIndex, otherDataPointOffset, recursionCount + 1);

							if (+otherDataPointActualOffset.toFixed(precision) &lt; +otherDataPointOffset.toFixed(precision)) {

								if (distanceFromOtherLabel &gt; minDistanceBetweenLabels)
									actualOffset = distanceFromOtherLabel - minDistanceBetweenLabels;
									//else
									//	actualOffset = 0;
								else
									actualOffset = tempOffset - (otherDataPointOffset - otherDataPointActualOffset);
							}
						}

					}

					//if (!(dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 + actualOffset &lt; labelYMax)) {
					//	if (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 &lt; labelYMax) {
					//		actualOffset = labelYMax - (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2);
					//	}
					//	else {
					//		actualOffset = 0;
					//	}
					//}

				}

				if (actualOffset) {

					var newLabelY = dataPointEO.indexLabelTextBlock.y + actualOffset;




					var newLabelX = 0;

					if (dataPointEO.hemisphere === &quot;right&quot;) {
						newLabelX = center.x + Math.sqrt(Math.pow(indexLabelRadius, 2) - Math.pow(newLabelY - center.y, 2));
					}
					else
						newLabelX = center.x - Math.sqrt(Math.pow(indexLabelRadius, 2) - Math.pow(newLabelY - center.y, 2));

					if (dataPointEO.midAngle &gt; (Math.PI / 2) - poleAnglularDistance &amp;&amp; dataPointEO.midAngle &lt; (Math.PI / 2) + poleAnglularDistance) {

						var prevDPIndex = (dataPointIndex - 1 + dataPointEOs.length) % dataPointEOs.length;
						var prevDP = dataPointEOs[prevDPIndex];
						var nextDP = dataPointEOs[(dataPointIndex + 1 + dataPointEOs.length) % dataPointEOs.length];

						if (dataPointEO.hemisphere === &quot;left&quot; &amp;&amp; prevDP.hemisphere === &quot;right&quot; &amp;&amp; newLabelX &gt; prevDP.indexLabelTextBlock.x) {
							newLabelX = prevDP.indexLabelTextBlock.x - 15;
						} else if (dataPointEO.hemisphere === &quot;right&quot; &amp;&amp; nextDP.hemisphere === &quot;left&quot; &amp;&amp; newLabelX &lt; nextDP.indexLabelTextBlock.x) {
							newLabelX = nextDP.indexLabelTextBlock.x + 15;
						}
					} else if (dataPointEO.midAngle &gt; (3 * Math.PI / 2) - poleAnglularDistance &amp;&amp; dataPointEO.midAngle &lt; (3 * Math.PI / 2) + poleAnglularDistance) {

						var prevDPIndex = (dataPointIndex - 1 + dataPointEOs.length) % dataPointEOs.length;
						var prevDP = dataPointEOs[prevDPIndex];
						var nextDP = dataPointEOs[(dataPointIndex + 1 + dataPointEOs.length) % dataPointEOs.length];

						if (dataPointEO.hemisphere === &quot;right&quot; &amp;&amp; prevDP.hemisphere === &quot;left&quot; &amp;&amp; newLabelX &lt; prevDP.indexLabelTextBlock.x) {
							newLabelX = prevDP.indexLabelTextBlock.x + 15;
						} else if (dataPointEO.hemisphere === &quot;left&quot; &amp;&amp; nextDP.hemisphere === &quot;right&quot; &amp;&amp; newLabelX &gt; nextDP.indexLabelTextBlock.x) {
							newLabelX = nextDP.indexLabelTextBlock.x - 15;
						}
					}

					//if (actualOffset &lt; 0 &amp;&amp; dataPointIndex &lt; 4)
					//	customPrompt(actualOffset.toFixed(2) + &quot;; &quot; + dataPointEO.indexLabelTextBlock.y.toFixed(2) + &quot;; &quot; + newLabelY.toFixed(2));

					dataPointEO.indexLabelTextBlock.y = newLabelY;

					dataPointEO.indexLabelTextBlock.x = newLabelX;

					dataPointEO.indexLabelAngle = Math.atan2((dataPointEO.indexLabelTextBlock.y - center.y), (dataPointEO.indexLabelTextBlock.x - center.x));

				}


			}

			return actualOffset;
		}


		function positionLabels() {
			var ctx = _this.plotArea.ctx;

			ctx.fillStyle = &quot;grey&quot;;
			ctx.strokeStyle = &quot;grey&quot;;
			var fontSize = 16;
			ctx.font = fontSize + &quot;px Arial&quot;;
			ctx.textBaseline = &quot;middle&quot;;
			var i = 0, j = 0;
			var deltaR = 0;

			var resizeFlag = true;

			for (j = 0; j &lt; 10 &amp;&amp; (j &lt; 1 || deltaR &gt; 0) ; j++) {

				if (dataSeries.radius || (!dataSeries.radius &amp;&amp; typeof dataSeries.innerRadius !== &#x27;undefined&#x27; &amp;&amp; dataSeries.innerRadius !== null &amp;&amp; outerRadius - deltaR &lt;= innerRadius))
					resizeFlag = false;

				if (resizeFlag)
					outerRadius -= deltaR;

				deltaR = 0;

				if (dataSeries.indexLabelPlacement !== &quot;inside&quot;) {

					indexLabelRadius = outerRadius * indexLabelRadiusToRadiusRatio;

					for (i = 0; i &lt; dataPoints.length; i++) {
						var dataPointEO = dataPointEOs[i];

						dataPointEO.indexLabelTextBlock.x = center.x + indexLabelRadius * Math.cos(dataPointEO.midAngle);
						dataPointEO.indexLabelTextBlock.y = center.y + indexLabelRadius * Math.sin(dataPointEO.midAngle);

						dataPointEO.indexLabelAngle = dataPointEO.midAngle;
						dataPointEO.radius = outerRadius;
						dataPointEO.percentInnerRadius = percentInnerRadius;
						//dataPointEO.indexLabelFontSize = dataPoint.indexLabelFontSize ? dataPoint.indexLabelFontSize : dataSeries.indexLabelFontSize;
					}

					var currentDataPoint, nextDataPoint;
					for (i = 0; i &lt; dataPoints.length; i++) {

						var dataPointEO = dataPointEOs[i];
						//dataPointEO.lab
						//resetAnimationFrame();
						//animate();
						//renderLabels();

						//var prevDataPointIndex = (i - 1 + dataPointEOs.length) % dataPointEOs.length;

						//var nextDataPointIndex = (i + 1 + dataPointEOs.length) % dataPointEOs.length;
						//nextDataPointIndex = dataPointEOs[nextDataPointIndex].hemisphere === dataPointEO.hemisphere &amp;&amp; nextDataPointIndex !== i ? nextDataPointIndex : null;

						var nextDataPointIndex = getNextLabelIndex(i);

						if (nextDataPointIndex === null)
							continue;

						currentDataPoint = dataPointEOs[i];
						nextDataPoint = dataPointEOs[nextDataPointIndex];


						var distanceFromNextLabel = 0;

						//if (dataPointEO.hemisphere === &quot;right&quot;)
						//	distanceFromNextLabel = (nextDataPoint.indexLabelTextBlock.y - nextDataPoint.indexLabelTextBlock.height / 2) - (currentDataPoint.indexLabelTextBlock.y + currentDataPoint.indexLabelTextBlock.height / 2) - minDistanceBetweenLabels;
						//else
						//	distanceFromNextLabel = (currentDataPoint.indexLabelTextBlock.y - currentDataPoint.indexLabelTextBlock.height / 2) - (nextDataPoint.indexLabelTextBlock.y + nextDataPoint.indexLabelTextBlock.height / 2) - minDistanceBetweenLabels;

						distanceFromNextLabel = getVerticalDistanceBetweenLabels(currentDataPoint, nextDataPoint) - minDistanceBetweenLabels;


						if (distanceFromNextLabel &lt; 0) {

							var dataPointsAbove = 0;
							var dataPointsBelow = 0;
							//var indexLabelAngleWhenTangent = Math.acos(outerRadius / indexLabelRadius) / Math.PI * 180;


							for (var k = 0; k &lt; dataPoints.length; k++) {

								if (k === i)
									continue;

								//if (dataPointEOs[k].hemisphere !== dataPointEO.hemisphere || Math.abs(dataPointEOs[k].midAngle - dataPointEO.midAngle) &gt; 30)
								//	continue;
								//if (dataPointEOs[k].hemisphere !== dataPointEO.hemisphere || Math.abs(dataPointEOs[k].labelAngle - dataPointEO.indexLabelAngle) &gt; 30)
								//	continue;
								//if (dataPointEOs[k].hemisphere !== dataPointEO.hemisphere || Math.abs(dataPointEOs[k].midAngle - dataPointEO.midAngle) &gt; indexLabelAngleWhenTangent)
								//	continue;
								if (dataPointEOs[k].hemisphere !== dataPointEO.hemisphere)
									continue;

								if (dataPointEOs[k].indexLabelTextBlock.y &lt; dataPointEO.indexLabelTextBlock.y)
									dataPointsAbove++;
								else
									dataPointsBelow++;
							}

							//var upWardsOffset = (distanceFromNextLabel) / dataPoints.length * (dataPointsBelow);
							var upWardsOffset = (distanceFromNextLabel) / (dataPointsAbove + dataPointsBelow || 1) * (dataPointsBelow);
							var downWardsOffset = -1 * (distanceFromNextLabel - upWardsOffset);

							var actualUpwardOffset = 0;
							var actualDownwardOffset = 0;

							if (dataPointEO.hemisphere === &quot;right&quot;) {
								actualUpwardOffset = rePositionLabels(i, upWardsOffset);

								//if (i &lt; 4 &amp;&amp; actualDownwardOffset !== upWardsOffset)
								//	customPrompt(i + &quot;; &quot; + upWardsOffset.toFixed(2) + &quot;; &quot; + actualUpwardOffset.toFixed(2));


								downWardsOffset = -1 * (distanceFromNextLabel - actualUpwardOffset);

								actualDownwardOffset = rePositionLabels(nextDataPointIndex, downWardsOffset);

								//window.alert(typeof +downWardsOffset.toFixed(precision));
								//Setting precision to make sure that they don&#x27;t become not equal become of minor differences - like a difference of .000001
								if (+actualDownwardOffset.toFixed(precision) &lt; +downWardsOffset.toFixed(precision) &amp;&amp; +actualUpwardOffset.toFixed(precision) &lt;= +upWardsOffset.toFixed(precision))
									rePositionLabels(i, -(downWardsOffset - actualDownwardOffset));

							} else {
								actualUpwardOffset = rePositionLabels(nextDataPointIndex, upWardsOffset);

								downWardsOffset = -1 * (distanceFromNextLabel - actualUpwardOffset);

								actualDownwardOffset = rePositionLabels(i, downWardsOffset);

								//Setting precision to make sure that they don&#x27;t become not equal become of minor differences - like a difference of .000001
								if (+actualDownwardOffset.toFixed(precision) &lt; +downWardsOffset.toFixed(precision) &amp;&amp; +actualUpwardOffset.toFixed(precision) &lt;= +upWardsOffset.toFixed(precision))
									rePositionLabels(nextDataPointIndex, -(downWardsOffset - actualDownwardOffset));
							}
						}


						//resetAnimationFrame();
						//animate();
						//renderLabels();
						//window.alert(&quot;next??&quot;);
					}
				} else {
					for (i = 0; i &lt; dataPoints.length; i++) {

						var dataPointEO = dataPointEOs[i];
						indexLabelRadius = dataSeries.type === &quot;pie&quot; ? outerRadius * .7 : outerRadius * .8;


						var dx = center.x + indexLabelRadius * (Math.cos((dataPointEO.midAngle)));
						var dy = center.y + indexLabelRadius * (Math.sin((dataPointEO.midAngle)));

						dataPointEO.indexLabelTextBlock.x = dx;
						dataPointEO.indexLabelTextBlock.y = dy;
					}
				}

				// Resize Pie based on the label length.
				for (i = 0; i &lt; dataPoints.length; i++) {

					dataPointEO = dataPointEOs[i];

					var size = dataPointEO.indexLabelTextBlock.measureText();
					// To make sure that null text or empty strings don&#x27;t affect the radius. Required when user is not showing any labels
					if (size.height === 0 || size.width === 0)
						continue;

					var xOverflow = 0;
					var xdr = 0;

					if (dataPointEO.hemisphere === &quot;right&quot;) {
						xOverflow = plotArea.x2 - (dataPointEO.indexLabelTextBlock.x + dataPointEO.indexLabelTextBlock.width + indexLabelLineEdgeLength);
						xOverflow *= -1;
					} else {
						xOverflow = plotArea.x1 - (dataPointEO.indexLabelTextBlock.x - dataPointEO.indexLabelTextBlock.width - indexLabelLineEdgeLength);
					}
					if (xOverflow &gt; 0) {
						if (!resizeFlag &amp;&amp; dataPointEO.indexLabelText) {
							var newIndexLabelMaxWidth = dataPointEO.hemisphere === &quot;right&quot; ? plotArea.x2 - dataPointEO.indexLabelTextBlock.x : dataPointEO.indexLabelTextBlock.x - plotArea.x1;
							dataPointEO.indexLabelTextBlock.maxWidth * .3 &gt; newIndexLabelMaxWidth ? dataPointEO.indexLabelText = &quot;&quot; : dataPointEO.indexLabelTextBlock.maxWidth = newIndexLabelMaxWidth * .85;
							if (dataPointEO.indexLabelTextBlock.maxWidth * .3 &lt; newIndexLabelMaxWidth) dataPointEO.indexLabelTextBlock.x -= dataPointEO.hemisphere === &quot;right&quot; ? 2 : -2;
						}

						if (Math.abs(dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2 - center.y) &lt; outerRadius
							|| Math.abs(dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 - center.y) &lt; outerRadius) {

							xdr = xOverflow / Math.abs(Math.cos(dataPointEO.indexLabelAngle));

							if (xdr &gt; 9)
								xdr = xdr * .3;

							if (xdr &gt; deltaR)
								deltaR = xdr;
						}
					}

					var yOverflow = 0;
					var ydr = 0;

					if (dataPointEO.indexLabelAngle &gt; 0 &amp;&amp; dataPointEO.indexLabelAngle &lt; Math.PI) {
						yOverflow = plotArea.y2 - (dataPointEO.indexLabelTextBlock.y + dataPointEO.indexLabelTextBlock.height / 2 + 5);
						yOverflow *= -1;
					} else {
						yOverflow = plotArea.y1 - (dataPointEO.indexLabelTextBlock.y - dataPointEO.indexLabelTextBlock.height / 2 - 5);
					}

					if (yOverflow &gt; 0) {
						if (!resizeFlag &amp;&amp; dataPointEO.indexLabelText) {
							var positionMultiplier = dataPointEO.indexLabelAngle &gt; 0 &amp;&amp; dataPointEO.indexLabelAngle &lt; Math.PI ? -1 : 1;
							if (rePositionLabels(i, yOverflow * positionMultiplier) === 0)
								rePositionLabels(i, 2 * positionMultiplier);
						}
						if (Math.abs(dataPointEO.indexLabelTextBlock.x - center.x) &lt; outerRadius) {

							ydr = yOverflow / Math.abs(Math.sin(dataPointEO.indexLabelAngle));

							if (ydr &gt; 9)
								ydr = ydr * .3;

							if (ydr &gt; deltaR)
								deltaR = ydr;

						}
					}

				}

				function removeLabelsForSmallSegments(totalOverlap, startIndex, endIndex) {

					var dpEOs = [];
					var totalRemovedLabelHeight = 0;

					for (var i = startIndex; true; i = (i + 1 + dataPoints.length) % dataPoints.length) {
						dpEOs.push(dataPointEOs[i]);

						if (i === endIndex)
							break;
					}

					dpEOs.sort(function (entry1, entry2) {
						return entry1.y - entry2.y;
					});

					for (var i = 0; i &lt; dpEOs.length; i++) {
						var dpEO = dpEOs[i];

						if (totalRemovedLabelHeight &lt; totalOverlap * .7) {
							totalRemovedLabelHeight += dpEO.indexLabelTextBlock.height;
							dpEO.indexLabelTextBlock.text = &quot;&quot;;
							dpEO.indexLabelText = &quot;&quot;;
							dpEO.indexLabelTextBlock.measureText();
						} else
							break;
					}

				}

				//resetAnimationFrame(1);
				//animate();
				//window.alert(&quot;next??&quot;);
				function skipLabels() {
					var overlapStartIndex = -1;
					var overlapEndIndex = -1;
					var totalOverlap = 0;
					var removeLabels = false;

					for (var k = 0; k &lt; dataPoints.length; k++) {
						removeLabels = false;
						currentDataPoint = dataPointEOs[k];

						if (!currentDataPoint.indexLabelText)
							continue;

						var nextLabelIndex = getNextLabelIndex(k);
						if (nextLabelIndex === null)
							continue;

						var nextDataPoint = dataPointEOs[nextLabelIndex];

						distanceFromNextLabel = 0;

						//if (nextDataPoint.indexLabelTextBlock.y &gt; currentDataPoint.indexLabelTextBlock.y)
						//	distanceFromNextLabel = (nextDataPoint.indexLabelTextBlock.y - (nextDataPoint.indexLabelTextBlock.height / 2)) - (currentDataPoint.indexLabelTextBlock.y + (currentDataPoint.indexLabelTextBlock.height / 2));
						//else
						//	distanceFromNextLabel = (currentDataPoint.indexLabelTextBlock.y - (currentDataPoint.indexLabelTextBlock.height / 2)) - (nextDataPoint.indexLabelTextBlock.y + (nextDataPoint.indexLabelTextBlock.height / 2));

						distanceFromNextLabel = getVerticalDistanceBetweenLabels(currentDataPoint, nextDataPoint);

						if (distanceFromNextLabel &lt; 0 &amp;&amp; areDataPointsTooClose(currentDataPoint, nextDataPoint)) {
							//if (distanceFromNextLabel &lt; 0 &amp;&amp; areDataPointsTooClose(currentDataPoint, nextDataPoint) ) {
							if (overlapStartIndex &lt; 0)
								overlapStartIndex = k;

							if (nextLabelIndex !== overlapStartIndex) {
								overlapEndIndex = nextLabelIndex;

								totalOverlap += -distanceFromNextLabel;
							}

							if (k % Math.max(dataPoints.length / 10, 3) === 0)
								removeLabels = true;

							//nextDataPoint.indexLabelText = &quot;&quot;;
							//nextDataPoint.indexLabelTextBlock.text = &quot;&quot;;
							//nextDataPoint.indexLabelTextBlock.measureText();
						} else {

							removeLabels = true;
						}

						if (removeLabels) {

							if (totalOverlap &gt; 0 &amp;&amp; overlapStartIndex &gt;= 0 &amp;&amp; overlapEndIndex &gt;= 0) {
								removeLabelsForSmallSegments(totalOverlap, overlapStartIndex, overlapEndIndex);

								overlapStartIndex = -1;
								overlapEndIndex = -1;
								totalOverlap = 0;
							}
						}
					}

					if (totalOverlap &gt; 0)
						removeLabelsForSmallSegments(totalOverlap, overlapStartIndex, overlapEndIndex);
				}

				skipLabels();


			}
			//window.alert(&quot;next??&quot;);


			//resetAnimationFrame(_this.animationEnabled &amp;&amp; _this.renderCount === 0 ? isCanvasSupported ? 60 : 30 : 1);
			//animate();

			//console.log(&quot;totalRecursions: &quot; + totalRecursions);
		}


		this.pieDoughnutClickHandler = function (e) {

			if (_this.isAnimating) {
				return;
			}

			//if explodeOnClick === true
			if ((isNullOrUndefined(e.dataSeries.explodeOnClick) || e.dataSeries.explodeOnClick)) {
				var i = e.dataPointIndex;
				var dataPoint = e.dataPoint;
				var dataSeries = this;


				var id = dataSeries.dataPointIds[i];

				//dataPointEO = _this._eventManager.objectMap[id];

				if (dataPoint.exploded)
					dataPoint.exploded = false;
				else
					dataPoint.exploded = true;


				// So that it doesn&#x27;t try to explode when there is only one segment
				if (dataSeries.dataPoints.length &gt; 1) {
					_this._animator.animate(0, explodeDuration, function (fractionComplete) {

						explodeToggle(fractionComplete);
						renderChartElementsInPlotArea();
						//console.log(&quot;Explode Start&quot;);

					});
				}
			}
			return;
		}

		initLabels();

		positionLabels();
		positionLabels();
		positionLabels();
		positionLabels();

		this.disableToolTip = true;
		this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function (fractionComplete) {

			animate(fractionComplete);
			renderChartElementsInPlotArea();

		}, function () {

			_this.disableToolTip = false;
			_this._animator.animate(0, _this.animatedRender ? explodeDuration : 0, function (fractionComplete) {

				explodeToggle(fractionComplete);
				renderChartElementsInPlotArea();

			});

			//console.log(&quot;Animation Complete&quot;);
		});

		function renderChartElementsInPlotArea() {

			_this.plotArea.layoutManager.reset();

			if (_this._title) {
				if (_this._title.dockInsidePlotArea || (_this._title.horizontalAlign === &quot;center&quot; &amp;&amp; _this._title.verticalAlign === &quot;center&quot;))
					_this._title.render();

			}

			if (_this.subtitles)
				for (var i = 0; i &lt; _this.subtitles.length; i++) {
					var subtitle = _this.subtitles[i];
					if (subtitle.dockInsidePlotArea || (subtitle.horizontalAlign === &quot;center&quot; &amp;&amp; subtitle.verticalAlign === &quot;center&quot;))
						subtitle.render();
				}

			if (_this.legend) {
				if (_this.legend.dockInsidePlotArea || (_this.legend.horizontalAlign === &quot;center&quot; &amp;&amp; _this.legend.verticalAlign === &quot;center&quot;))
					_this.legend.render();
			}
		}

		//this.ctx.strokeRect(plotArea.x1 + 1, plotArea.y1, plotArea.width - 2, plotArea.height);
	}

	//#endregion pieChart


	//#endregion Render Methods
	Chart.prototype.animationRequestId = null;

	Chart.prototype.requestAnimFrame = (function () {
		return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function (callback) {
					window.setTimeout(callback, 1000 / 60);
				};
	})();

	Chart.prototype.cancelRequestAnimFrame = (function () {
		return window.cancelAnimationFrame ||
			window.webkitCancelRequestAnimationFrame ||
			window.mozCancelRequestAnimationFrame ||
			window.oCancelRequestAnimationFrame ||
			window.msCancelRequestAnimationFrame ||
			clearTimeout
	})();

	//#endregion Class Chart

	//#region Class LayoutManager
	function LayoutManager(x1, y1, x2, y2, padding) {

		if (typeof (padding) === &quot;undefined&quot;)
			padding = 0;

		this._padding = padding;

		this._x1 = x1;
		this._y1 = y1;
		this._x2 = x2;
		this._y2 = y2;

		this._topOccupied = this._padding;
		this._bottomOccupied = this._padding;
		this._leftOccupied = this._padding;
		this._rightOccupied = this._padding;
	}

	LayoutManager.prototype.registerSpace = function (position, size) {
		if (position === &quot;top&quot;) {
			this._topOccupied += size.height;
		}
		else if (position === &quot;bottom&quot;) {
			this._bottomOccupied += size.height;
		} else if (position === &quot;left&quot;) {
			this._leftOccupied += size.width; // this is width when seen upright/vertically
		} else if (position === &quot;right&quot;) {
			this._rightOccupied += size.width;// this is width when seen upright/vertically
		}
	}

	LayoutManager.prototype.unRegisterSpace = function (position, size) {
		if (position === &quot;top&quot;) {
			this._topOccupied -= size.height;
		}
		else if (position === &quot;bottom&quot;) {
			this._bottomOccupied -= size.height;
		} else if (position === &quot;left&quot;) {
			this._leftOccupied -= size.width;// this is width when seen upright/vertically
		} else if (position === &quot;right&quot;) {
			this._rightOccupied -= size.width;// this is width when seen upright/vertically
		}
	}

	LayoutManager.prototype.getFreeSpace = function () {
		///&lt;signature&gt;
		///&lt;summary&gt;Returns available free space {x1:number, y1:number, x2:number, y2:number}&lt;/summary&gt;
		///&lt;/signature&gt;

		return {
			x1: this._x1 + this._leftOccupied,
			y1: this._y1 + this._topOccupied,
			x2: this._x2 - this._rightOccupied,
			y2: this._y2 - this._bottomOccupied,
			width: (this._x2 - this._x1) - this._rightOccupied - this._leftOccupied,
			height: (this._y2 - this._y1) - this._bottomOccupied - this._topOccupied
		};
	}

	LayoutManager.prototype.reset = function () {
		//so that there is enough padding.
		this._topOccupied = this._padding;
		this._bottomOccupied = this._padding;
		this._leftOccupied = this._padding;
		this._rightOccupied = this._padding;
	}
	//#endregion Class LayoutManager

	//#region Class TextBlock
	function TextBlock(ctx, options) {
		TextBlock.base.constructor.call(this, &quot;TextBlock&quot;, options);

		this.ctx = ctx;
		this._isDirty = true;
		this._wrappedText = null;
		this._lineHeight = getFontHeightInPixels(this.fontFamily, this.fontSize, this.fontWeight);
	}
	extend(TextBlock, CanvasJSObject);
	TextBlock.prototype.render = function (preserveContext) {
		if (preserveContext)
			this.ctx.save();

		var font = this.ctx.font;
		this.ctx.textBaseline = this.textBaseline;

		var offsetY = 0;

		if (this._isDirty)
			this.measureText(this.ctx);

		this.ctx.translate(this.x, this.y + offsetY);

		if (this.textBaseline === &quot;middle&quot;) {
			offsetY = -this._lineHeight / 2;
		}

		this.ctx.font = this._getFontString();

		this.ctx.rotate(Math.PI / 180 * this.angle);

		var textLeft = 0;
		var textTop = this.padding;
		//var textTop = this.padding;
		var line = null;

		if ((this.borderThickness &gt; 0 &amp;&amp; this.borderColor) || this.backgroundColor) {
			this.ctx.roundRect(0, offsetY, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);

			//if (this.textBaseline === &quot;middle&quot;) {
			//	//textTop += this.fontSize / 2;
			//	textTop += this._lineHeight / 2;
			//}
		}

		this.ctx.fillStyle = this.fontColor;

		for (var i = 0; i &lt; this._wrappedText.lines.length; i++) {

			line = this._wrappedText.lines[i];
			if (this.horizontalAlign === &quot;right&quot;)
				textLeft = this.width - line.width - this.padding;
			else if (this.horizontalAlign === &quot;left&quot;)
				textLeft = this.padding;
			else if (this.horizontalAlign === &quot;center&quot;)
				textLeft = (this.width - this.padding * 2) / 2 - line.width / 2 + this.padding;

			this.ctx.fillText(line.text, textLeft, textTop);

			textTop += line.height;
		}

		this.ctx.font = font;

		if (preserveContext)
			this.ctx.restore();
	}

	TextBlock.prototype.setText = function (text) {
		this.text = text;
		this._isDirty = true;
		this._wrappedText = null;
	}

	TextBlock.prototype.measureText = function () {
		if (this.maxWidth === null) {
			throw (&quot;Please set maxWidth and height for TextBlock&quot;);
		}

		this._wrapText(this.ctx);
		this._isDirty = false;

		return {
			width: this.width, height: this.height
		}
	}

	TextBlock.prototype._getLineWithWidth = function (text, width, clipWord) {
		text = String(text);
		clipWord = clipWord || false;

		if (!text)
			return {
				text: &quot;&quot;, width: 0
			};

		var textWidth = 0,
			min = 0,
			max = text.length - 1,
			mid = Infinity;

		this.ctx.font = this._getFontString();

		while (min &lt;= max) {
			mid = Math.floor((min + max) / 2);
			var tempText = text.substr(0, mid + 1);

			textWidth = this.ctx.measureText(tempText).width;

			if (textWidth &lt; width) {
				min = mid + 1;
			} else if (textWidth &gt; width) {
				max = mid - 1;
			} else {
				break;
			}
		}

		//edge cases
		if (textWidth &gt; width &amp;&amp; tempText.length &gt; 1) {
			tempText = tempText.substr(0, tempText.length - 1);
			textWidth = this.ctx.measureText(tempText).width;
		}

		var isClipped = true;

		if (tempText.length === text.length || text[tempText.length] === &quot; &quot;)
			isClipped = false;

		if (isClipped) {
			var resultWords = tempText.split(&quot; &quot;);
			if (resultWords.length &gt; 1)
				resultWords.pop();

			tempText = resultWords.join(&quot; &quot;);
			textWidth = this.ctx.measureText(tempText).width;
		}

		return {
			text: tempText, width: textWidth
		};
	}

	TextBlock.prototype._wrapText = function wrapText() {
		//this.ctx.save();
		var text = new String(trimString(String(this.text)));
		var lines = [];
		var font = this.ctx.font; // Save the current Font
		var height = 0;
		var width = 0;

		this.ctx.font = this._getFontString();

		while (text.length &gt; 0) {

			var maxWidth = this.maxWidth - this.padding * 2;
			var maxHeight = this.maxHeight - this.padding * 2;

			var line = this._getLineWithWidth(text, maxWidth, false);
			line.height = this._lineHeight;

			lines.push(line);

			width = Math.max(width, line.width);
			height += line.height;
			text = trimString(text.slice(line.text.length, text.length));

			if (maxHeight &amp;&amp; height &gt; maxHeight) {
				var line = lines.pop();
				height -= line.height;
			}
		}

		this._wrappedText = {
			lines: lines, width: width, height: height
		};
		this.width = width + this.padding * 2;
		this.height = height + this.padding * 2;

		this.ctx.font = font; // Restore the font
	}

	TextBlock.prototype._getFontString = function () {
		//return this.fontStyle + &quot; &quot; + this.fontWeight + &quot; &quot; + this.fontSize + &quot;px &quot; + this.fontFamily
		return getFontString(&quot;&quot;, this, null);
	}

	//#endregion Class TextBlock

	//#region Class Title

	function Title(chart, options) {
		Title.base.constructor.call(this, &quot;Title&quot;, options, chart.theme);

		this.chart = chart;
		this.canvas = chart.canvas;
		this.ctx = this.chart.ctx;

		//For assigning zero margin if title and subtitle situated at the same place
		if (isNullOrUndefined(this._options.margin) &amp;&amp; chart._options.subtitles) {
			var subtitles = chart._options.subtitles;
			for (var i = 0; i &lt; subtitles.length; i++) {
				if ((isNullOrUndefined(subtitles[i].horizontalAlign) &amp;&amp; this.horizontalAlign === &quot;center&quot; || subtitles[i].horizontalAlign === this.horizontalAlign) &amp;&amp; (isNullOrUndefined(subtitles[i].verticalAlign) &amp;&amp; this.verticalAlign === &quot;top&quot; || subtitles[i].verticalAlign === this.verticalAlign) &amp;&amp; (!subtitles[i].dockInsidePlotArea === !this.dockInsidePlotArea)) {
					this.margin = 0;
					break;
				}
			}
		}

		if (typeof (this._options.fontSize) === &quot;undefined&quot;) {

			this.fontSize = this.chart.getAutoFontSize(this.fontSize);

			//window.console.log(&quot;Chart Title fontSize: &quot; + this.fontSize);
		}

		this.width = null,//read only
		this.height = null//read only
		this.bounds = {
			x1: null, y1: null, x2: null, y2: null
		};
	}

	extend(Title, CanvasJSObject);
	Title.prototype.render = function () {

		if (!this.text)
			return;

		var container = (!this.dockInsidePlotArea ? this.chart : this.chart.plotArea);
		var freespace = container.layoutManager.getFreeSpace();
		var left = freespace.x1;
		var top = freespace.y1;
		var angle = 0;
		var maxHeight = 0;
		var containerMargin = 2; //Margin towards the container
		var rightOffset = this.chart._menuButton &amp;&amp; this.chart.exportEnabled &amp;&amp; this.verticalAlign === &quot;top&quot; ? 22 : 0; //So that Title doesn&#x27;t overlap menu button.

		var textBlockHorizontalAlign;
		var position;

		if (this.verticalAlign === &quot;top&quot; || this.verticalAlign === &quot;bottom&quot;) {
			if (this.maxWidth === null)
				this.maxWidth = freespace.width - containerMargin * 2 - rightOffset * (this.horizontalAlign === &quot;center&quot; ? 2 : 1);

			maxHeight = freespace.height * .5 - this.margin - containerMargin;
			angle = 0;
		}
		else if (this.verticalAlign === &quot;center&quot;) {

			if (this.horizontalAlign === &quot;left&quot; || this.horizontalAlign === &quot;right&quot;) {
				if (this.maxWidth === null)
					this.maxWidth = freespace.height - containerMargin * 2;

				maxHeight = freespace.width * .5 - this.margin - containerMargin;
			} else if (this.horizontalAlign === &quot;center&quot;) {
				if (this.maxWidth === null)
					this.maxWidth = freespace.width - containerMargin * 2;

				maxHeight = freespace.height * .5 - containerMargin * 2;
			}
		}

		if (!this.wrap)
			maxHeight = Math.min(maxHeight, Math.max(this.fontSize * 1.5, this.fontSize + this.padding * 2.5));
		//console.log(this.maxWidth);

		var textBlock = new TextBlock(this.ctx, {
			fontSize: this.fontSize, fontFamily: this.fontFamily, fontColor: this.fontColor,
			fontStyle: this.fontStyle, fontWeight: this.fontWeight,
			horizontalAlign: this.horizontalAlign, verticalAlign: this.verticalAlign,
			borderColor: this.borderColor, borderThickness: this.borderThickness,
			backgroundColor: this.backgroundColor,
			maxWidth: this.maxWidth, maxHeight: maxHeight,
			cornerRadius: this.cornerRadius,
			text: this.text,
			padding: this.padding,
			textBaseline: &quot;top&quot;
		});

		var textBlockSize = textBlock.measureText();

		if (this.verticalAlign === &quot;top&quot; || this.verticalAlign === &quot;bottom&quot;) {

			if (this.verticalAlign === &quot;top&quot;) {
				top = freespace.y1 + containerMargin;
				position = &quot;top&quot;;
			}
			else if (this.verticalAlign === &quot;bottom&quot;) {
				top = freespace.y2 - containerMargin - textBlockSize.height;
				position = &quot;bottom&quot;;
			}

			if (this.horizontalAlign === &quot;left&quot;) {
				left = freespace.x1 + containerMargin;
			}
			else if (this.horizontalAlign === &quot;center&quot;) {
				left = freespace.x1 + freespace.width / 2 - textBlockSize.width / 2;
			}
			else if (this.horizontalAlign === &quot;right&quot;) {
				left = freespace.x2 - containerMargin - textBlockSize.width - rightOffset;
			}

			textBlockHorizontalAlign = this.horizontalAlign;

			this.width = textBlockSize.width;
			this.height = textBlockSize.height;
		}
		else if (this.verticalAlign === &quot;center&quot;) {

			if (this.horizontalAlign === &quot;left&quot;) {

				left = freespace.x1 + containerMargin;
				top = freespace.y2 - containerMargin - (this.maxWidth / 2 - textBlockSize.width / 2);
				angle = -90;

				position = &quot;left&quot;;
				this.width = textBlockSize.height;
				this.height = textBlockSize.width;
			}
			else if (this.horizontalAlign === &quot;right&quot;) {
				left = freespace.x2 - containerMargin;
				top = freespace.y1 + containerMargin + (this.maxWidth / 2 - textBlockSize.width / 2);
				angle = 90;

				position = &quot;right&quot;;
				this.width = textBlockSize.height;
				this.height = textBlockSize.width;
			}
			else if (this.horizontalAlign === &quot;center&quot;) {
				top = container.y1 + (container.height / 2 - textBlockSize.height / 2);
				left = container.x1 + (container.width / 2 - textBlockSize.width / 2);

				position = &quot;center&quot;;
				this.width = textBlockSize.width;
				this.height = textBlockSize.height;
			}

			textBlockHorizontalAlign = &quot;center&quot;;
		}

		textBlock.x = left;
		textBlock.y = top;
		textBlock.angle = angle;
		textBlock.horizontalAlign = textBlockHorizontalAlign;
		textBlock.render(true);

		container.layoutManager.registerSpace(position, {
			width: this.width + (position === &quot;left&quot; || position === &quot;right&quot; ? this.margin + containerMargin : 0),
			height: this.height + (position === &quot;top&quot; || position === &quot;bottom&quot; ? this.margin + containerMargin : 0)
		});

		this.bounds = {
			x1: left, y1: top, x2: left + this.width, y2: top + this.height
		};

		this.ctx.textBaseline = &quot;top&quot;;
	}


	//#endregion Class Title

	//#region Class SubTitle

	function Subtitle(chart, options) {
		Subtitle.base.constructor.call(this, &quot;Subtitle&quot;, options, chart.theme);

		this.chart = chart;
		this.canvas = chart.canvas;
		this.ctx = this.chart.ctx;


		if (typeof (this._options.fontSize) === &quot;undefined&quot;) {

			this.fontSize = this.chart.getAutoFontSize(this.fontSize);

			//window.console.log(&quot;Chart Title fontSize: &quot; + this.fontSize);
		}

		this.width = null,//read only
		this.height = null//read only
		this.bounds = {
			x1: null, y1: null, x2: null, y2: null
		};
	}

	extend(Subtitle, CanvasJSObject);
	Subtitle.prototype.render = Title.prototype.render;

	//#endregion Class SubTitle

	//#region Legend

	//TBI: Implement Markes for Legend
	function Legend(chart, options, theme) {
		Legend.base.constructor.call(this, &quot;Legend&quot;, options, theme);

		this.chart = chart;
		this.canvas = chart.canvas;
		this.ctx = this.chart.ctx;
		this.ghostCtx = this.chart._eventManager.ghostCtx;
		this.items = [];

		this.width = 0,
		//this.fontSize = 12,
		this.height = 0,
		this.orientation = null,
		this.dataSeries = [];
		this.bounds = {
			x1: null, y1: null, x2: null, y2: null
		};

		if (typeof (this._options.fontSize) === &quot;undefined&quot;) {
			this.fontSize = this.chart.getAutoFontSize(this.fontSize);
			//window.console.log(&quot;fontSize: &quot; + this.fontSize);
		}

		this.lineHeight = getFontHeightInPixels(this.fontFamily, this.fontSize, this.fontWeight);

		this.horizontalSpacing = this.fontSize;
	}
	extend(Legend, CanvasJSObject);

	Legend.prototype.render = function () {

		var container = (!this.dockInsidePlotArea ? this.chart : this.chart.plotArea);
		var freeSpace = container.layoutManager.getFreeSpace();
		var position = null;
		var top = 0;
		var left = 0;
		var maxWidth = 0;
		var maxHeight = 0;
		var markerMargin = this.chart._options.legend &amp;&amp; !isNullOrUndefined(this.chart._options.legend.markerMargin) ? this.chart._options.legend.markerMargin : this.fontSize * 0.3;
		this.height = 0;

		var items = [];
		var rows = [];

		//this.ctx.font = getFontString(&quot;&quot;, this, null);
		//this.ctx.fontColor = this.fontColor;

		if (this.verticalAlign === &quot;top&quot; || this.verticalAlign === &quot;bottom&quot;) {
			this.orientation = &quot;horizontal&quot;;
			position = this.verticalAlign;

			maxWidth = this.maxWidth !== null ? this.maxWidth : freeSpace.width;
			maxHeight = this.maxHeight !== null ? this.maxHeight : freeSpace.height * .5;
		}
		else if (this.verticalAlign === &quot;center&quot;) {
			this.orientation = &quot;vertical&quot;;
			position = this.horizontalAlign;

			maxWidth = this.maxWidth !== null ? this.maxWidth : freeSpace.width * .5;
			maxHeight = this.maxHeight !== null ? this.maxHeight : freeSpace.height;
		}

		for (var i = 0; i &lt; this.dataSeries.length; i++) {
			var dataSeries = this.dataSeries[i];


			if (dataSeries.type !== &quot;pie&quot; &amp;&amp; dataSeries.type !== &quot;doughnut&quot; &amp;&amp; dataSeries.type !== &quot;funnel&quot;) {

				var markerType = dataSeries.legendMarkerType ? dataSeries.legendMarkerType : (dataSeries.type === &quot;line&quot; || dataSeries.type === &quot;stepLine&quot; || dataSeries.type === &quot;spline&quot; || dataSeries.type === &quot;scatter&quot; || dataSeries.type === &quot;bubble&quot;) &amp;&amp; dataSeries.markerType ? dataSeries.markerType : DataSeries.getDefaultLegendMarker(dataSeries.type);
				var legendText = dataSeries.legendText ? dataSeries.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart._publicChartReference, legend: this._options, dataSeries: dataSeries, dataPoint: null })
					: dataSeries.name;
				var markerColor = dataSeries.legendMarkerColor ? dataSeries.legendMarkerColor : dataSeries.markerColor ? dataSeries.markerColor : dataSeries._colorSet[0];
				var markerSize = (!dataSeries.markerSize &amp;&amp; (dataSeries.type === &quot;line&quot; || dataSeries.type === &quot;stepLine&quot; || dataSeries.type === &quot;spline&quot;)) ? 0 : this.lineHeight * .75;
				var markerBorderColor = dataSeries.legendMarkerBorderColor ? dataSeries.legendMarkerBorderColor : dataSeries.markerBorderColor;
				var markerBorderThickness = dataSeries.legendMarkerBorderThickness ? dataSeries.legendMarkerBorderThickness : dataSeries.markerBorderThickness ? Math.max(1, Math.round(markerSize * .2)) : 0;
				var lineColor = dataSeries._colorSet[0];

				legendText = this.chart.replaceKeywordsWithValue(legendText, dataSeries.dataPoints[0], dataSeries, i);
				var item = {
					markerType: markerType, markerColor: markerColor, text: legendText, textBlock: null, chartType: dataSeries.type, markerSize: markerSize, lineColor: dataSeries._colorSet[0],
					dataSeriesIndex: dataSeries.index, dataPointIndex: null, markerBorderColor: markerBorderColor, markerBorderThickness: markerBorderThickness
				};

				items.push(item);
			} else {
				for (var dataPointIndex = 0; dataPointIndex &lt; dataSeries.dataPoints.length; dataPointIndex++) {

					var dataPoint = dataSeries.dataPoints[dataPointIndex];

					var markerType = dataPoint.legendMarkerType ? dataPoint.legendMarkerType : dataSeries.legendMarkerType ? dataSeries.legendMarkerType : DataSeries.getDefaultLegendMarker(dataSeries.type);
					var legendText = dataPoint.legendText ? dataPoint.legendText : dataSeries.legendText ? dataSeries.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart._publicChartReference, legend: this._options, dataSeries: dataSeries, dataPoint: dataPoint })
						: dataPoint.name ? dataPoint.name : &quot;DataPoint: &quot; + (dataPointIndex + 1);
					var markerColor = dataPoint.legendMarkerColor ? dataPoint.legendMarkerColor : dataSeries.legendMarkerColor ? dataSeries.legendMarkerColor : dataPoint.color ? dataPoint.color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[dataPointIndex % dataSeries._colorSet.length];
					var markerSize = this.lineHeight * .75;
					var markerBorderColor = dataPoint.legendMarkerBorderColor ? dataPoint.legendMarkerBorderColor : dataSeries.legendMarkerBorderColor ? dataSeries.legendMarkerBorderColor : dataPoint.markerBorderColor ? dataPoint.markerBorderColor : dataSeries.markerBorderColor;
					var markerBorderThickness = dataPoint.legendMarkerBorderThickness ? dataPoint.legendMarkerBorderThickness : dataSeries.legendMarkerBorderThickness ? dataSeries.legendMarkerBorderThickness : dataPoint.markerBorderThickness || dataSeries.markerBorderThickness ? Math.max(1, Math.round(markerSize * .2)) : 0;

					legendText = this.chart.replaceKeywordsWithValue(legendText, dataPoint, dataSeries, dataPointIndex);

					var item = {
						markerType: markerType, markerColor: markerColor, text: legendText, textBlock: null, chartType: dataSeries.type, markerSize: markerSize,
						dataSeriesIndex: i, dataPointIndex: dataPointIndex, markerBorderColor: markerBorderColor, markerBorderThickness: markerBorderThickness
					};

					if (dataPoint.showInLegend || (dataSeries.showInLegend &amp;&amp; dataPoint.showInLegend !== false)) {
						items.push(item);
					}
				}
			}
			item = null;
		}
		if (this.reversed === true) {
			items.reverse();
		}

		// Find out the required width and height of Legend and position the items relative to the container
		if (items.length &gt; 0) {
			var row = null;
			var rowIndex = 0; // required for vertical orientation
			var textMaxWidth = 0;
			var columnHeight = 0;

			if (this.itemWidth !== null) {
				if (this.itemMaxWidth !== null) {
					textMaxWidth = Math.min(this.itemWidth, this.itemMaxWidth, maxWidth);
				} else {
					textMaxWidth = Math.min(this.itemWidth, maxWidth);
				}
			} else {
				if (this.itemMaxWidth !== null) {
					textMaxWidth = Math.min(this.itemMaxWidth, maxWidth);
				} else {
					textMaxWidth = maxWidth;
				}
			}

			markerSize = (markerSize === 0 ? this.lineHeight * .75 : markerSize);
			textMaxWidth = textMaxWidth - (markerSize + markerMargin);

			for (var i = 0; i &lt; items.length; i++) {
				var item = items[i];

				if (item.chartType === &quot;line&quot; || item.chartType === &quot;spline&quot; || item.chartType === &quot;stepLine&quot;) {
					textMaxWidth = textMaxWidth - 2 * (this.lineHeight * .1);
				}

				if (maxHeight &lt;= 0 || typeof (maxHeight) === &quot;undefined&quot; || textMaxWidth &lt;= 0 || typeof (textMaxWidth) === &quot;undefined&quot;) {
					continue;
				}

				if (this.orientation === &quot;horizontal&quot;) {

					item.textBlock = new TextBlock(this.ctx, {
						x: 0,
						y: 0,//TBI
						maxWidth: textMaxWidth,
						maxHeight: this.itemWrap ? maxHeight : this.lineHeight, //TBI: FontSize
						angle: 0,
						text: item.text,
						horizontalAlign: &quot;left&quot;,//left, center, right
						fontSize: this.fontSize,//in pixels
						fontFamily: this.fontFamily,
						fontWeight: this.fontWeight, //normal, bold, bolder, lighter,
						fontColor: this.fontColor,
						fontStyle: this.fontStyle, // normal, italic, oblique
						textBaseline: &quot;middle&quot;
					});
					item.textBlock.measureText();

					if (this.itemWidth !== null) {
						item.textBlock.width = this.itemWidth - (markerSize + markerMargin + ((item.chartType === &quot;line&quot; || item.chartType === &quot;spline&quot; || item.chartType === &quot;stepLine&quot;) ? 2 * (this.lineHeight * .1) : 0));
					}

					if (!row || row.width + Math.round(item.textBlock.width + markerSize + markerMargin + (row.width === 0 ? 0 : (this.horizontalSpacing)) + ((item.chartType === &quot;line&quot; || item.chartType === &quot;spline&quot; || item.chartType === &quot;stepLine&quot;) ? 2 * (this.lineHeight * .1) : 0)) &gt; maxWidth) {
						row = {
							items: [], width: 0
						};
						rows.push(row);
						this.height += columnHeight;
						columnHeight = 0;
					}

					columnHeight = Math.max(columnHeight, item.textBlock.height);

					item.textBlock.x = row.width;
					item.textBlock.y = 0;

					row.width += Math.round(item.textBlock.width + markerSize + markerMargin + (row.width === 0 ? 0 : this.horizontalSpacing) + ((item.chartType === &quot;line&quot; || item.chartType === &quot;spline&quot; || item.chartType === &quot;stepLine&quot;) ? 2 * (this.lineHeight * .1) : 0));
					row.items.push(item);

					this.width = Math.max(row.width, this.width);
				} else {

					item.textBlock = new TextBlock(this.ctx, {
						x: 0,
						y: 0,//TBI
						maxWidth: textMaxWidth,
						maxHeight: this.itemWrap === true ? maxHeight : this.fontSize * 1.5, //TBI: FontSize
						angle: 0,
						text: item.text,
						horizontalAlign: &quot;left&quot;,//left, center, right
						fontSize: this.fontSize,//in pixels
						fontFamily: this.fontFamily,
						fontWeight: this.fontWeight, //normal, bold, bolder, lighter,
						fontColor: this.fontColor,
						fontStyle: this.fontStyle, // normal, italic, oblique
						textBaseline: &quot;middle&quot;
					});

					item.textBlock.measureText();

					if (this.itemWidth !== null) {
						item.textBlock.width = this.itemWidth - (markerSize + markerMargin + ((item.chartType === &quot;line&quot; || item.chartType === &quot;spline&quot; || item.chartType === &quot;stepLine&quot;) ? 2 * (this.lineHeight * .1) : 0));
					}

					if (this.height &lt; maxHeight - this.lineHeight) {			
						row = {
							items: [], width: 0
						};
						rows.push(row);
					} else {
						row = rows[rowIndex];
						rowIndex = (rowIndex + 1) % rows.length;
					}

					this.height += item.textBlock.height;

					item.textBlock.x = row.width; // relative to the row                    
					item.textBlock.y = 0; // relative to the row                                   

					row.width += Math.round(item.textBlock.width + markerSize + markerMargin + (row.width === 0 ? 0 : this.horizontalSpacing) + ((item.chartType === &quot;line&quot; || item.chartType === &quot;spline&quot; || item.chartType === &quot;stepLine&quot;) ? 2 * (this.lineHeight * .1) : 0));
					row.items.push(item);

					this.width = Math.max(row.width, this.width);
				}
			}

			if (this.itemWrap === false) {
				this.height = rows.length * (this.lineHeight);
			} else {
				this.height += columnHeight;
			}

			this.height = Math.min(maxHeight, this.height);
			this.width = Math.min(maxWidth, this.width);
		}

		if (this.verticalAlign === &quot;top&quot;) {
			if (this.horizontalAlign === &quot;left&quot;)
				left = freeSpace.x1;
			else if (this.horizontalAlign === &quot;right&quot;)
				left = freeSpace.x2 - this.width;
			else
				left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;

			top = freeSpace.y1;
		} else if (this.verticalAlign === &quot;center&quot;) {
			if (this.horizontalAlign === &quot;left&quot;)
				left = freeSpace.x1;
			else if (this.horizontalAlign === &quot;right&quot;)
				left = freeSpace.x2 - this.width;
			else
				left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;

			top = freeSpace.y1 + freeSpace.height / 2 - this.height / 2;
		} else if (this.verticalAlign === &quot;bottom&quot;) {
			if (this.horizontalAlign === &quot;left&quot;)
				left = freeSpace.x1;
			else if (this.horizontalAlign === &quot;right&quot;)
				left = freeSpace.x2 - this.width;
			else
				left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;

			top = freeSpace.y2 - this.height;
		}

		this.items = items;

	    //Assign ids to all legendItems
		for (var i = 0; i &lt; this.items.length; i++) {

			var item = items[i];

			item.id = ++this.chart._eventManager.lastObjectId;
			this.chart._eventManager.objectMap[item.id] = {
				id: item.id, objectType: &quot;legendItem&quot;, legendItemIndex: i, dataSeriesIndex: item.dataSeriesIndex, dataPointIndex: item.dataPointIndex
			};
			//delete item.textBlock;// Not Required anymore
		}

		var rowHeight = 0;
		for (var i = 0; i &lt; rows.length; i++) {
			var row = rows[i];
			var columnHeight = 0;
			for (var itemIndex = 0; itemIndex &lt; row.items.length; itemIndex++) {
				var item = row.items[itemIndex];

				var itemX = item.textBlock.x + left + (itemIndex === 0 ? markerSize * .2 : this.horizontalSpacing);
				var itemY = top + rowHeight;

				var ghostX = itemX;

				if (!this.chart.data[item.dataSeriesIndex].visible)
					this.ctx.globalAlpha = .5;

				this.ctx.save();
				this.ctx.beginPath();
				this.ctx.rect(left, top, maxWidth, Math.max(maxHeight - (maxHeight % this.lineHeight), 0));
				this.ctx.clip();

				if (item.chartType === &quot;line&quot; || item.chartType === &quot;stepLine&quot; || item.chartType === &quot;spline&quot;) {
					this.ctx.strokeStyle = item.lineColor;
					this.ctx.lineWidth = Math.ceil(this.lineHeight / 8);
					this.ctx.beginPath();
					this.ctx.moveTo(itemX - this.lineHeight * .1, itemY + this.lineHeight / 2);
					this.ctx.lineTo(itemX + this.lineHeight * .85, itemY + this.lineHeight / 2);
					this.ctx.stroke();

					ghostX -= this.lineHeight * .1;
				}

				RenderHelper.drawMarker(itemX + markerSize / 2, itemY + (this.lineHeight / 2), this.ctx, item.markerType, item.markerSize, item.markerColor, item.markerBorderColor, item.markerBorderThickness);

				item.textBlock.x = itemX + markerMargin + markerSize;

				if (item.chartType === &quot;line&quot; || item.chartType === &quot;stepLine&quot; || item.chartType === &quot;spline&quot;) {
					item.textBlock.x = item.textBlock.x + this.lineHeight * .1;
				}

				item.textBlock.y = Math.round(itemY + this.lineHeight / 2);

				item.textBlock.render(true);

				this.ctx.restore();

				if (itemIndex &gt; 0) {
					columnHeight = Math.max(columnHeight, item.textBlock.height);
				} else {
					columnHeight = item.textBlock.height;
				}

				if (!this.chart.data[item.dataSeriesIndex].visible)
					this.ctx.globalAlpha = 1;

				var hexColor = intToHexColorString(item.id);
				this.ghostCtx.fillStyle = hexColor;
				this.ghostCtx.beginPath();
				this.ghostCtx.fillRect(ghostX, item.textBlock.y - this.lineHeight / 2, item.textBlock.x + item.textBlock.width - ghostX, item.textBlock.height);

				item.x1 = this.chart._eventManager.objectMap[item.id].x1 = ghostX;
				item.y1 = this.chart._eventManager.objectMap[item.id].y1 = item.textBlock.y - this.lineHeight / 2;
				item.x2 = this.chart._eventManager.objectMap[item.id].x2 = item.textBlock.x + item.textBlock.width;
				item.y2 = this.chart._eventManager.objectMap[item.id].y2 = item.textBlock.y + item.textBlock.height - this.lineHeight / 2;
			}
			rowHeight = rowHeight + columnHeight;
		}

		//this.ctx.beginPath();
		//this.ctx.lineWidth = 2;
		//this.ctx.strokeStyle = &quot;red&quot;;
		//this.ctx.rect(left, top, this.width, this.height);
		//this.ctx.stroke();

		if (items.length &gt; 0)
			container.layoutManager.registerSpace(position, { width: this.width + 2 + 2, height: this.height + 5 + 5 });

		this.bounds = {
			x1: left, y1: top, x2: left + this.width, y2: top + this.height
		};
	}

	//#endregion Legend

	//#region Class PlotArea
	function PlotArea(chart, options) {
		PlotArea.base.constructor.call(this, options);

		this.chart = chart;
		this.canvas = chart.canvas;
		this.ctx = this.chart.ctx;
	}
	extend(PlotArea, CanvasJSObject);

	PlotArea.prototype.render = function () {
		var freeSpace = this.chart.layoutManager.getFreeSpace();
		this.ctx.fillStyle = &quot;red&quot;;
		this.ctx.fillRect(freeSpace.x1, freeSpace.y1, freeSpace.x2, freeSpace.y2);

	}
	//#endregion Class PlotArea

	//#region DataSeries

	function DataSeries(chart, options, theme, index, id) {
		DataSeries.base.constructor.call(this, &quot;DataSeries&quot;, options, theme);

		this.chart = chart;
		this.canvas = chart.canvas;
		this._ctx = chart.canvas.ctx;
		this.index = index;
		this.noDataPointsInPlotArea = 0;
		//this.maxWidthInX = 0;
		this.id = id;
		this.chart._eventManager.objectMap[id] = {
			id: id, objectType: &quot;dataSeries&quot;, dataSeriesIndex: index
		}
		this.dataPointIds = [];
		this.plotUnit = [];

		this.axisX = null;
		this.axisY = null;

		if (this.fillOpacity === null) {
			if (this.type.match(/area/i))
				this.fillOpacity = .7;
			else
				this.fillOpacity = 1;
		}


		this.axisPlacement = this.getDefaultAxisPlacement();

		if (typeof (this._options.indexLabelFontSize) === &quot;undefined&quot;) {

			this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize);
		}
	}
	extend(DataSeries, CanvasJSObject);

	//Static Method that returns the axisPlacement for a given ChartType. Returns one of &quot;normal&quot;, &quot;xySwapped&quot;, &quot;none&quot;
	DataSeries.prototype.getDefaultAxisPlacement = function () {

		//if (!this.visible)
		//	return &quot;none&quot;;

		//type = this.type.toLowerCase();
		var type = this.type;

		if (type === &quot;column&quot; || type === &quot;line&quot; || type === &quot;stepLine&quot; || type === &quot;spline&quot; || type === &quot;area&quot; || type === &quot;stepArea&quot; || type === &quot;splineArea&quot; || type === &quot;stackedColumn&quot; || type === &quot;stackedLine&quot; || type === &quot;bubble&quot; || type === &quot;scatter&quot;
			|| type === &quot;stackedArea&quot; || type === &quot;stackedColumn100&quot; || type === &quot;stackedLine100&quot; || type === &quot;stackedArea100&quot;
			|| type === &quot;candlestick&quot; || type === &quot;ohlc&quot; || type === &quot;rangeColumn&quot; || type === &quot;rangeArea&quot; || type === &quot;rangeSplineArea&quot;) {
			return &quot;normal&quot;;
		}
		else if (type === &quot;bar&quot; || type === &quot;stackedBar&quot; || type === &quot;stackedBar100&quot; || type === &quot;rangeBar&quot;) {

			return &quot;xySwapped&quot;;
		}
		else if (type === &quot;pie&quot; || type === &quot;doughnut&quot; || type === &quot;funnel&quot;) {
			return &quot;none&quot;;
		} else {
			window.console.log(&quot;Unknown Chart Type: &quot; + type);
			return null;
		}
	}

	DataSeries.getDefaultLegendMarker = function (type) {

		//type = type.toLowerCase();

		if (type === &quot;column&quot; || type === &quot;stackedColumn&quot; || type === &quot;stackedLine&quot; || type === &quot;bar&quot; || type === &quot;stackedBar&quot; || type === &quot;stackedBar100&quot;
			|| type === &quot;bubble&quot; || type === &quot;scatter&quot;
			|| type === &quot;stackedColumn100&quot; || type === &quot;stackedLine100&quot; || type === &quot;stepArea&quot;
			|| type === &quot;candlestick&quot; || type === &quot;ohlc&quot; || type === &quot;rangeColumn&quot; || type === &quot;rangeBar&quot; || type === &quot;rangeArea&quot; || type === &quot;rangeSplineArea&quot;) {
			return &quot;square&quot;;
		}
		else if (type === &quot;line&quot; || type === &quot;stepLine&quot; || type === &quot;spline&quot; || type === &quot;pie&quot; || type === &quot;doughnut&quot; || type === &quot;funnel&quot;) {
			return &quot;circle&quot;;
		} else if (type === &quot;area&quot; || type === &quot;splineArea&quot; || type === &quot;stackedArea&quot; || type === &quot;stackedArea100&quot;) {
			return &quot;triangle&quot;
		} else {
			window.console.log(&quot;Unknown Chart Type: &quot; + type);
			return null;
		}
	}

	//Finds dataPoint with the given x value. If findClosest is set, finds dataPoint with closest x value. 
	//Returns searchResult object if found, else returns null
	DataSeries.prototype.getDataPointAtX = function (x, findClosest) {

		if (!this.dataPoints || this.dataPoints.length === 0) return null;

		var searchResult = {
			dataPoint: null, distance: Infinity, index: NaN
		};
		var dataPoint = null;

		var j = 0;
		var i = 0;
		var direction = 1; // +1 for foward and -1 for backward.

		var minimumXDistance = Infinity;
		var forwardMissCount = 0, backwardMissCount = 0;
		var maxMissCount = 1000;
		var searchStartIndex = 0;

		if (this.chart.plotInfo.axisPlacement !== &quot;none&quot;) {

			//var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);

			//if (xRange &gt; 0)
			//	searchStartIndex = ((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) &gt;&gt; 0;
			//else
			//	searchStartIndex = 0;

			var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);

			if (xRange &gt; 0)
				searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) &gt;&gt; 0, 0), this.dataPoints.length);
			else
				searchStartIndex = 0;

			//searchStartIndex = ((this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) / this.dataPoints.length * (x - this.dataPoints[0].x)) &gt;&gt; 0;
		}

		while (true) {

			i = (direction &gt; 0) ? searchStartIndex + j : searchStartIndex - j;

			if (i &gt;= 0 &amp;&amp; i &lt; this.dataPoints.length) {

				dataPoint = this.dataPoints[i];

				var distance = Math.abs(dataPoint.x - x);

				if (distance &lt; searchResult.distance) {
					searchResult.dataPoint = dataPoint;
					searchResult.distance = distance;
					searchResult.index = i;
				}

				var xDistance = Math.abs(dataPoint.x - x);
				if (xDistance &lt;= minimumXDistance)
					minimumXDistance = xDistance;
				else {
					if (direction &gt; 0)
						forwardMissCount++;
					else
						backwardMissCount++;
				}

				if (forwardMissCount &gt; maxMissCount &amp;&amp; backwardMissCount &gt; maxMissCount)
					break;


			} else if (searchStartIndex - j &lt; 0 &amp;&amp; searchStartIndex + j &gt;= this.dataPoints.length)
				break;

			if (direction === -1) {
				j++;
				direction = 1;
			} else
				direction = -1;
		}


		if (!findClosest &amp;&amp; searchResult.dataPoint.x === x)
			return searchResult;
		else if (findClosest &amp;&amp; searchResult.dataPoint !== null)
			return searchResult;
		else
			return null;
	}

	// x &amp; y should be in pixels. Can be used only after rendering the chart.
	DataSeries.prototype.getDataPointAtXY = function (x, y, getClosest) {

		if (!this.dataPoints || this.dataPoints.length === 0 || x &lt; this.chart.plotArea.x1 || x &gt; this.chart.plotArea.x2 || y &lt; this.chart.plotArea.y1 || y &gt; this.chart.plotArea.y2) return null;

		getClosest = getClosest || false;
		var results = [];
		var j = 0, i = 0;
		var direction = 1; // +1 for foward and -1 for backward.
		var foundDataPoint = false;
		var minimumXDistance = Infinity;
		var forwardMissCount = 0, backwardMissCount = 0;
		var maxMissCount = 1000;
		var searchStartIndex = 0;

		if (this.chart.plotInfo.axisPlacement !== &quot;none&quot;) {
			var xval = this.chart.axisX.getXValueAt({ x: x, y: y });

			var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);

			if (xRange &gt; 0)
				searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.dataPoints[0].x)) &gt;&gt; 0, 0), this.dataPoints.length);
			else
				searchStartIndex = 0;

			//var xRange = (this.axisX._absoluteMaximum - this.axisX._absoluteMinimum);

			//if (xRange &gt; 0)
			//	searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.axisX._absoluteMinimum)) &gt;&gt; 0, 0), this.dataPoints.length);
			//else
			//	searchStartIndex = 0;
		}

		while (true) {

			//i = searchStartIndex + (j * direction);
			i = (direction &gt; 0) ? searchStartIndex + j : searchStartIndex - j;

			if (i &gt;= 0 &amp;&amp; i &lt; this.dataPoints.length) {

				var id = this.dataPointIds[i];
				var visualInfo = this.chart._eventManager.objectMap[id];
				var dataPoint = this.dataPoints[i];
				var distance = null;

				if (visualInfo) {

					switch (this.type) {

						case &quot;column&quot;:
						case &quot;stackedColumn&quot;:
						case &quot;stackedColumn100&quot;:
						case &quot;bar&quot;:
						case &quot;stackedBar&quot;:
						case &quot;stackedBar100&quot;:
						case &quot;rangeColumn&quot;:
						case &quot;rangeBar&quot;:

							if (x &gt;= visualInfo.x1 &amp;&amp; x &lt;= visualInfo.x2 &amp;&amp; y &gt;= visualInfo.y1 &amp;&amp; y &lt;= visualInfo.y2) {
								results.push({
									dataPoint: dataPoint,
									dataPointIndex: i,
									dataSeries: this,
									distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y1 - y), Math.abs(visualInfo.y2 - y))
									//distance:0
								});

								foundDataPoint = true;
							}
							break;

						case &quot;line&quot;:
						case &quot;stepLine&quot;:
						case &quot;spline&quot;:
						case &quot;area&quot;:
						case &quot;stepArea&quot;:
						case &quot;stackedArea&quot;:
						case &quot;stackedArea100&quot;:
						case &quot;splineArea&quot;:
						case &quot;scatter&quot;:
							var markerSize = getProperty(&quot;markerSize&quot;, dataPoint, this) || 4;
							var snapDistance = getClosest ? 20 : markerSize;

							distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));
							if (distance &lt;= snapDistance) {
								results.push({
									dataPoint: dataPoint,
									dataPointIndex: i,
									dataSeries: this,
									distance: distance
								});
							}

							var xDistance = Math.abs(visualInfo.x1 - x);
							if (xDistance &lt;= minimumXDistance)
								minimumXDistance = xDistance;
							else {
								if (direction &gt; 0)
									forwardMissCount++;
								else
									backwardMissCount++;
							}

							if (distance &lt;= markerSize / 2) {
								foundDataPoint = true;
							}

							break;

						case &quot;rangeArea&quot;:
						case &quot;rangeSplineArea&quot;:

							var markerSize = getProperty(&quot;markerSize&quot;, dataPoint, this) || 4;
							var snapDistance = getClosest ? 20 : markerSize;

							distance = Math.min(Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2)), Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y2 - y, 2)));
							if (distance &lt;= snapDistance) {
								results.push({
									dataPoint: dataPoint,
									dataPointIndex: i,
									dataSeries: this,
									distance: distance
								});
							}

							var xDistance = Math.abs(visualInfo.x1 - x);
							if (xDistance &lt;= minimumXDistance)
								minimumXDistance = xDistance;
							else {
								if (direction &gt; 0)
									forwardMissCount++;
								else
									backwardMissCount++;
							}

							if (distance &lt;= markerSize / 2) {
								foundDataPoint = true;
							}

							break;

						case &quot;bubble&quot;:
							var markerSize = visualInfo.size;
							distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));
							if (distance &lt;= markerSize / 2) {
								results.push({
									dataPoint: dataPoint,
									dataPointIndex: i,
									dataSeries: this,
									distance: distance
								});

								foundDataPoint = true;
							}
							break;

						case &quot;pie&quot;:
						case &quot;doughnut&quot;:
							var center = visualInfo.center;
							var innerRadius = this.type === &quot;doughnut&quot; ? visualInfo.percentInnerRadius * visualInfo.radius : 0;

							distance = Math.sqrt(Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2));
							if (distance &lt; visualInfo.radius &amp;&amp; distance &gt; innerRadius) {

								var deltaY = y - center.y;
								var deltaX = x - center.x;
								var angle = Math.atan2(deltaY, deltaX);

								if (angle &lt; 0)
									angle += Math.PI * 2;

								angle = Number((((angle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));
								//console.log(angle);


								var startAngle = Number((((visualInfo.startAngle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));
								var endAngle = Number((((visualInfo.endAngle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));

								//So that data point is detected when there is only one dataPoint
								if (endAngle === 0 &amp;&amp; visualInfo.endAngle &gt; 1) {
									endAngle = 360;
								}

								if (startAngle &gt;= endAngle &amp;&amp; dataPoint.y !== 0) {
									endAngle += 360;

									if (angle &lt; startAngle)
										angle += 360;
								}


								if (angle &gt; startAngle &amp;&amp; angle &lt; endAngle) {
									results.push({
										dataPoint: dataPoint,
										dataPointIndex: i,
										dataSeries: this,
										distance: 0
									});

									foundDataPoint = true;
								}

							}

							break;

						case &quot;candlestick&quot;:
							if (((x &gt;= (visualInfo.x1 - visualInfo.borderThickness / 2)) &amp;&amp; (x &lt;= (visualInfo.x2 + visualInfo.borderThickness / 2))
								&amp;&amp; (y &gt;= visualInfo.y2 - visualInfo.borderThickness / 2) &amp;&amp; (y &lt;= visualInfo.y3 + visualInfo.borderThickness / 2))
								|| (Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) &lt; visualInfo.borderThickness &amp;&amp; (y &gt;= visualInfo.y1 &amp;&amp; y &lt;= visualInfo.y4))) {
								results.push({
									dataPoint: dataPoint,
									dataPointIndex: i,
									dataSeries: this,
									distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y))
									//distance:0
								});

								foundDataPoint = true;
							}
							break;

						case &quot;ohlc&quot;:

							if ((Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) &lt; visualInfo.borderThickness &amp;&amp; (y &gt;= visualInfo.y2 &amp;&amp; y &lt;= visualInfo.y3))

								|| (x &gt;= visualInfo.x1 &amp;&amp; (x &lt;= (visualInfo.x2 + visualInfo.x1) / 2)
									&amp;&amp; (y &gt;= visualInfo.y1 - visualInfo.borderThickness / 2) &amp;&amp; (y &lt;= visualInfo.y1 + visualInfo.borderThickness / 2))

								|| ((x &gt;= (visualInfo.x1 + visualInfo.x2) / 2) &amp;&amp; (x &lt;= visualInfo.x2)
									&amp;&amp; (y &gt;= visualInfo.y4 - visualInfo.borderThickness / 2) &amp;&amp; (y &lt;= visualInfo.y4 + visualInfo.borderThickness / 2))) {

								results.push({
									dataPoint: dataPoint,
									dataPointIndex: i,
									dataSeries: this,
									distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y))
									//distance:0
								});

								foundDataPoint = true;
							}
							break;

					}

					if (foundDataPoint || (forwardMissCount &gt; maxMissCount &amp;&amp; backwardMissCount &gt; maxMissCount))
						break;
				}

			} else if (searchStartIndex - j &lt; 0 &amp;&amp; searchStartIndex + j &gt;= this.dataPoints.length)
				break;

			if (direction === -1) {
				j++;
				direction = 1;
			} else
				direction = -1;

		}



		var closestResult = null;

		for (var m = 0; m &lt; results.length; m++) {
			if (!closestResult) {
				closestResult = results[m];
			} else if (results[m].distance &lt;= closestResult.distance) {
				closestResult = results[m];
			}
		}

		//if (window.console)
		//	window.console.log(&quot;forwardMissCount: &quot; + forwardMissCount + &quot;; backwardMissCount: &quot; + backwardMissCount + &quot;; getClosest: &quot; + getClosest);

		//if (window.console &amp;&amp; closestResult)
		//    window.console.log(j + &quot;: distance = &quot; + closestResult.distance);

		return closestResult;
	}

	DataSeries.prototype.getMarkerProperties = function (index, x, y, ctx) {
		var dataPoints = this.dataPoints;
		var dataSeries = this;

		var markerColor = dataPoints[index].markerColor ? dataPoints[index].markerColor : dataSeries.markerColor ? dataSeries.markerColor : dataPoints[index].color ? dataPoints[index].color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[index % dataSeries._colorSet.length];
		var markerBorderColor = dataPoints[index].markerBorderColor ? dataPoints[index].markerBorderColor : dataSeries.markerBorderColor ? dataSeries.markerBorderColor : null;
		var markerBorderThickness = dataPoints[index].markerBorderThickness ? dataPoints[index].markerBorderThickness : dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : null;
		var markerType = dataPoints[index].markerType ? dataPoints[index].markerType : dataSeries.markerType;
		var markerSize = dataPoints[index].markerSize ? dataPoints[index].markerSize : dataSeries.markerSize;


		return {
			x: x, y: y, ctx: ctx,
			type: markerType,
			size: markerSize,
			color: markerColor,
			borderColor: markerBorderColor,
			borderThickness: markerBorderThickness
		}
	}
	//#endregion DataSeries

	//#region Axis

	function Axis(chart, options, type, position) {
		Axis.base.constructor.call(this, &quot;Axis&quot;, options, chart.theme);

		this.chart = chart;
		this.canvas = chart.canvas;
		this.ctx = chart.ctx;
		this.maxWidth = 0;
		this.maxHeight = 0;
		this.intervalStartPosition = 0;
		this.labels = [];
		this._labels = null;
		this._stripLineLabels = null;

		//Processed information about the data that gets plotted against this axis
		this.dataInfo = {
			min: Infinity,
			max: -Infinity,
			viewPortMin: Infinity,
			viewPortMax: -Infinity,
			minDiff: Infinity // Used only in case of axisX
		};

		if (type === &quot;axisX&quot;) {
			this.sessionVariables = this.chart.sessionVariables[type];

			if (!this._options.interval)
				this.intervalType = null;

			//Temporary Fix for axisX Line in theme2: In theme2 we need lineThickness of 0 only for Y axis.
			if (this.chart.theme === &quot;theme2&quot; &amp;&amp; isNullOrUndefined(this._options.lineThickness)) {
				this.lineThickness = 2;
			}
		} else {
			if (position === &quot;left&quot; || position === &quot;top&quot;)
				this.sessionVariables = this.chart.sessionVariables[&quot;axisY&quot;];
			else {
				this.sessionVariables = this.chart.sessionVariables[&quot;axisY2&quot;];
			}
		}



		if (typeof (this._options.titleFontSize) === &quot;undefined&quot;) {

			this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize);

			//window.console.log(&quot;titleFontSize: &quot; + this.titleFontSize);
		}

		if (typeof (this._options.labelFontSize) === &quot;undefined&quot;) {

			this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize);

			//window.console.log(&quot;labelFontSize: &quot; + this.labelFontSize);

		}

		//Axis Type : axisX, axisY
		this.type = type;
		if (type === &quot;axisX&quot; &amp;&amp; (!options || typeof (options.gridThickness) === &quot;undefined&quot;))
			this.gridThickness = 0;

		this._position = position;

		this.lineCoordinates = {
			x1: null, y1: null, x2: null, y2: null, width: null
		};//{x1:, y1:, x2:, y2:, width:}
		//
		{
			this.labelAngle = ((this.labelAngle % 360) + 360) % 360;

			if (this.labelAngle &gt; 90 &amp;&amp; this.labelAngle &lt;= 270)
				this.labelAngle -= 180;
			else if (this.labelAngle &gt; 270 &amp;&amp; this.labelAngle &lt;= 360)
				this.labelAngle -= 360
		}

		if (this._options.stripLines &amp;&amp; this._options.stripLines.length &gt; 0) {

			this.stripLines = [];

			for (var i = 0; i &lt; this._options.stripLines.length; i++) {
				this.stripLines.push(new StripLine(this.chart, this._options.stripLines[i], chart.theme, ++this.chart._eventManager.lastObjectId, this));
			}
		}

		this._titleTextBlock = null;

		if (this.hasOptionChanged(&quot;viewportMinimum&quot;) &amp;&amp; this.viewportMinimum === null) {
			this._options.viewportMinimum = undefined;
			this.sessionVariables.viewportMinimum = null;
		}

		if (!this.hasOptionChanged(&quot;viewportMinimum&quot;) &amp;&amp; !isNaN(this.sessionVariables.newViewportMinimum) &amp;&amp; this.sessionVariables.newViewportMinimum !== null)
			this.viewportMinimum = this.sessionVariables.newViewportMinimum;
		else
			this.sessionVariables.newViewportMinimum = null;


		if (this.hasOptionChanged(&quot;viewportMaximum&quot;) &amp;&amp; this.viewportMaximum === null) {
			this._options.viewportMaximum = undefined;
			this.sessionVariables.viewportMaximum = null;
		}

		if (!this.hasOptionChanged(&quot;viewportMaximum&quot;) &amp;&amp; !isNaN(this.sessionVariables.newViewportMaximum) &amp;&amp; this.sessionVariables.newViewportMaximum !== null)
			this.viewportMaximum = this.sessionVariables.newViewportMaximum;
		else
			this.sessionVariables.newViewportMaximum = null;

		if (this.minimum !== null &amp;&amp; this.viewportMinimum !== null)
			this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);

		if (this.maximum !== null &amp;&amp; this.viewportMaximum !== null)
			this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);

		this.trackChanges(&quot;viewportMinimum&quot;);
		this.trackChanges(&quot;viewportMaximum&quot;);
	}

	extend(Axis, CanvasJSObject);

	Axis.prototype.createLabels = function () {
		var textBlock, textBlockNext;
		var sizeNext;
		var i = 0;
		var k = 0;
		var endPoint;

		var labelMaxWidth = 0;
		var labelEffectiveMaxWidth = 0;
		var labelMaxHeight = 0;
		var labelEffectiveMaxHeight = 0;
		var intervalInPixels = 0;

		//var intervalInPixels = this.conversionParameters.pixelPerUnit * this.interval;


		if (this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) {
			intervalInPixels = this.lineCoordinates.width / Math.abs(this.viewportMaximum - this.viewportMinimum) * convertToNumber(this.interval, this.intervalType);

			labelMaxWidth = typeof (this._options.labelMaxWidth) === &quot;undefined&quot; ? this.chart.width * .5 &gt;&gt; 0 : this._options.labelMaxWidth;

			if (!(this.chart.panEnabled))
				labelMaxHeight = typeof (this._options.labelWrap) === &quot;undefined&quot; || this.labelWrap ? this.chart.height * .8 &gt;&gt; 0 : this.labelFontSize * 1.5;
		}
		else if (this._position === &quot;left&quot; || this._position === &quot;right&quot;) {

			intervalInPixels = this.lineCoordinates.height / Math.abs(this.viewportMaximum - this.viewportMinimum) * convertToNumber(this.interval, this.intervalType);

			if (!(this.chart.panEnabled))
				labelMaxWidth = typeof (this._options.labelMaxWidth) === &quot;undefined&quot; ? this.chart.width * .3 &gt;&gt; 0 : this._options.labelMaxWidth;

			labelMaxHeight = typeof (this._options.labelWrap) === &quot;undefined&quot; || this.labelWrap ? this.chart.height * .3 &gt;&gt; 0 : this.labelFontSize * 1.5;
		}
		if (this.type === &quot;axisX&quot; &amp;&amp; this.chart.plotInfo.axisXValueType === &quot;dateTime&quot;) {
			this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval);
			endPoint = addToDateTime(new Date(this.viewportMaximum), this.interval, this.intervalType)

			for (i = this.intervalStartPosition; i &lt; endPoint; addToDateTime(i, this.interval, this.intervalType)) {

				//var text = dateFormat(i, this.valueFormatString);
				var timeInMilliseconds = i.getTime();
				var text = this.labelFormatter ? this.labelFormatter({ chart: this.chart._publicChartReference, axis: this._options, value: i, label: this.labels[i] ? this.labels[i] : null })
					: this.type === &quot;axisX&quot; &amp;&amp; this.labels[timeInMilliseconds] ? this.labels[timeInMilliseconds] : dateFormat(i, this.valueFormatString, this.chart._cultureInfo);

				textBlock = new TextBlock(this.ctx, {
					x: 0,
					y: 0,
					//maxWidth: this.maxHeight,
					//maxHeight: this.labelFontSize,
					maxWidth: labelMaxWidth,
					maxHeight: labelMaxHeight,
					angle: this.labelAngle,
					text: this.prefix + text + this.suffix,
					horizontalAlign: &quot;left&quot;,//left, center, right
					fontSize: this.labelFontSize,//in pixels
					fontFamily: this.labelFontFamily,
					fontWeight: this.labelFontWeight, //normal, bold, bolder, lighter,
					fontColor: this.labelFontColor,
					fontStyle: this.labelFontStyle, // normal, italic, oblique
					textBaseline: &quot;middle&quot;
				});

				this._labels.push({ position: i.getTime(), textBlock: textBlock, effectiveHeight: null });
			}

		}
		else {
			endPoint = this.viewportMaximum;

			//Check if it should be rendered as a category axis. If yes, then ceil the interval
			if (this.labels &amp;&amp; this.labels.length) {
				var tempInterval = Math.ceil(this.interval);
				var tempStartPoint = Math.ceil(this.intervalStartPosition);
				var hasAllLabels = false;
				for (i = tempStartPoint; i &lt; this.viewportMaximum; i += tempInterval) {
					if (this.labels[i]) {
						hasAllLabels = true;
					} else {
						hasAllLabels = false;
						break;
					}
				}

				if (hasAllLabels) {
					this.interval = tempInterval;
					this.intervalStartPosition = tempStartPoint;
				}
			}

			//parseFloat &amp; toPrecision are being used to avoid issues related to precision.
			for (i = this.intervalStartPosition; i &lt;= endPoint; i = parseFloat((i + this.interval).toFixed(14))) {
				var text = this.labelFormatter ? this.labelFormatter({ chart: this.chart._publicChartReference, axis: this._options, value: i, label: this.labels[i] ? this.labels[i] : null })
					: this.type === &quot;axisX&quot; &amp;&amp; this.labels[i] ? this.labels[i] : numberFormat(i, this.valueFormatString, this.chart._cultureInfo);

				textBlock = new TextBlock(this.ctx, {
					x: 0,
					y: 0,
					//maxWidth: this.maxHeight,
					//maxHeight: this.labelFontSize,
					maxWidth: labelMaxWidth,
					maxHeight: labelMaxHeight,
					angle: this.labelAngle,
					text: this.prefix + text + this.suffix,
					horizontalAlign: &quot;left&quot;,//left, center, right
					fontSize: this.labelFontSize,//in pixels
					fontFamily: this.labelFontFamily,
					fontWeight: this.labelFontWeight, //normal, bold, bolder, lighter,
					fontColor: this.labelFontColor,
					fontStyle: this.labelFontStyle, // normal, italic, oblique
					textBaseline: &quot;middle&quot;,
					borderThickness: 0
				});

				this._labels.push({ position: i, textBlock: textBlock, effectiveHeight: null });
			}
		}
		var effectiveLabelHeights = [];
		var effectiveLabelWidths = [];

		if (this.labelAutoFit || this._options.labelAutoFit) {
			if (this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) {
				var j = 0;
				labelMaxWidth = intervalInPixels * .9 &gt;&gt; 0;
				if (!isNullOrUndefined(this.labelAngle)) {
					this.labelAngle = ((this.labelAngle % 360) + 360) % 360;

					if (this.labelAngle &gt; 90 &amp;&amp; this.labelAngle &lt;= 270)
						this.labelAngle -= 180;
					else if (this.labelAngle &gt; 270 &amp;&amp; this.labelAngle &lt;= 360)
						this.labelAngle -= 360
				}


				if (!(this.chart.panEnabled) &amp;&amp; this._labels.length &gt;= 1) {
					this.sessionVariables.labelFontSize = this.labelFontSize;
					this.sessionVariables.labelMaxWidth = labelMaxWidth;
					this.sessionVariables.labelMaxHeight = labelMaxHeight;
					this.sessionVariables.labelAngle = this.labelAngle;
					this.sessionVariables.labelWrap = true;

					for (i = 0; i &lt; this._labels.length; i++) {
						textBlock = this._labels[i].textBlock;
						var size = textBlock.measureText();

						if (i &lt; this._labels.length - 1) {
							j = (i + 1);
							textBlockNext = this._labels[j].textBlock;
							sizeNext = textBlockNext.measureText();
						}
						effectiveLabelHeights.push(textBlock.height);
						this.sessionVariables.labelMaxHeight = Math.max.apply(Math, effectiveLabelHeights);

						labelEffectiveMaxWidth = (labelMaxWidth * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) + ((labelMaxHeight - textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)));
						labelEffectiveMaxHeight = (labelMaxWidth * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) + ((labelMaxHeight - textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)));
						if (!(isNullOrUndefined(this._options.labelAngle) &amp;&amp; isNaN(this._options.labelAngle)) || this._options.labelAngle === 0) {//User has set angle --&gt;Rotate
							this.sessionVariables.labelAngle = this.labelAngle;
							this.sessionVariables.labelMaxHeight = (this.labelAngle === 0) ? labelMaxHeight : Math.min((labelEffectiveMaxHeight - labelMaxWidth * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / (Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))), labelEffectiveMaxHeight);
							if (!isNullOrUndefined(this._options.labelWrap)) {//User has set wrapping (true/false)
								if (this._options.labelWrap) {//wrap is true --&gt;Rotate+Wrap
									this.sessionVariables.labelWrap = this.labelWrap;
									this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.height * .8 &gt;&gt; 0 ? this.chart.height * .8 &gt;&gt; 0 : this._options.labelMaxWidth : labelMaxWidth;
									this.sessionVariables.labelMaxHeight = labelMaxHeight;
								}
								else {//wrap is false
									if (!isNullOrUndefined(this._options.labelMaxWidth)) {//User has set labelMaxWidth --&gt;Rotate+Clip after user set labelMaxWidth
										this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.height * .8 &gt;&gt; 0 ? this.chart.height * .8 &gt;&gt; 0 : this._options.labelMaxWidth : labelEffectiveMaxWidth;
										this.sessionVariables.labelWrap = this.labelWrap;
										this.sessionVariables.labelMaxHeight = labelMaxHeight;
									}
									else {//User has not set labelMaxWidth --&gt;Rotate
										this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.height * .8 &gt;&gt; 0 ? this.chart.height * .8 &gt;&gt; 0 : this._options.labelMaxWidth : labelEffectiveMaxWidth;
										this.sessionVariables.labelWrap = this.labelWrap;
										this.sessionVariables.labelMaxHeight = labelMaxHeight;
									}
								}
							}
							else if (isNullOrUndefined(this._options.labelWrap)) {//User has not set wrap
								if (this.labelWrap &amp;&amp; !isNullOrUndefined(this._options.labelMaxWidth)) {//labelwrap-&gt;true by default --&gt;Rotate+Wrap
									this.sessionVariables.labelWrap = this.labelWrap;
									this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.height * .8 &gt;&gt; 0 ? this.chart.height * .8 &gt;&gt; 0 : this._options.labelMaxWidth : labelMaxWidth;
									this.sessionVariables.labelMaxHeight = labelMaxHeight;
								}
								else {
									this.sessionVariables.labelMaxWidth = labelEffectiveMaxWidth &gt; this.chart.height * .5 ? this.chart.height * .5 : labelEffectiveMaxWidth;
									this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight &lt; intervalInPixels * .9 ? intervalInPixels * .9 : labelEffectiveMaxHeight &lt; this.labelFontSize ? this.labelFontSize * 2.5 : labelEffectiveMaxHeight - this.labelFontSize;
									this.sessionVariables.labelWrap = this.labelWrap;
									if (isNullOrUndefined(this._options.labelMaxWidth)) {
										this.sessionVariables.labelAngle = this.labelAngle;
									}
								}
							}
						}//if-angle is not set proceed to else part
						else {
							this.sessionVariables.labelMaxHeight = this.labelAngle === 0 ? labelMaxHeight : Math.min((labelEffectiveMaxHeight - labelMaxWidth * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / (Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))), labelEffectiveMaxHeight);
							if (!isNullOrUndefined(this._options.labelWrap)) {//User has set Wrap (true/false)
								if (this._options.labelWrap) {//wrap is true --&gt;Wrap
									this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : labelMaxWidth;
									this.sessionVariables.labelAngle = this._options.labelMaxWidth &gt; labelMaxWidth ? -25 : this.sessionVariables.labelAngle;
									this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight;
								}
								else {//wrap is false
									if (!isNullOrUndefined(this._options.labelMaxWidth)) {//User has set labelMaxWidth --&gt;Clip after user set labelMaxWidth
										this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : labelMaxWidth;
										this.sessionVariables.labelAngle = this._options.labelMaxWidth &gt; labelMaxWidth ? -25 : this.sessionVariables.labelAngle;
										this.sessionVariables.labelMaxHeight = labelMaxHeight;
										this.sessionVariables.labelWrap = this.labelWrap;
									}
									else {//User has not set labelMaxWidth --&gt; Rotate+Clip
										this.sessionVariables.labelMaxWidth = labelMaxWidth;
										this.sessionVariables.labelWrap = this.labelWrap;
										this.sessionVariables.labelMaxHeight = labelMaxHeight;
									}
								}
							}
							else if (isNullOrUndefined(this._options.labelWrap)) {//User has not set Wrap, labelWrap is true by default
								if (!isNullOrUndefined(this._options.labelMaxWidth)) {//User has set labelMaxWidth --&gt;Wrap if user set labelMaxWidth&lt;labelMaxWidth else Rotate+Wrap
									if (this._options.labelMaxWidth &lt; labelMaxWidth) {
										this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth;
										this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight;
									}
									else {
										this.sessionVariables.labelAngle = -25;
										this.sessionVariables.labelMaxWidth = !isNullOrUndefined(this._options.labelMaxWidth) ? this._options.labelMaxWidth &gt; this.chart.width * .3 &gt;&gt; 0 ? this.chart.width * .3 &gt;&gt; 0 : this._options.labelMaxWidth : labelMaxWidth;
										this.sessionVariables.labelMaxHeight = this.labelFontSize * 2.5;
									}
								}

								else {//User has not set anything, handle auto-labelling (Rotate or Wrap or Decrease font size for the bestfit)
									//Decide Auto-Labelling based on overlapping
									if (!isNullOrUndefined(sizeNext)) {
										if (((size.width + sizeNext.width) &gt;&gt; 0) &gt;= (2 * labelMaxWidth) &amp;&amp; ((size.width + sizeNext.width) &gt;&gt; 0) &lt; (2.4 * labelMaxWidth)) {//Reduce Font size
											var labelFontSize = this.labelFontSize;
											this.sessionVariables.labelMaxWidth = labelMaxWidth * 1.2;
											if (isNullOrUndefined(this._options.labelFontSize)) {
												if (labelFontSize &gt; 12) {
													labelFontSize = Math.floor(12 / 13 * labelFontSize);
													size = textBlock.measureText();
												}
											}
											this.sessionVariables.labelFontSize = isNullOrUndefined(this._options.labelFontSize) ? labelFontSize : this._options.labelFontSize;
											this.sessionVariables.labelAngle = this.labelAngle;
										}
										else if (((size.width + sizeNext.width) &gt;&gt; 0) &gt;= (2.4 * labelMaxWidth) &amp;&amp; (size.width + sizeNext.width) &lt; (2.8 * labelMaxWidth)) {//Slant
											this.sessionVariables.labelAngle = -25;
											this.sessionVariables.labelMaxWidth = labelMaxWidth * 2.5;
											this.sessionVariables.labelFontSize = this.labelFontSize;
										}
										else if (((size.width + sizeNext.width) &gt;&gt; 0) &gt;= (2.8 * labelMaxWidth) &amp;&amp; (size.width + sizeNext.width) &lt; (3.2 * labelMaxWidth)) {//Wrap+Reduce font size
											this.sessionVariables.labelMaxWidth = labelMaxWidth * 1.2;
											this.sessionVariables.labelWrap = true;
											if (isNullOrUndefined(this._options.labelFontSize)) {
												if (this.labelFontSize &gt; 12) {
													this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);//labelFontSize should not go beyond 12
													size = textBlock.measureText();
												}
											}
											this.sessionVariables.labelFontSize = isNullOrUndefined(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize;
											this.sessionVariables.labelAngle = this.labelAngle;
										}
										else if (((size.width + sizeNext.width) &gt;&gt; 0) &gt;= (3.2 * labelMaxWidth) &amp;&amp; (size.width + sizeNext.width) &lt; (3.6 * labelMaxWidth)) {//Rotate+Wrap
											this.sessionVariables.labelAngle = -25;
											this.sessionVariables.labelWrap = true;
											this.sessionVariables.labelMaxWidth = labelMaxWidth * 2.5;
											this.sessionVariables.labelFontSize = this.labelFontSize;
										}
										else if ((size.width + sizeNext.width) &gt; (3.6 * labelMaxWidth) &amp;&amp; (size.width + sizeNext.width) &lt; (5 * labelMaxWidth)) {
											if (isNullOrUndefined(this._options.labelFontSize)) {
												if (this.labelFontSize &gt; 12) {
													this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);//labelFontSize should not go beyond 12
													size = textBlock.measureText();
												}
											}
											this.sessionVariables.labelFontSize = isNullOrUndefined(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize;
											this.sessionVariables.labelWrap = true;
											this.sessionVariables.labelMaxWidth = labelMaxWidth;
											this.sessionVariables.labelAngle = this.labelAngle;
											this.sessionVariables.labelWrap = true;
										}
										else if ((size.width + sizeNext.width) &gt; (5 * labelMaxWidth)) {
											this.sessionVariables.labelWrap = true;
											this.sessionVariables.labelMaxWidth = labelMaxWidth;
											this.sessionVariables.labelFontSize = this.labelFontSize;
											this.sessionVariables.labelMaxHeight = labelMaxHeight;
											this.sessionVariables.labelAngle = this.labelAngle;
										}
									}
								}
							}
						}

					}
					for (k = 0; k &lt; this._labels.length; k++) {
						textBlock = this._labels[k].textBlock;
						textBlock.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth;
						textBlock.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize;
						textBlock.angle = this.labelAngle = this.sessionVariables.labelAngle;
						textBlock.wrap = this.labelWrap = this.sessionVariables.labelWrap;
						textBlock.maxHeight = this.sessionVariables.labelMaxHeight;
						textBlock.measureText();
					}
				}
					//Panning Mode
				else {
					for (i = 0; i &lt; this._labels.length; i++) {
						textBlock = this._labels[i].textBlock;
						textBlock.maxWidth = this.labelMaxWidth = isNullOrUndefined(this._options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this._options.labelMaxWidth;
						textBlock.fontSize = this.labelFontSize = isNullOrUndefined(this._options.labelFontSize) ? this.sessionVariables.labelFontSize : this._options.labelFontSize;
						textBlock.angle = this.labelAngle = isNullOrUndefined(this._options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle;
						textBlock.wrap = this.labelWrap = isNullOrUndefined(this._options.labelWrap) ? this.sessionVariables.labelWrap : this._options.labelWrap;
						textBlock.maxHeight = this.sessionVariables.labelMaxHeight;
						textBlock.measureText();
					}
				}
			}
			else if (this._position === &quot;left&quot; || this._position === &quot;right&quot;) {
				var j = 0;
				labelMaxWidth = isNullOrUndefined(this._options.labelMaxWidth) ? this.chart.width * .3 &gt;&gt; 0 : this._options.labelMaxWidth;
				if (!isNullOrUndefined(this.labelAngle)) {
					this.labelAngle = ((this.labelAngle % 360) + 360) % 360;

					if (this.labelAngle &gt; 90 &amp;&amp; this.labelAngle &lt;= 270)
						this.labelAngle -= 180;
					else if (this.labelAngle &gt; 270 &amp;&amp; this.labelAngle &lt;= 360)
						this.labelAngle -= 360
				}

				if (!(this.chart.panEnabled) &amp;&amp; this._labels.length &gt;= 1) {
					this.sessionVariables.labelFontSize = this.labelFontSize;
					this.sessionVariables.labelMaxWidth = labelMaxWidth;
					this.sessionVariables.labelMaxHeight = labelMaxHeight;
					this.sessionVariables.labelAngle = isNullOrUndefined(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
					this.sessionVariables.labelWrap = true;

					for (i = 0; i &lt; this._labels.length; i++) {
						textBlock = this._labels[i].textBlock;
						var size = textBlock.measureText();

						if (i &lt; this._labels.length - 1) {
							j = (i + 1);
							textBlockNext = this._labels[j].textBlock;
							sizeNext = textBlockNext.measureText();
						}
						effectiveLabelWidths.push(textBlock.height);
						this.sessionVariables.labelMaxHeight = Math.max.apply(Math, effectiveLabelWidths);

						labelEffectiveMaxHeight = (labelMaxWidth * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) + ((labelMaxHeight - textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)));
						labelEffectiveMaxWidth = (labelMaxWidth * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) + ((labelMaxHeight - textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)));
						if (!(isNullOrUndefined(this._options.labelAngle) &amp;&amp; isNaN(this._options.labelAngle)) || this._options.labelAngle === 0) {//User has set angle --&gt;Rotate
							this.sessionVariables.labelAngle = this.labelAngle;
							this.sessionVariables.labelMaxWidth = this.labelAngle === 0 ? labelMaxWidth : Math.min((labelEffectiveMaxHeight - labelMaxHeight * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / (Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))), labelMaxHeight);
							if (!isNullOrUndefined(this._options.labelWrap)) {//User has set wrapping (true/false)
								if (this._options.labelWrap) {//wrap is true --&gt;Rotate+Wrap
									this.sessionVariables.labelMaxHeight = this.labelAngle === 0 ? labelMaxHeight : labelEffectiveMaxHeight;
									this.sessionVariables.labelWrap = this.labelWrap;
									this.sessionVariables.labelMaxWidth = labelMaxWidth;
								}
								else {//wrap is false
									if (!isNullOrUndefined(this._options.labelMaxWidth)) {//User has set labelMaxWidth --&gt;Rotate+Clip after user set labelMaxWidth
										this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.height * .8 &gt;&gt; 0 ? this.chart.height * .8 &gt;&gt; 0 : this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
										this.sessionVariables.labelWrap = this.labelWrap;
									}
									else {//User has not set labelMaxWidth --&gt;Rotate
										this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.height * .8 &gt;&gt; 0 ? this.chart.height * .8 &gt;&gt; 0 : this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
										this.sessionVariables.labelWrap = this.labelWrap;
									}
								}
							}
							else if (isNullOrUndefined(this._options.labelWrap)) {//User has not set wrap
								if (this.labelWrap &amp;&amp; !isNullOrUndefined(this._options.labelMaxWidth)) {//labelwrap-&gt;true by default --&gt;Rotate+Wrap
									this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.height * .8 &gt;&gt; 0 ? this.chart.height * .8 &gt;&gt; 0 : this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
									this.sessionVariables.labelWrap = this.labelWrap;
									this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight;
								}
								else {
									this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.height * .8 &gt;&gt; 0 ? this.chart.height * .8 &gt;&gt; 0 : this._options.labelMaxWidth : labelMaxWidth;
									this.sessionVariables.labelMaxHeight = this.labelAngle === 0 ? labelMaxHeight : labelEffectiveMaxHeight;
									if (isNullOrUndefined(this._options.labelMaxWidth)) {
										this.sessionVariables.labelAngle = this.labelAngle;
									}
								}
							}
						}//if-angle is not set proceed to else part
						else {
							if (!isNullOrUndefined(this._options.labelWrap)) {//User has set Wrap (true/false)
								if (this._options.labelWrap) {//wrap is true --&gt;Wrap
									this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.width * .3 &gt;&gt; 0 ? this.chart.width * .3 &gt;&gt; 0 : this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
								}
								else {//wrap is false
									if (this._options.labelMaxWidth) {//User has set labelMaxWidth --&gt;Clip after user set labelMaxWidth
										this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.width * .3 &gt;&gt; 0 ? this.chart.width * .3 &gt;&gt; 0 : this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
									}
									else {//User has not set labelMaxWidth --&gt; Rotate+Clip
										this.sessionVariables.labelMaxWidth = labelMaxWidth;
										this.sessionVariables.labelAngle = -25;
									}
								}
							}
							else if (isNullOrUndefined(this._options.labelWrap)) {//User has not set Wrap, labelWrap is true by default
								if (!isNullOrUndefined(this._options.labelMaxWidth)) {//User has set labelMaxWidth --&gt;Wrap if user set labelMaxWidth&lt;labelMaxWidth else Rotate+Wrap
									if (this._options.labelMaxWidth &lt; labelMaxWidth) {
										this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth;
									}
									else {
										this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth &gt; this.chart.width * .3 &gt;&gt; 0 ? this.chart.width * .3 &gt;&gt; 0 : this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth;
									}
								}

								else {//User has not set anything, handle auto-labelling (Rotate or Wrap or Decrease font size for the bestfit)
									//Decide Auto-Labelling based on overlapping
									if (!isNullOrUndefined(sizeNext)) {
										if (((size.height + sizeNext.height) &gt;&gt; 0) &gt;= (2 * this.labelMaxHeight) &amp;&amp; ((size.height + sizeNext.height) &gt;&gt; 0) &lt; (2.4 * this.labelMaxHeight)) {//Reduce Font size
											if (isNullOrUndefined(this._options.labelFontSize)) {
												if (this.labelFontSize &gt; 12) {
													this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);
													size = textBlock.measureText();
												}
											}
											this.sessionVariables.labelMaxHeight = this.labelMaxHeight;
											this.sessionVariables.labelFontSize = (isNullOrUndefined(this._options.labelFontSize)) ? this.labelFontSize : this._options.labelFontSize;
										}
										else if (((size.height + sizeNext.height) &gt;&gt; 0) &gt;= (2.4 * this.labelMaxHeight) &amp;&amp; (size.height + sizeNext.height) &lt; (2.8 * this.labelMaxHeight)) {//Slant
											this.sessionVariables.labelAngle = -25;
											this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight;
											this.sessionVariables.labelFontSize = this.labelFontSize;
											this.sessionVariables.labelWrap = true;
										}
										else if (((size.height + sizeNext.height) &gt;&gt; 0) &gt;= (2.8 * this.labelMaxHeight) &amp;&amp; (size.height + sizeNext.height) &lt; (3.2 * this.labelMaxHeight)) {//Wrap+Reduce font size
											this.sessionVariables.labelMaxHeight = this.labelMaxHeight;
											this.sessionVariables.labelWrap = true;
											if (isNullOrUndefined(this._options.labelFontSize)) {
												if (this.labelFontSize &gt; 12) {
													this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);
													size = textBlock.measureText();
												}
											}
											this.sessionVariables.labelFontSize = isNullOrUndefined(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize;
											this.sessionVariables.labelAngle = isNullOrUndefined(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
										}
										else if (((size.height + sizeNext.height) &gt;&gt; 0) &gt;= (3.2 * this.labelMaxHeight) &amp;&amp; (size.height + sizeNext.height) &lt; (3.6 * this.labelMaxHeight)) {//Rotate+Wrap
											this.sessionVariables.labelAngle = -25;
											this.sessionVariables.labelMaxHeight = labelEffectiveMaxHeight;
											this.sessionVariables.labelWrap = true;
											this.sessionVariables.labelFontSize = this.labelFontSize;
										}
										else if ((size.height + sizeNext.height) &gt; (3.6 * this.labelMaxHeight) &amp;&amp; (size.height + sizeNext.height) &lt; (10 * this.labelMaxHeight)) {
											if (isNullOrUndefined(this._options.labelFontSize)) {
												if (this.labelFontSize &gt; 12) {
													this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);
													size = textBlock.measureText();
												}
											}
											this.sessionVariables.labelFontSize = isNullOrUndefined(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize;
											this.sessionVariables.labelMaxWidth = labelMaxWidth;
											this.sessionVariables.labelMaxHeight = this.labelMaxHeight;
											this.sessionVariables.labelAngle = isNullOrUndefined(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
										}
										else if ((size.height + sizeNext.height) &gt; (10 * this.labelMaxHeight) &amp;&amp; (size.height + sizeNext.height) &lt; (50 * this.labelMaxHeight)) {
											if (isNullOrUndefined(this._options.labelFontSize)) {
												if (this.labelFontSize &gt; 12) {
													this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize);
													size = textBlock.measureText();
												}
											}
											this.sessionVariables.labelFontSize = isNullOrUndefined(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize;
											this.sessionVariables.labelMaxHeight = this.labelMaxHeight;
											this.sessionVariables.labelMaxWidth = labelMaxWidth;
											this.sessionVariables.labelAngle = isNullOrUndefined(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
										}
									}
								}
							}

						}

					}
					for (k = 0; k &lt; this._labels.length; k++) {
						textBlock = this._labels[k].textBlock;
						textBlock.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth;
						textBlock.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize;
						textBlock.angle = this.labelAngle = this.sessionVariables.labelAngle;
						textBlock.wrap = this.labelWrap = this.sessionVariables.labelWrap;
						textBlock.maxHeight = this.sessionVariables.labelMaxHeight;
						textBlock.measureText();
					}
				}
					//Panning Mode
				else {
					for (i = 0; i &lt; this._labels.length; i++) {
						textBlock = this._labels[i].textBlock;
						textBlock.maxWidth = this.labelMaxWidth = isNullOrUndefined(this._options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this._options.labelMaxWidth;
						textBlock.fontSize = this.labelFontSize = isNullOrUndefined(this._options.labelFontSize) ? this.sessionVariables.labelFontSize : this._options.labelFontSize;
						textBlock.angle = this.labelAngle = isNullOrUndefined(this._options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle;
						textBlock.wrap = this.labelWrap = isNullOrUndefined(this._options.labelWrap) ? this.sessionVariables.labelWrap : this._options.labelWrap;
						textBlock.maxHeight = this.sessionVariables.labelMaxHeight;
						textBlock.measureText();
					}
				}
			}
		}//------------------LabelAutoFit-------------------//


		for (var i = 0; i &lt; this.stripLines.length; i++) {
			var stripLine = this.stripLines[i];
			var stripLineMaxWidth = (this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) ? this.chart.width * .9 &gt;&gt; 0 : this.chart.height * .9 &gt;&gt; 0;
			var backgroundColor;
			
			if (stripLine.labelPlacement === &quot;outside&quot;) {
				if (!isNullOrUndefined(stripLine._options.labelBackgroundColor))
					backgroundColor = stripLine._options.labelBackgroundColor;
				else
					backgroundColor = &quot;#EEEEEE&quot;;
			}
			else {
				if (!isNullOrUndefined(stripLine._options.labelBackgroundColor))
					backgroundColor = stripLine._options.labelBackgroundColor;
				else {
					if (stripLine.startValue)
						backgroundColor = &quot;#EEEEEE&quot;;
					else
						backgroundColor = &quot;transparent&quot;;
				}
			}

			textBlock = new TextBlock(this.ctx, {
				x: 0,
				y: 0,
				//maxWidth: this.maxHeight,
				//maxHeight: this.labelFontSize,
				backgroundColor: backgroundColor,
				maxWidth: stripLine._options.labelMaxWidth ? stripLine._options.labelMaxWidth : stripLineMaxWidth,
				maxHeight: typeof (stripLine._options.labelWrap) === &quot;undefined&quot; || stripLine.labelWrap ? stripLineMaxWidth : this.labelFontSize * 1.5,
				angle: this.labelAngle,
				text: stripLine.labelFormatter ? stripLine.labelFormatter({ chart: this.chart._publicChartReference, axis: this, stripLine: stripLine }) : stripLine.label,
				horizontalAlign: &quot;left&quot;,//left, center, right
				fontSize: stripLine.labelPlacement === &quot;outside&quot; ? stripLine._options.labelFontSize ? stripLine._options.labelFontSize : this.labelFontSize : stripLine.labelFontSize,//in pixels
				fontFamily: stripLine.labelPlacement === &quot;outside&quot; ? stripLine._options.labelFontFamily ? stripLine._options.labelFontFamily : this.labelFontFamily : stripLine.labelFontFamily,
				fontWeight: stripLine.labelPlacement === &quot;outside&quot; ? stripLine._options.fontWeight ? stripLine._options.fontWeight : this.fontWeight : stripLine.fontWeight, //normal, bold, bolder, lighter,
				fontColor: stripLine._options.labelFontColor || stripLine.color,
				fontStyle: stripLine.labelPlacement === &quot;outside&quot; ? stripLine._options.fontStyle ? stripLine._options.fontStyle : this.fontWeight : stripLine.fontStyle, // normal, italic, oblique
				textBaseline: &quot;middle&quot;,
				borderThickness: 0
			});
			this._stripLineLabels.push({ position: stripLine.value, textBlock: textBlock, effectiveHeight: null, stripLine: stripLine });
		}

	}

	Axis.prototype.createLabelsAndCalculateWidth = function () {

		var maxLabelEffectiveWidth = 0;
		var i = 0;
		this._labels = [];
		this._stripLineLabels = [];

		if (this._position === &quot;left&quot; || this._position === &quot;right&quot;) {

			this.createLabels();

			for (i = 0; i &lt; this._labels.length; i++) {

				var textBlock = this._labels[i].textBlock;

				var size = textBlock.measureText();

				//var hypotenuse = Math.sqrt(Math.pow(size.height / 2, 2) + Math.pow(size.width, 2));
				//labelEffectiveWidth = hypotenuse * Math.cos(Math.abs(Math.PI / 180 * this.labelAngle) - Math.abs(Math.acos(size.width / hypotenuse)));

				var labelEffectiveWidth = 0;

				if (this.labelAngle === 0)
					labelEffectiveWidth = size.width;
				else
					labelEffectiveWidth = (size.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) + ((size.height - textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)));


				if (maxLabelEffectiveWidth &lt; labelEffectiveWidth)
					maxLabelEffectiveWidth = labelEffectiveWidth;

				this._labels[i].effectiveWidth = labelEffectiveWidth;
			}
			for (i = 0; i &lt; this._stripLineLabels.length; i++) {
				if (this._stripLineLabels[i].stripLine.labelPlacement === &quot;outside&quot;) {
					var textBlock = this._stripLineLabels[i].textBlock;

					var size = textBlock.measureText();

					//var hypotenuse = Math.sqrt(Math.pow(size.height / 2, 2) + Math.pow(size.width, 2));
					//labelEffectiveWidth = hypotenuse * Math.cos(Math.abs(Math.PI / 180 * this.labelAngle) - Math.abs(Math.acos(size.width / hypotenuse)));

					var labelEffectiveWidth = 0;

					if (this.labelAngle === 0)
						labelEffectiveWidth = size.width;
					else
						labelEffectiveWidth = (size.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) + ((size.height - textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)));


					if (maxLabelEffectiveWidth &lt; labelEffectiveWidth)
						maxLabelEffectiveWidth = labelEffectiveWidth;

					this._stripLineLabels[i].effectiveWidth = labelEffectiveWidth;
				}
			}
		}


		var titleHeight = this.title ? this._titleTextBlock.measureText().height + 2 : 0;

		var axisWidth = titleHeight + maxLabelEffectiveWidth + this.tickLength + 5;

		//if (isDebugMode &amp;&amp; window.console) {
		//	window.console.log(this.type + &quot;--- axisWidth: &quot; + axisWidth);
		//}

		return axisWidth;
	}

	Axis.prototype.createLabelsAndCalculateHeight = function () {
		var maxLabelEffectiveHeight = 0;
		this._labels = [];
		this._stripLineLabels = [];
		var textBlock;
		var i = 0;

		this.createLabels();

		if (this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) {

			for (i = 0; i &lt; this._labels.length; i++) {

				textBlock = this._labels[i].textBlock;
				var size = textBlock.measureText();
				//var diagonal = Math.sqrt(Math.pow(size.height, 2) + Math.pow(size.width, 2));

				//var hypotenuse = Math.sqrt(Math.pow(size.height / 2, 2) + Math.pow(size.width, 2));
				//var labelEffectiveHeight = hypotenuse * Math.cos(Math.PI / 2 - (Math.abs(Math.PI / 180 * this.labelAngle) + Math.abs(Math.acos(size.width / hypotenuse))));

				var labelEffectiveHeight = 0;

				if (this.labelAngle === 0)
					labelEffectiveHeight = size.height;
				else
					labelEffectiveHeight = (size.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) + ((size.height - textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)));

				if (maxLabelEffectiveHeight &lt; labelEffectiveHeight)
					maxLabelEffectiveHeight = labelEffectiveHeight;

				this._labels[i].effectiveHeight = labelEffectiveHeight;
			}
			for (i = 0; i &lt; this._stripLineLabels.length; i++) {
				if (this._stripLineLabels[i].stripLine.labelPlacement === &quot;outside&quot;) {
					textBlock = this._stripLineLabels[i].textBlock;
					var size = textBlock.measureText();
					var labelEffectiveHeight = 0;

					if (this.labelAngle === 0)
						labelEffectiveHeight = size.height;
					else
						labelEffectiveHeight = (size.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) + ((size.height - textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)));

					if (maxLabelEffectiveHeight &lt; labelEffectiveHeight)
						maxLabelEffectiveHeight = labelEffectiveHeight;

					this._labels[i].effectiveHeight = labelEffectiveHeight;
				}
			}
		}


		//var titleHeight = this.title ? this.titleFontSize + 5 : 0;
		var titleHeight = this.title ? this._titleTextBlock.measureText().height + 2 : 0;

		return titleHeight + maxLabelEffectiveHeight + this.tickLength + 5;
	}

	//Static Method that co-ordinates between axisX, axisY and renders them
	Axis.setLayoutAndRender = function (axisX, axisY, axisY2, axisPlacement, freeSpace) {
		var x1, y1, x2, y2;
		var chart = axisX.chart;
		var ctx = chart.ctx;

		axisX.calculateAxisParameters();

		if (axisY)
			axisY.calculateAxisParameters();

		if (axisY2)
			axisY2.calculateAxisParameters();

		//if (axisY &amp;&amp; axisY2 &amp;&amp; typeof (axisY._options.viewportMaximum) === &quot;undefined&quot; &amp;&amp; typeof (axisY._options.viewportMinimum) === &quot;undefined&quot; &amp;&amp; typeof (axisY._options.interval) === &quot;undefined&quot;
		//		&amp;&amp; typeof (axisY2._options.viewportMaximum) === &quot;undefined&quot; &amp;&amp; typeof (axisY2._options.viewportMinimum) === &quot;undefined&quot; &amp;&amp; typeof (axisY2._options.interval) === &quot;undefined&quot;) {

		//	var noTicksY = (axisY.viewportMaximum - axisY.viewportMinimum) / axisY.interval;

		//	var noTicksY2 = (axisY2.viewportMaximum - axisY2.viewportMinimum) / axisY2.interval;

		//	if (noTicksY &gt; noTicksY2) {
		//		axisY2.viewportMaximum = axisY2.interval * noTicksY + axisY2.viewportMinimum;
		//	} else if (noTicksY2 &gt; noTicksY) {
		//		axisY.viewportMaximum = axisY.interval * noTicksY2 + axisY.viewportMinimum;
		//	}
		//}

		var axisYlineThickness = axisY ? axisY.lineThickness ? axisY.lineThickness : 0 : 0;
		var axisY2lineThickness = axisY2 ? axisY2.lineThickness ? axisY2.lineThickness : 0 : 0;

		var axisYGridThickness = axisY ? axisY.gridThickness ? axisY.gridThickness : 0 : 0;
		var axisY2GridThickness = axisY2 ? axisY2.gridThickness ? axisY2.gridThickness : 0 : 0;

		var axisYMargin = axisY ? axisY.margin : 0;
		var axisY2Margin = axisY2 ? axisY2.margin : 0;
		var i = 0;
		var firstLabelWidthX = 0, lastLabelWidthX = 0, firstLabelWidthY, lastLabelWidthY, firstLabelWidthY2, lastLabelWidthY2, firstLabelPosition, lastLabelPosition, lastLabelWidthOutside = 0, firstLabelOutside = 0;
		var xFlag, yFlag, y2Flag;
		xFlag = yFlag = y2Flag = false;

		if (axisX &amp;&amp; axisX.title) {
			axisX._titleTextBlock = new TextBlock(axisX.ctx, {
				text: axisX.title,
				horizontalAlign: &quot;center&quot;,//left, center, right
				fontSize: axisX.titleFontSize,//in pixels
				fontFamily: axisX.titleFontFamily,
				fontWeight: axisX.titleFontWeight, //normal, bold, bolder, lighter,
				fontColor: axisX.titleFontColor,
				fontStyle: axisX.titleFontStyle, // normal, italic, oblique
				textBaseline: &quot;top&quot;
			});
		}

		if (axisY &amp;&amp; axisY.title) {
			axisY._titleTextBlock = new TextBlock(axisY.ctx, {
				text: axisY.title,
				horizontalAlign: &quot;center&quot;,//left, center, right
				fontSize: axisY.titleFontSize,//in pixels
				fontFamily: axisY.titleFontFamily,
				fontWeight: axisY.titleFontWeight, //normal, bold, bolder, lighter,
				fontColor: axisY.titleFontColor,
				fontStyle: axisY.titleFontStyle, // normal, italic, oblique
				textBaseline: &quot;top&quot;
			});
		}

		if (axisY2 &amp;&amp; axisY2.title) {
			axisY2._titleTextBlock = new TextBlock(axisY2.ctx, {
				text: axisY2.title,
				horizontalAlign: &quot;center&quot;,//left, center, right
				fontSize: axisY2.titleFontSize,//in pixels
				fontFamily: axisY2.titleFontFamily,
				fontWeight: axisY2.titleFontWeight, //normal, bold, bolder, lighter,
				fontColor: axisY2.titleFontColor,
				fontStyle: axisY2.titleFontStyle, // normal, italic, oblique
				textBaseline: &quot;top&quot;
			});
		}

		if (axisPlacement === &quot;normal&quot;) {
			var axisXHeights = []; var axisYWidths = []; var axisY2Widths = [];
			if (axisX &amp;&amp; axisX.title) {
				axisX._titleTextBlock.maxWidth = axisX.titleMaxWidth || freeSpace.width;
				axisX._titleTextBlock.maxHeight = axisX.titleWrap ? freeSpace.height * 0.8 : axisX.titleFontSize * 1.5;
				axisX._titleTextBlock.angle = 0;
			}

			if (axisY &amp;&amp; axisY.title) {
				axisY._titleTextBlock.maxWidth = axisY.titleMaxWidth || freeSpace.height;//this.lineCoordinates.height,
				axisY._titleTextBlock.maxHeight = axisY.titleWrap ? freeSpace.width * 0.8 : axisY.titleFontSize * 1.5;
				axisY._titleTextBlock.angle = -90;
			}

			if (axisY2 &amp;&amp; axisY2.title) {
				axisY2._titleTextBlock.maxWidth = axisY2.titleMaxWidth || freeSpace.height;
				axisY2._titleTextBlock.maxHeight = axisY2.titleWrap ? freeSpace.width * 0.8 : axisY2.titleFontSize * 1.5;
				axisY2._titleTextBlock.angle = 90;
			}

			while (i++ &lt; 4) {

				axisX.lineCoordinates = {
				};

				var axisYWidth = Math.ceil(axisY ? axisY.createLabelsAndCalculateWidth() : 0);
				axisYWidths.push(axisYWidth);
				x1 = Math.round(freeSpace.x1 + axisYWidth + axisYMargin);
				var axisY2Width = Math.ceil(axisY2 ? axisY2.createLabelsAndCalculateWidth() : 0);
				axisY2Widths.push(axisY2Width);
				x2 = Math.round(freeSpace.x2 - axisY2Width - axisY2Margin &gt; axisX.chart.width - 10 ? axisX.chart.width - 10 : freeSpace.x2 - axisY2Width - axisY2Margin);

				if (axisX.labelAutoFit &amp;&amp; !isNullOrUndefined(firstLabelPosition) &amp;&amp; !isNullOrUndefined(lastLabelPosition)) {
					if (axisX.labelAngle &gt; 0) {
						if (lastLabelPosition + lastLabelWidthX &gt; x2)
							lastLabelWidthOutside += ((axisX.labelAngle &gt; 0) ? (lastLabelPosition + lastLabelWidthX) - x2 - axisY2Width : 0);
					}
					else if (axisX.labelAngle &lt; 0) {
						if (firstLabelPosition - firstLabelWidthX &lt; x1 &amp;&amp; firstLabelPosition - firstLabelWidthX &lt; axisX.viewportMinimum) {
							firstLabelOutside = x1 - (axisYMargin + axisX.tickLength + axisYWidth + firstLabelPosition - firstLabelWidthX + axisX.labelFontSize / 2);
						}
					}
					else if (axisX.labelAngle === 0) {
						if (lastLabelPosition + lastLabelWidthX &gt; x2)
							lastLabelWidthOutside = (lastLabelPosition + lastLabelWidthX / 2) - x2 - axisY2Width;
						if (firstLabelPosition - firstLabelWidthX &lt; x1 &amp;&amp; firstLabelPosition - firstLabelWidthX &lt; axisX.viewportMinimum) {
							firstLabelOutside = x1 - axisYMargin - axisX.tickLength - axisYWidth - firstLabelPosition + (firstLabelWidthX / 2);
						}

					}
					if ((axisX.viewportMaximum === axisX.maximum &amp;&amp; axisX.viewportMinimum === axisX.minimum) &amp;&amp; axisX.labelAngle &gt; 0 &amp;&amp; lastLabelWidthOutside &gt; 0)
						x2 -= lastLabelWidthOutside;
					else if ((axisX.viewportMaximum === axisX.maximum &amp;&amp; axisX.viewportMinimum === axisX.minimum) &amp;&amp; axisX.labelAngle &lt; 0 &amp;&amp; firstLabelOutside &gt; 0)
						x1 += firstLabelOutside;
					else if ((axisX.viewportMaximum === axisX.maximum &amp;&amp; axisX.viewportMinimum === axisX.minimum) &amp;&amp; axisX.labelAngle === 0) {
						if (firstLabelOutside &gt; 0)
							x1 += firstLabelOutside;
						if (lastLabelWidthOutside &gt; 0)
							x2 -= lastLabelWidthOutside;
					}
				}
				axisX.lineCoordinates.x1 = x1;
				axisX.lineCoordinates.x2 = x2;

				axisX.lineCoordinates.width = Math.abs(x2 - x1); // required early on inside createLabels of axisX

				if (axisX.title)
					axisX._titleTextBlock.maxWidth = axisX.titleMaxWidth &gt; 0 &amp;&amp; axisX.titleMaxWidth &lt; axisX.lineCoordinates.width ? axisX.titleMaxWidth : axisX.lineCoordinates.width;

				var axisXHeight = Math.ceil(axisX.createLabelsAndCalculateHeight());
				axisXHeights.push(axisXHeight);

				if (axisX._labels &amp;&amp; axisX._labels.length &gt; 1) {
					var firstLabel = 0, lastLabel = 0;
					firstLabel = axisX._labels[1];
					if (axisX.chart.plotInfo.axisXValueType === &quot;dateTime&quot;) {
						lastLabel = axisX._labels[axisX._labels.length - 2];
					}
					else
						lastLabel = axisX._labels[axisX._labels.length - 1];
					firstLabelWidthX = (firstLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle))) + ((firstLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle)));
					lastLabelWidthX = (lastLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle))) + ((lastLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle)));
				}


				if (!chart.panEnabled)
					chart.sessionVariables.axisX.height = axisXHeight;
				else
					axisXHeight = chart.sessionVariables.axisX.height;
				// Position axisX based on the available free space, Margin and its height
				//x1 = freeSpace.x1 + axisYWidth + axisYMargin + axisYlineThickness / 2;
				y1 = Math.round(freeSpace.y2 - axisXHeight - axisX.margin);
				y2 = Math.round(freeSpace.y2 - axisX.margin);

				//axisX.lineCoordinates = { x1: x1, y1: y1, x2: x2, y2: y1, width: Math.abs(x2 - x1) }
				axisX.lineCoordinates.y1 = y1;
				axisX.lineCoordinates.y2 = y1;

				axisX.boundingRect = {
					x1: x1, y1: y1, x2: x2, y2: y2, width: x2 - x1, height: y2 - y1
				};

				//if (isDebugMode) {
				//	axisX.ctx.rect(axisX.boundingRect.x1, axisX.boundingRect.y1, axisX.boundingRect.width, axisX.boundingRect.height);
				//	axisX.ctx.stroke();
				//}

				// Position axisY based on the available free space, Margin and its height
				if (axisY) {
					x1 = Math.round(freeSpace.x1 + axisY.margin);
					//x1 = Math.round(axisX.lineCoordinates.x1 - axisYWidth);
					y1 = Math.round(freeSpace.y1 &lt; 10 ? 10 : freeSpace.y1);
					x2 = Math.round(freeSpace.x1 + axisYWidth + axisY.margin);
					//x2 = Math.round(axisX.lineCoordinates.x1);
					//y2 = freeSpace.y2 - axisXHeight - axisX.margin - axisX.lineThickness / 2;
					y2 = Math.round(freeSpace.y2 - axisXHeight - axisX.margin);

					axisY.lineCoordinates = {
						x1: x2, y1: y1, x2: x2, y2: y2, height: Math.abs(y2 - y1)
					}

					axisY.boundingRect = {
						x1: x1, y1: y1, x2: x2, y2: y2, width: x2 - x1, height: y2 - y1
					};

					if (axisY.title)
						axisY._titleTextBlock.maxWidth = axisY.titleMaxWidth &gt; 0 &amp;&amp; axisY.titleMaxWidth &lt; axisY.lineCoordinates.height ? axisY.titleMaxWidth : axisY.lineCoordinates.height;
				}

				//if (isDebugMode &amp;&amp; axisY) {
				//	axisY.ctx.rect(axisY.boundingRect.x1, axisY.boundingRect.y1, axisY.boundingRect.width, axisY.boundingRect.height);
				//	axisY.ctx.stroke();
				//}

				// Position axisY2 based on the available free space, Margin and its height
				if (axisY2) {
					x1 = Math.round(axisX.lineCoordinates.x2);
					y1 = Math.round(freeSpace.y1 &lt; 10 ? 10 : freeSpace.y1);
					x2 = Math.round(x1 + axisY2Width);
					//y2 = freeSpace.y2 - axisXHeight - axisX.margin - axisX.lineThickness / 2;
					y2 = Math.round(freeSpace.y2 - axisXHeight - axisX.margin);

					axisY2.lineCoordinates = {
						x1: x1, y1: y1, x2: x1, y2: y2, height: Math.abs(y2 - y1)
					}

					axisY2.boundingRect = {
						x1: x1, y1: y1, x2: x2, y2: y2, width: x2 - x1, height: y2 - y1
					};

					if (axisY2.title)
						axisY2._titleTextBlock.maxWidth = axisY2.titleMaxWidth &gt; 0 &amp;&amp; axisY2.titleMaxWidth &lt; axisY2.lineCoordinates.height ? axisY2.titleMaxWidth : axisY2.lineCoordinates.height;
				}


				axisX.calculateValueToPixelConversionParameters();
				if (axisX._labels &amp;&amp; axisX._labels.length &gt; 1) {
					firstLabelPosition = (axisX._labels[1].position - axisX.viewportMinimum) * axisX.conversionParameters.pixelPerUnit + axisX.lineCoordinates.x1;
					if (axisX.chart.plotInfo.axisXValueType === &quot;dateTime&quot;)
						lastLabelPosition = (axisX._labels[axisX._labels.length - 2].position - axisX.viewportMinimum) * axisX.conversionParameters.pixelPerUnit + axisX.lineCoordinates.x1;
					else
						lastLabelPosition = (axisX._labels[axisX._labels.length - 1].position - axisX.viewportMinimum) * axisX.conversionParameters.pixelPerUnit + axisX.lineCoordinates.x1;
				}

				if (axisY)
					axisY.calculateValueToPixelConversionParameters();

				if (axisY2)
					axisY2.calculateValueToPixelConversionParameters();

				if (axisX || axisY || axisY2) {
					if (!isNullOrUndefined(axisXHeights)) {
						for (i = 0; i &lt; axisXHeights.length; i++) {
							for (j = i + 1; j &lt; axisXHeights.length; j++) {
								if (axisXHeights[i] == axisXHeights[j])
									xFlag = true;
							}
						}
					}
					if (!isNullOrUndefined(axisYWidths)) {
						for (i = 0; i &lt; axisYWidths.length; i++) {
							for (j = i + 1; j &lt; axisYWidths.length; j++) {
								if (axisYWidths[i] == axisYWidths[j])
									yFlag = true;
							}
						}
					}
					if (!isNullOrUndefined(axisY2Widths)) {
						for (i = 0; i &lt; axisY2Widths.length; i++) {
							for (j = i + 1; j &lt; axisY2Widths.length; j++) {
								if (axisY2Widths[i] == axisY2Widths[j])
									y2Flag = true;
							}
						}
					}
				}
				if (xFlag &amp;&amp; yFlag &amp;&amp; y2Flag) {
					break;
				}
			}

			ctx.save();
			ctx.beginPath();
			ctx.rect(5, axisX.boundingRect.y1, axisX.chart.width - 10, axisX.boundingRect.height);
			ctx.clip();

			axisX.renderLabelsTicksAndTitle();
			ctx.restore();

			if (axisY)
				axisY.renderLabelsTicksAndTitle();

			if (axisY2)
				axisY2.renderLabelsTicksAndTitle();


			chart.preparePlotArea();
			var plotArea = axisX.chart.plotArea;

			ctx.save();
			ctx.beginPath();
			ctx.rect(plotArea.x1, plotArea.y1, Math.abs(plotArea.x2 - plotArea.x1), Math.abs(plotArea.y2 - plotArea.y1));

			ctx.clip();

			axisX.renderStripLinesOfThicknessType(&quot;value&quot;);

			if (axisY)
				axisY.renderStripLinesOfThicknessType(&quot;value&quot;);

			if (axisY2)
				axisY2.renderStripLinesOfThicknessType(&quot;value&quot;);


			axisX.renderInterlacedColors();

			if (axisY)
				axisY.renderInterlacedColors();

			if (axisY2)
				axisY2.renderInterlacedColors();

			ctx.restore();


			axisX.renderGrid();

			if (axisY)
				axisY.renderGrid();

			if (axisY2)
				axisY2.renderGrid();


			axisX.renderAxisLine();

			if (axisY)
				axisY.renderAxisLine();

			if (axisY2)
				axisY2.renderAxisLine();


			//No need to clip to plotArea because stripLines need to render on top of gridlines
			axisX.renderStripLinesOfThicknessType(&quot;pixel&quot;);

			if (axisY)
				axisY.renderStripLinesOfThicknessType(&quot;pixel&quot;);

			if (axisY2)
				axisY2.renderStripLinesOfThicknessType(&quot;pixel&quot;);
		}
		else {
			var axisXWidths = []; var axisYHeights = []; var axisY2Heights = [];
			if (axisX &amp;&amp; axisX.title) {
				axisX._titleTextBlock.maxWidth = axisX.titleMaxWidth || freeSpace.height;//this.lineCoordinates.height,
				axisX._titleTextBlock.maxHeight = axisX.titleWrap ? freeSpace.width * 0.8 : axisX.titleFontSize * 1.5;
				axisX._titleTextBlock.angle = -90;
			}

			if (axisY &amp;&amp; axisY.title) {
				axisY._titleTextBlock.maxWidth = axisY.titleMaxWidth || freeSpace.width;//axisX.lineCoordinates.width,
				axisY._titleTextBlock.maxHeight = axisY.titleWrap ? freeSpace.height * 0.8 : axisY.titleFontSize * 1.5;
				axisY._titleTextBlock.angle = 0;
			}

			if (axisY2 &amp;&amp; axisY2.title) {
				axisY2._titleTextBlock.maxWidth = axisY.titleMaxWidth || freeSpace.width;//this.lineCoordinates.width,
				axisY2._titleTextBlock.maxHeight = axisY2.titleWrap ? freeSpace.height * 0.8 : axisY2.titleFontSize * 1.5;
				axisY2._titleTextBlock.angle = 0;
			}

			while (i++ &lt; 4) {
				var axisXWidth = Math.ceil(axisX.createLabelsAndCalculateWidth());
				axisXWidths.push(axisXWidth);

				if (axisY) {
					axisY.lineCoordinates = {
					};
					x1 = Math.round(freeSpace.x1 + axisXWidth + axisX.margin);
					x2 = Math.round(freeSpace.x2 &gt; axisY.chart.width - 10 ? axisY.chart.width - 10 : freeSpace.x2);
					if (axisY.labelAutoFit) {
						if (!isNullOrUndefined(firstLabelWidthY)) {
							x1 = axisY.labelAngle &lt; 0 ? Math.max(x1, firstLabelWidthY) : axisY.labelAngle === 0 ? Math.max(x1, firstLabelWidthY / 2) : x1;
							x2 = axisY.labelAngle &gt; 0 ? x2 - lastLabelWidthY : axisY.labelAngle === 0 ? x2 - lastLabelWidthY / 2 : x2;
						}
					}
					axisY.lineCoordinates.x1 = x1;
					axisY.lineCoordinates.x2 = x2;
					axisY.lineCoordinates.width = Math.abs(x2 - x1);
					if (axisY.title)
						axisY._titleTextBlock.maxWidth = axisY.titleMaxWidth &gt; 0 &amp;&amp; axisY.titleMaxWidth &lt; axisY.lineCoordinates.width ? axisY.titleMaxWidth : axisY.lineCoordinates.width;
				}

				if (axisY2) {
					axisY2.lineCoordinates = {
					};
					x1 = Math.round(freeSpace.x1 + axisXWidth + axisX.margin);
					x2 = Math.round(freeSpace.x2 &gt; axisY2.chart.width - 10 ? axisY2.chart.width - 10 : freeSpace.x2);
					if (axisY &amp;&amp; axisY.labelAutoFit) {
						if (!isNullOrUndefined(firstLabelWidthY2)) {
							x1 = axisY2.labelAngle &gt; 0 ? Math.max(x1, firstLabelWidthY2) : axisY2.labelAngle === 0 ? Math.max(x1, firstLabelWidthY2 / 2) : x1;
							x2 = axisY2.labelAngle &lt; 0 ? x2 - lastLabelWidthY2 / 2 : axisY2.labelAngle === 0 ? x2 - lastLabelWidthY2 / 2 : x2 - (lastLabelWidthY2 / 2);
						}
					}
					axisY2.lineCoordinates.x1 = x1;
					axisY2.lineCoordinates.x2 = x2;
					axisY2.lineCoordinates.width = Math.abs(x2 - x1);
					if (axisY2.title)
						axisY2._titleTextBlock.maxWidth = axisY2.titleMaxWidth &gt; 0 &amp;&amp; axisY2.titleMaxWidth &lt; axisY2.lineCoordinates.width ? axisY2.titleMaxWidth : axisY2.lineCoordinates.width;
				}



				var axisYHeight = Math.ceil(axisY ? axisY.createLabelsAndCalculateHeight() : 0);
				var axisY2Height = Math.ceil(axisY2 ? axisY2.createLabelsAndCalculateHeight() : 0);
				axisYHeights.push(axisYHeight); axisY2Heights.push(axisY2Height);

				if (axisY &amp;&amp; axisY._labels.length &gt; 0) {
					var firstLabel = axisY._labels[0];
					var lastLabel = axisY._labels[axisY._labels.length - 1];
					firstLabelWidthY = (firstLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle))) + ((firstLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle)));//(axisY2._labels[0].textBlock.width);
					lastLabelWidthY = (lastLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle))) + ((lastLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle)));//axisY2._labels[axisY2._labels.length - 1].textBlock.width;
				}

				if (axisY2 &amp;&amp; axisY2._labels.length &gt; 0) {
					var firstLabel = axisY2._labels[0];
					var lastLabel = axisY2._labels[axisY2._labels.length - 1];
					firstLabelWidthY2 = (firstLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle))) + ((firstLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(firstLabel.textBlock.angle)));//(axisY2._labels[0].textBlock.width);
					lastLabelWidthY2 = (lastLabel.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle))) + ((lastLabel.textBlock.height - lastLabel.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(lastLabel.textBlock.angle)));//axisY2._labels[axisY2._labels.length - 1].textBlock.width;
				}

				if (!chart.panEnabled)
					chart.sessionVariables.axisY.height = axisYHeight;
				else
					axisYHeight = chart.sessionVariables.axisY.height;

				// Position axisY based on the available free space, Margin and its height
				if (axisY) {
					//x1 = freeSpace.x1 + axisXWidth + axisX.margin + axisX.lineThickness / 2;
					//x2 = freeSpace.x2 &gt; axisY.chart.width - 10 ? axisY.chart.width - 10 : freeSpace.x2;

					y1 = Math.round(freeSpace.y2 - axisYHeight - axisY.margin);
					y2 = Math.round(freeSpace.y2 - axisYMargin &gt; axisY.chart.height - 10 ? axisY.chart.height - 10 : freeSpace.y2 - axisYMargin);

					//axisY.lineCoordinates = { x1: x1, y1: y1, x2: x2, y2: y1, width: Math.abs(x2 - x1) }
					axisY.lineCoordinates.y1 = y1;
					axisY.lineCoordinates.y2 = y1;

					axisY.boundingRect = {
						x1: x1, y1: y1, x2: x2, y2: y2, width: x2 - x1, height: axisYHeight
					};
					if (axisY.title)
						axisY._titleTextBlock.maxWidth = axisY.titleMaxWidth &gt; 0 &amp;&amp; axisY.titleMaxWidth &lt; axisY.lineCoordinates.width ? axisY.titleMaxWidth : axisY.lineCoordinates.width;
				}

				// Position axisY based on the available free space, Margin and its height
				if (axisY2) {
					//x1 = freeSpace.x1 + axisXWidth + axisX.margin + axisX.lineThickness / 2;
					//x2 = freeSpace.x2 &gt; axisY2.chart.width - 10 ? axisY2.chart.width - 10 : freeSpace.x2;

					y1 = Math.round(freeSpace.y1 + axisY2.margin);
					y2 = (freeSpace.y1 + axisY2.margin + axisY2Height);

					//axisY2.lineCoordinates = { x1: x1, y1: y2, x2: x2, y2: y2, width: Math.abs(x2 - x1) }
					axisY2.lineCoordinates.y1 = y2;
					axisY2.lineCoordinates.y2 = y2;

					axisY2.boundingRect = {
						x1: x1, y1: y1, x2: x2, y2: y2, width: x2 - x1, height: axisY2Height
					};
					if (axisY2.title)
						axisY2._titleTextBlock.maxWidth = axisY2.titleMaxWidth &gt; 0 &amp;&amp; axisY2.titleMaxWidth &lt; axisY2.lineCoordinates.width ? axisY2.titleMaxWidth : axisY2.lineCoordinates.width;
				}

				//axisY.ctx.rect(axisY.boundingRect.x1, axisY.boundingRect.y1, axisY.boundingRect.width, axisY.boundingRect.height);
				//axisY.ctx.stroke();

				// Position axisX based on the available free space, Margin and its height
				x1 = Math.round(freeSpace.x1 + axisX.margin);
				y1 = Math.round(axisY2 ? axisY2.lineCoordinates.y2 : (freeSpace.y1 &lt; 10 ? 10 : freeSpace.y1));
				x2 = Math.round(freeSpace.x1 + axisXWidth + axisX.margin);
				y2 = Math.round(axisY ? axisY.lineCoordinates.y1 : (freeSpace.y2 - axisYMargin &gt; axisX.chart.height - 10 ? axisX.chart.height - 10 : freeSpace.y2 - axisYMargin));

				if (axisY &amp;&amp; axisY.labelAutoFit) {
					x2 = axisY.labelAngle &lt; 0 ? Math.max(x2, firstLabelWidthY) : axisY.labelAngle === 0 ? Math.max(x2, firstLabelWidthY / 2) : x2;
					x1 = axisY.labelAngle &lt; 0 || axisY.labelAngle === 0 ? x2 - axisXWidth : x1;
				}

				if (axisY2 &amp;&amp; axisY2.labelAutoFit) {
					x2 = axisY2.lineCoordinates.x1;//Math.max(x2, firstLabelWidthY2 / 2);
					x1 = x2 - axisXWidth;

				}


				axisX.lineCoordinates = {
					x1: x2, y1: y1, x2: x2, y2: y2, height: Math.abs(y2 - y1)
				};

				axisX.boundingRect = {
					x1: x1, y1: y1, x2: x2, y2: y2, width: x2 - x1, height: y2 - y1
				};

				if (axisX.title)
					axisX._titleTextBlock.maxWidth = axisX.titleMaxWidth &gt; 0 &amp;&amp; axisX.titleMaxWidth &lt; axisX.lineCoordinates.height ? axisX.titleMaxWidth : axisX.lineCoordinates.height;

				//axisX.ctx.rect(axisX.boundingRect.x1, axisX.boundingRect.y1, axisX.boundingRect.width, axisX.boundingRect.height);
				//axisX.ctx.stroke();
				axisX.calculateValueToPixelConversionParameters();

				if (axisY) {
					axisY.calculateValueToPixelConversionParameters();
					//intervalInPixelsY = axisY.conversionParameters.pixelPerUnit * convertToNumber(axisY.interval, axisY.intervalType);
				}
				if (axisY2) {
					axisY2.calculateValueToPixelConversionParameters();
					//intervalInPixelsY2 = axisY2.conversionParameters.pixelPerUnit * convertToNumber(axisY2.interval, axisY2.intervalType);
				}

				if (axisX || axisY || axisY2) {
					if (!isNullOrUndefined(axisXHeights)) {
						for (i = 0; i &lt; axisXHeights.length; i++) {
							for (j = i + 1; j &lt; axisXHeights.length; j++) {
								if (axisXHeights[i] == axisXHeights[j])
									xFlag = true;
							}
						}
					}
					if (!isNullOrUndefined(axisYWidths)) {
						for (i = 0; i &lt; axisYWidths.length; i++) {
							for (j = i + 1; j &lt; axisYWidths.length; j++) {
								if (axisYWidths[i] == axisYWidths[j])
									yFlag = true;
							}
						}
					}
					if (!isNullOrUndefined(axisY2Widths)) {
						for (i = 0; i &lt; axisY2Widths.length; i++) {
							for (j = i + 1; j &lt; axisY2Widths.length; j++) {
								if (axisY2Widths[i] == axisY2Widths[j])
									y2Flag = true;
							}
						}
					}
				}
				if (xFlag &amp;&amp; yFlag &amp;&amp; y2Flag) {
					break;
				}

				//x2 = Math.round(freeSpace.x2 &gt; axisY.chart.width - 10 ? axisY.chart.width - 10 - intervalInPixels : freeSpace.x2 - intervalInPixels);
				//axisY.lineCoordinates.x1 -= chart.axisY.conversionParameters.pixelPerUnit * convertToNumber(chart.axisY.interval, chart.axisY.intervalType);
				//axisY.lineCoordinates.x2 -= chart.axisY.conversionParameters.pixelPerUnit * convertToNumber(chart.axisY.interval, chart.axisY.intervalType);
			}

			//axisX.calculateValueToPixelConversionParameters();

			//if (axisY)
			//	axisY.calculateValueToPixelConversionParameters();
			//if (axisY2)
			//	axisY2.calculateValueToPixelConversionParameters();

			//console.log(chart.axisY.conversionParameters.pixelPerUnit * convertToNumber(chart.axisY.interval, chart.axisY.intervalType));
			//ctx.save();
			//ctx.rect(axisY.boundingRect.x1 - 30, axisY.boundingRect.y1, axisY.boundingRect.width + 60, axisY.boundingRect.height);
			//ctx.clip();

			if (axisY)
				axisY.renderLabelsTicksAndTitle();

			if (axisY2)
				axisY2.renderLabelsTicksAndTitle();

			//ctx.restore();

			axisX.renderLabelsTicksAndTitle();

			chart.preparePlotArea();
			var plotArea = axisX.chart.plotArea;

			ctx.save();
			ctx.beginPath();
			ctx.rect(plotArea.x1, plotArea.y1, Math.abs(plotArea.x2 - plotArea.x1), Math.abs(plotArea.y2 - plotArea.y1));

			ctx.clip();


			//No need to clip to plotArea because stripLines need to render on top of gridlines
			axisX.renderStripLinesOfThicknessType(&quot;value&quot;);

			if (axisY)
				axisY.renderStripLinesOfThicknessType(&quot;value&quot;);
			if (axisY2)
				axisY2.renderStripLinesOfThicknessType(&quot;value&quot;);

			axisX.renderInterlacedColors();

			if (axisY)
				axisY.renderInterlacedColors();
			if (axisY2)
				axisY2.renderInterlacedColors();

			ctx.restore();


			axisX.renderGrid();


			if (axisY)
				axisY.renderGrid();

			if (axisY2)
				axisY2.renderGrid();


			axisX.renderAxisLine();

			if (axisY)
				axisY.renderAxisLine();

			if (axisY2)
				axisY2.renderAxisLine();


			axisX.renderStripLinesOfThicknessType(&quot;pixel&quot;);

			if (axisY)
				axisY.renderStripLinesOfThicknessType(&quot;pixel&quot;);
			if (axisY2)
				axisY2.renderStripLinesOfThicknessType(&quot;pixel&quot;);


		}
	}

	Axis.prototype.renderLabelsTicksAndTitle = function () {

		var skipLabels = false;
		var totalLabelWidth = 0;
		var thresholdRatio = 1;
		var labelCount = 0;
		var skipStep = 2;
		var intervalInPixels = this.conversionParameters.pixelPerUnit * convertToNumber(this.interval, this.intervalType);

		if (this.labelAngle !== 0 &amp;&amp; this.labelAngle !== 360)
			thresholdRatio = 1.2;

		//Don&#x27;t skip labels when interval is explicitely set
		if (typeof (this._options.interval) === &quot;undefined&quot;) {
			if (this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) {

				//thresholdRatio = .9;// More space is preferred between labels when axis is horizontally aligned

				for (var i = 0; i &lt; this._labels.length; i++) {
					label = this._labels[i];
					if (label.position &lt; this.viewportMinimum)// don&#x27;t consider stripLine&#x27;s label
						continue;
					var width = label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + label.textBlock.height * Math.sin(Math.PI / 180 * this.labelAngle);

					totalLabelWidth += width;
				}

				if (totalLabelWidth &gt; this.lineCoordinates.width * thresholdRatio &amp;&amp; this.labelAutoFit) {
					skipLabels = true;
				}
			} if (this._position === &quot;left&quot; || this._position === &quot;right&quot;) {
				for (var i = 0; i &lt; this._labels.length; i++) {
					label = this._labels[i];
					if (label.position &lt; this.viewportMinimum)// don&#x27;t consider stripLine&#x27;s lable
						continue;

					var width = label.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle);

					totalLabelWidth += width;
				}

				if (totalLabelWidth &gt; this.lineCoordinates.height * thresholdRatio &amp;&amp; this.labelAutoFit) {
					skipLabels = true;
				}
			}
		}
		//		var width = label.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle);
		//		if (label.position * this.conversionParameters.pixelPerUnit + width &gt; labelNext.position * this.conversionParameters.pixelPerUnit)
		//			skipLabels = true;
		//	}
		//}


		if (this._position === &quot;bottom&quot;) {
			var i = 0;

			var label;
			var xy;

			for (i = 0; i &lt; this._labels.length; i++) {

				label = this._labels[i];
				if (label.position &lt; this.viewportMinimum || label.position &gt; this.viewportMaximum)
					continue;

				xy = this.getPixelCoordinatesOnAxis(label.position);

				if (this.tickThickness) {
					this.ctx.lineWidth = this.tickThickness;
					this.ctx.strokeStyle = this.tickColor;
					var tickX = (this.ctx.lineWidth % 2 === 1) ? (xy.x &lt;&lt; 0) + .5 : (xy.x &lt;&lt; 0);
					this.ctx.beginPath();
					this.ctx.moveTo(tickX, xy.y &lt;&lt; 0);
					this.ctx.lineTo(tickX, (xy.y + this.tickLength) &lt;&lt; 0);
					this.ctx.stroke();
				}

				if (skipLabels &amp;&amp; labelCount++ % skipStep !== 0 &amp;&amp; this.labelAutoFit)
					continue;

				if (label.textBlock.angle === 0) {
					xy.x -= label.textBlock.width / 2;
					xy.y += this.tickLength + label.textBlock.fontSize / 2;

				} else {
					xy.x -= (this.labelAngle &lt; 0 ? (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) : 0);
					xy.y += this.tickLength + Math.abs((this.labelAngle &lt; 0 ? label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5));
				}
				label.textBlock.x = xy.x;
				label.textBlock.y = xy.y;

				label.textBlock.render(true);
			}

			if (this.title) {

				this._titleTextBlock.measureText();
				this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2;
				this._titleTextBlock.y = this.boundingRect.y2 - this._titleTextBlock.height - 3;
				this._titleTextBlock.render(true);
			}
		}
		else if (this._position === &quot;top&quot;) {
			var i = 0;

			var label;
			var xy;

			for (i = 0; i &lt; this._labels.length; i++) {
				label = this._labels[i];
				if (label.position &lt; this.viewportMinimum || label.position &gt; this.viewportMaximum)
					continue;

				xy = this.getPixelCoordinatesOnAxis(label.position);

				if (this.tickThickness) {

					this.ctx.lineWidth = this.tickThickness;
					this.ctx.strokeStyle = this.tickColor;


					var tickX = (this.ctx.lineWidth % 2 === 1) ? (xy.x &lt;&lt; 0) + .5 : (xy.x &lt;&lt; 0);
					this.ctx.beginPath();
					this.ctx.moveTo(tickX, xy.y &lt;&lt; 0);
					this.ctx.lineTo(tickX, (xy.y - this.tickLength) &lt;&lt; 0);
					this.ctx.stroke();

				}

				if (skipLabels &amp;&amp; labelCount++ % skipStep !== 0 &amp;&amp; this.labelAutoFit)
					continue;

				if (label.textBlock.angle === 0) {
					xy.x -= label.textBlock.width / 2;
					xy.y -= this.tickLength + label.textBlock.height;
				} else {
					//xy.x -= label.textBlock.angle &lt; 0 ? ((label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - (label.textBlock.height - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle)) : (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) + (label.textBlock.height - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle);
					//xy.y -= this.tickLength + Math.abs((label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + (label.textBlock.height - this.labelFontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle)));
					xy.x += ((label.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle)) - (this.labelAngle &gt; 0 ? label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0);
					xy.y -= this.tickLength + (label.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (this.labelAngle &gt; 0 ? label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0));
				}
				label.textBlock.x = xy.x;
				label.textBlock.y = xy.y;

				label.textBlock.render(true);
			}

			if (this.title) {

				this._titleTextBlock.measureText();
				this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2;
				this._titleTextBlock.y = this.boundingRect.y1 + 1;
				this._titleTextBlock.render(true);
			}
		}
		else if (this._position === &quot;left&quot;) {


			var label;
			var xy;
			for (var i = 0; i &lt; this._labels.length; i++) {
				label = this._labels[i];
				if (label.position &lt; this.viewportMinimum || label.position &gt; this.viewportMaximum)
					continue;

				xy = this.getPixelCoordinatesOnAxis(label.position);

				if (this.tickThickness) {
					this.ctx.lineWidth = this.tickThickness;
					this.ctx.strokeStyle = this.tickColor;
					var tickY = (this.ctx.lineWidth % 2 === 1) ? (xy.y &lt;&lt; 0) + .5 : (xy.y &lt;&lt; 0);
					this.ctx.beginPath();
					this.ctx.moveTo(xy.x &lt;&lt; 0, tickY);
					this.ctx.lineTo((xy.x - this.tickLength) &lt;&lt; 0, tickY);
					this.ctx.stroke();
				}

				if (skipLabels &amp;&amp; labelCount++ % skipStep !== 0 &amp;&amp; this.labelAutoFit)
					continue;

				//label.textBlock.x = xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - this.tickLength - 5;

				if (this.labelAngle === 0) {
					label.textBlock.y = xy.y;
					label.textBlock.x = xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - this.tickLength - 5;
				} else {
					label.textBlock.y = (xy.y - (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle)));
					label.textBlock.x = this.labelAngle &gt; 0 ? (xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - this.tickLength - 5) : (xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) + (label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength);
				}
				label.textBlock.render(true);
			}

			if (this.title) {

				var size = this._titleTextBlock.measureText();

				//this._titleTextBlock.x -= 4;
				this._titleTextBlock.x = this.boundingRect.x1 + 1;
				this._titleTextBlock.y = (this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1);
				this._titleTextBlock.render(true);

				//if (isDebugMode) {
				//	window.console.log(&quot;titleFontSize: &quot; + this.titleFontSize + &quot;; width: &quot; + size.width + &quot;; height: &quot; + size.height);
				//	window.console.log(&quot;this.boundingRect.x1: &quot; + this.boundingRect.x1);

				//	//this.ctx.rect(this._titleTextBlock.x, this._titleTextBlock.y, this._titleTextBlock.height, -this._titleTextBlock.width);
				//	//this.ctx.stroke();

				//}

			}
		}
		else if (this._position === &quot;right&quot;) {


			var label;
			var xy;

			for (var i = 0; i &lt; this._labels.length; i++) {
				label = this._labels[i];
				if (label.position &lt; this.viewportMinimum || label.position &gt; this.viewportMaximum)
					continue;

				xy = this.getPixelCoordinatesOnAxis(label.position);

				if (this.tickThickness) {
					this.ctx.lineWidth = this.tickThickness;
					this.ctx.strokeStyle = this.tickColor;
					var tickY = (this.ctx.lineWidth % 2 === 1) ? (xy.y &lt;&lt; 0) + .5 : (xy.y &lt;&lt; 0);
					this.ctx.beginPath();
					this.ctx.moveTo(xy.x &lt;&lt; 0, tickY);
					this.ctx.lineTo((xy.x + this.tickLength) &lt;&lt; 0, tickY);
					this.ctx.stroke();

				}

				if (skipLabels &amp;&amp; labelCount++ % skipStep !== 0 &amp;&amp; this.labelAutoFit)
					continue;

				//label.textBlock.y = xy.y - (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle));

				if (this.labelAngle === 0) {
					label.textBlock.y = xy.y;
					label.textBlock.x = xy.x + this.tickLength + 5;
				} else {
					label.textBlock.y = this.labelAngle &lt; 0 ? xy.y : xy.y - (label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle);
					label.textBlock.x = this.labelAngle &gt; 0 ? (xy.x + ((label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle)) + this.tickLength) : xy.x + this.tickLength + 5;//(xy.x + (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle)) + (label.textBlock.height - label.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5);
				}

				label.textBlock.render(true);
			}

			if (this.title) {

				this._titleTextBlock.measureText();
				this._titleTextBlock.x = this.boundingRect.x2 - 1;
				this._titleTextBlock.y = (this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1);
				this._titleTextBlock.render(true);

			}
		}
	}

	Axis.prototype.renderInterlacedColors = function () {
		var ctx = this.chart.plotArea.ctx;
		//return;

		var interlacedGridStartPoint;
		var interlacedGridEndPoint;
		var plotAreaCoordinates = this.chart.plotArea;
		var i = 0, renderInterlacedGrid = true;

		if ((this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) &amp;&amp; this.interlacedColor) {

			ctx.fillStyle = this.interlacedColor;

			for (i = 0; i &lt; this._labels.length; i++) {

				if (this._labels[i].stripLine)
					continue;

				if (renderInterlacedGrid) {//So that the interlaced color alternates
					interlacedGridStartPoint = this.getPixelCoordinatesOnAxis(this._labels[i].position);

					if (i + 1 &gt;= this._labels.length - 1)
						interlacedGridEndPoint = this.getPixelCoordinatesOnAxis(this.viewportMaximum);
					else
						interlacedGridEndPoint = this.getPixelCoordinatesOnAxis(this._labels[i + 1].position);

					ctx.fillRect(interlacedGridStartPoint.x, plotAreaCoordinates.y1, Math.abs(interlacedGridEndPoint.x - interlacedGridStartPoint.x), Math.abs(plotAreaCoordinates.y1 - plotAreaCoordinates.y2));
					renderInterlacedGrid = false;
				} else
					renderInterlacedGrid = true;

			}

		} else if ((this._position === &quot;left&quot; || this._position === &quot;right&quot;) &amp;&amp; this.interlacedColor) {

			ctx.fillStyle = this.interlacedColor;

			for (i = 0; i &lt; this._labels.length; i++) {
				if (this._labels[i].stripLine)
					continue;

				if (renderInterlacedGrid) {//So that the interlaced color alternates

					interlacedGridEndPoint = this.getPixelCoordinatesOnAxis(this._labels[i].position);

					if (i + 1 &gt;= this._labels.length - 1)
						interlacedGridStartPoint = this.getPixelCoordinatesOnAxis(this.viewportMaximum);
					else
						interlacedGridStartPoint = this.getPixelCoordinatesOnAxis(this._labels[i + 1].position);

					ctx.fillRect(plotAreaCoordinates.x1, interlacedGridStartPoint.y, Math.abs(plotAreaCoordinates.x1 - plotAreaCoordinates.x2), Math.abs(interlacedGridStartPoint.y - interlacedGridEndPoint.y));
					renderInterlacedGrid = false;
				} else
					renderInterlacedGrid = true;
			}
			//throw &quot;123&quot;;
		}

		ctx.beginPath();
	}

	//Renders stripLines of given thickness type.
	Axis.prototype.renderStripLinesOfThicknessType = function (thicknessType) {

		if (!(this.stripLines &amp;&amp; this.stripLines.length &gt; 0) || !thicknessType)
			return;

		var _this = this;
		var label;
		var xy;
		var i = 0;
		for (i = 0; i &lt; this.stripLines.length; i++) {

			var stripLine = this.stripLines[i];
			if (stripLine._thicknessType !== thicknessType)
				continue;

			//Should be skipped only if thicknessType is &quot;pixel&quot;. If it is &quot;value&quot; then clipping is automatically applied before calling.
			if (thicknessType === &quot;pixel&quot; &amp;&amp; (stripLine.value &lt; this.viewportMinimum || stripLine.value &gt; this.viewportMaximum))
				continue;

			if (stripLine.showOnTop) {
				this.chart.addEventListener(&quot;dataAnimationIterationEnd&quot;, function () {
				    this.ctx.save();
				    this.ctx.beginPath();
					this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
					this.ctx.clip();
					stripLine.render();
					this.ctx.restore();
				}, stripLine);
			}
			else
				stripLine.render();
		}


		//Stripline Label placement and render
		for (i = 0; i &lt; this._stripLineLabels.length; i++) {
			var stripLine = this.stripLines[i];
			label = this._stripLineLabels[i];
			if (label.position &lt; this.viewportMinimum || label.position &gt; this.viewportMaximum)
				continue;

			xy = this.getPixelCoordinatesOnAxis(label.position);

			if (label.stripLine.labelPlacement === &quot;outside&quot;) {
				if (stripLine &amp;&amp; stripLine._thicknessType === &quot;pixel&quot;) {
					this.ctx.lineWidth = stripLine.thickness;
					this.ctx.strokeStyle = stripLine.color;
				}
				if (this._position === &quot;bottom&quot;) {
					var tickX = (this.ctx.lineWidth % 2 === 1) ? (xy.x &lt;&lt; 0) + .5 : (xy.x &lt;&lt; 0);
					this.ctx.beginPath();
					this.ctx.moveTo(tickX, xy.y &lt;&lt; 0);
					this.ctx.lineTo(tickX, (xy.y + this.tickLength) &lt;&lt; 0);
					this.ctx.stroke();

					if (this.labelAngle === 0) {
						xy.x -= label.textBlock.width / 2;
						xy.y += this.tickLength + label.textBlock.fontSize / 2;

					} else {
						xy.x -= (this.labelAngle &lt; 0 ? (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) : 0);
						xy.y += this.tickLength + Math.abs((this.labelAngle &lt; 0 ? label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5 : 5));
					}
				}
				else if (this._position === &quot;top&quot;) {
					var tickX = (this.ctx.lineWidth % 2 === 1) ? (xy.x &lt;&lt; 0) + .5 : (xy.x &lt;&lt; 0);
					this.ctx.beginPath();
					this.ctx.moveTo(tickX, xy.y &lt;&lt; 0);
					this.ctx.lineTo(tickX, (xy.y - this.tickLength) &lt;&lt; 0);
					this.ctx.stroke();
					if (this.labelAngle === 0) {
						xy.x -= label.textBlock.width / 2;
						xy.y -= this.tickLength + label.textBlock.height;
					} else {
						xy.x += ((label.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle)) - (this.labelAngle &gt; 0 ? label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0);
						xy.y -= this.tickLength + (label.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (this.labelAngle &gt; 0 ? label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0));
					}
				}
				else if (this._position === &quot;left&quot;) {
					var tickY = (this.ctx.lineWidth % 2 === 1) ? (xy.y &lt;&lt; 0) + .5 : (xy.y &lt;&lt; 0);
					this.ctx.beginPath();
					this.ctx.moveTo(xy.x &lt;&lt; 0, tickY);
					this.ctx.lineTo((xy.x - this.tickLength) &lt;&lt; 0, tickY);
					this.ctx.stroke();

					if (this.labelAngle === 0) {
						xy.x = xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - this.tickLength - 5;
					} else {
						xy.y = (xy.y - (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle)));
						xy.x = this.labelAngle &gt; 0 ? (xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) - this.tickLength - 5) : (xy.x - (label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle)) + (label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength);
					}
				}
				else if (this._position === &quot;right&quot;) {
					var tickY = (this.ctx.lineWidth % 2 === 1) ? (xy.y &lt;&lt; 0) + .5 : (xy.y &lt;&lt; 0);
					this.ctx.beginPath();
					this.ctx.moveTo(xy.x &lt;&lt; 0, tickY);
					this.ctx.lineTo((xy.x + this.tickLength) &lt;&lt; 0, tickY);
					this.ctx.stroke();

					if (this.labelAngle === 0) {
						xy.x = xy.x + this.tickLength + 5;
					} else {
						xy.y = this.labelAngle &lt; 0 ? xy.y : xy.y - (label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle);
						xy.x = this.labelAngle &gt; 0 ? (xy.x + ((label.textBlock.height - label.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle)) + this.tickLength) : xy.x + this.tickLength + 5;//(xy.x + (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle)) + (label.textBlock.height - label.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5);
					}
				}


				label.textBlock.x = xy.x;
				label.textBlock.y = xy.y;

				if (stripLine.showOnTop) {

					this.chart.addEventListener(&quot;dataAnimationIterationEnd&quot;, label.textBlock.render, label.textBlock);
				}
				else {
					label.textBlock.render(true);
				}
			}

			else {		//labelPlacement === &quot;inside&quot;
				label.textBlock.angle = -90;
				if (this._position === &quot;bottom&quot;) {
					label.textBlock.maxWidth = this._options.stripLines[i].labelMaxWidth ? this._options.stripLines[i].labelMaxWidth : this.chart.plotArea.height - 3;
					label.textBlock.measureText();
					if (xy.x - label.textBlock.height &gt; this.chart.plotArea.x1) {
						if (isNullOrUndefined(stripLine.startValue))
							xy.x -= label.textBlock.height - label.textBlock.fontSize / 2;
						else
							xy.x -= label.textBlock.height / 2 - label.textBlock.fontSize / 2 + 3;
					}
					else {
						label.textBlock.angle = 90;
						if (isNullOrUndefined(stripLine.startValue))
							xy.x += label.textBlock.height - label.textBlock.fontSize / 2;
						else
							xy.x += label.textBlock.height / 2 - label.textBlock.fontSize / 2 + 3;
					}

					if (label.textBlock.angle === -90)
						xy.y = label.stripLine.labelAlign === &quot;near&quot; ? (this.chart.plotArea.y2) - 3 : label.stripLine.labelAlign === &quot;center&quot; ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + label.textBlock.width) / 2 : (this.chart.plotArea.y1) + label.textBlock.width + 3;
					else
						xy.y = label.stripLine.labelAlign === &quot;near&quot; ? (this.chart.plotArea.y2) - label.textBlock.width - 3 : label.stripLine.labelAlign === &quot;center&quot; ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - label.textBlock.width) / 2 : (this.chart.plotArea.y1) + 3;

				}
				else if (this._position === &quot;top&quot;) {
					label.textBlock.maxWidth = this._options.stripLines[i].labelMaxWidth ? this._options.stripLines[i].labelMaxWidth : this.chart.plotArea.height - 3;
					label.textBlock.measureText();
					if (xy.x - label.textBlock.height &gt; this.chart.plotArea.x1) {
						if (isNullOrUndefined(stripLine.startValue))
							xy.x -= label.textBlock.height - label.textBlock.fontSize / 2;
						else
							xy.x -= label.textBlock.height / 2 - label.textBlock.fontSize / 2 + 3;
					}
					else {
						label.textBlock.angle = 90;
						if (isNullOrUndefined(stripLine.startValue))
							xy.x += label.textBlock.height - label.textBlock.fontSize / 2;
						else
							xy.x += label.textBlock.height / 2 - label.textBlock.fontSize / 2 + 3;
					}

					if (label.textBlock.angle === -90)
						xy.y = label.stripLine.labelAlign === &quot;near&quot; ? (this.chart.plotArea.y1) + label.textBlock.width + 3 : label.stripLine.labelAlign === &quot;center&quot; ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + label.textBlock.width) / 2 : (this.chart.plotArea.y2) - 3;
					else
						xy.y = label.stripLine.labelAlign === &quot;near&quot; ? (this.chart.plotArea.y1) + 3 : label.stripLine.labelAlign === &quot;center&quot; ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - label.textBlock.width) / 2 : (this.chart.plotArea.y2) - label.textBlock.width - 3;

				}
				else if (this._position === &quot;left&quot;) {
					label.textBlock.maxWidth = this._options.stripLines[i].labelMaxWidth ? this._options.stripLines[i].labelMaxWidth : this.chart.plotArea.width - 3;
					label.textBlock.angle = 0;
					label.textBlock.measureText();
					if (xy.y - label.textBlock.height &gt; this.chart.plotArea.y1) {
						if (isNullOrUndefined(stripLine.startValue))
							xy.y -= label.textBlock.height - label.textBlock.fontSize / 2;
						else
							xy.y -= label.textBlock.height / 2 - label.textBlock.fontSize + 3;
					}
					else if (xy.y - label.textBlock.height &lt; this.chart.plotArea.y2) {
						xy.y += label.textBlock.fontSize / 2 + 3;
					}
					else {
						if (isNullOrUndefined(stripLine.startValue))
							xy.y -= label.textBlock.height - label.textBlock.fontSize / 2;
						else
							xy.y -= label.textBlock.height / 2 - label.textBlock.fontSize + 3;
					}

					xy.x = label.stripLine.labelAlign === &quot;near&quot; ? (this.chart.plotArea.x1) + 3 : label.stripLine.labelAlign === &quot;center&quot; ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - label.textBlock.width / 2 : (this.chart.plotArea.x2) - label.textBlock.width - 3;

				}
				else if (this._position === &quot;right&quot;) {
					label.textBlock.maxWidth = this._options.stripLines[i].labelMaxWidth ? this._options.stripLines[i].labelMaxWidth : this.chart.plotArea.width - 3;
					label.textBlock.angle = 0;
					label.textBlock.measureText();
					if (xy.y - +label.textBlock.height &gt; this.chart.plotArea.y1) {
						if (isNullOrUndefined(stripLine.startValue))
							xy.y -= label.textBlock.height - label.textBlock.fontSize / 2;
						else
							xy.y -= label.textBlock.height / 2 - label.textBlock.fontSize / 2 - 3;
					}
					else if (xy.y - label.textBlock.height &lt; this.chart.plotArea.y2) {
						xy.y += label.textBlock.fontSize / 2 + 3;
					}
					else {
						if (isNullOrUndefined(stripLine.startValue))
							xy.y -= label.textBlock.height - label.textBlock.fontSize / 2;
						else
							xy.y -= label.textBlock.height / 2 - label.textBlock.fontSize / 2 + 3;
					}

					xy.x = label.stripLine.labelAlign === &quot;near&quot; ? (this.chart.plotArea.x2) - label.textBlock.width - 3 : label.stripLine.labelAlign === &quot;center&quot; ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - label.textBlock.width / 2 : (this.chart.plotArea.x1) + 3;

				}


				label.textBlock.x = xy.x;
				label.textBlock.y = xy.y;
				if (stripLine.showOnTop) {
				    this.ctx.save();
				    this.ctx.beginPath();
					this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
					this.ctx.clip();
					this.chart.addEventListener(&quot;dataAnimationIterationEnd&quot;, function () {
						label.textBlock.render(true);
						_this.ctx.restore();
					}, label.textBlock);
				}
				else {
				    this.ctx.save();
				    this.ctx.beginPath();
					this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
					this.ctx.clip();
					label.textBlock.render(true);
					this.ctx.restore();
				}
			}
		}
	};

	Axis.prototype.renderGrid = function () {

		if (!(this.gridThickness &amp;&amp; this.gridThickness &gt; 0))
			return;

		//var ctx = this.chart.plotArea.ctx;
		var ctx = this.chart.ctx;
		ctx.save();

		var xy;
		var plotAreaCoordinates = this.chart.plotArea;
		var stripLine;
		var tempLineWidth, tempStrokeStyle;

		ctx.lineWidth = this.gridThickness;
		ctx.strokeStyle = this.gridColor;

		if (ctx.setLineDash) {
			ctx.setLineDash(getLineDashArray(this.gridDashType, this.gridThickness));
		}


		if (this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) {

			for (i = 0; i &lt; this._labels.length &amp;&amp; !this._labels[i].stripLine; i++) {

				if (this._labels[i].position &lt; this.viewportMinimum || this._labels[i].position &gt; this.viewportMaximum)
					continue;

				ctx.beginPath();

				xy = this.getPixelCoordinatesOnAxis(this._labels[i].position);

				var gridX = (ctx.lineWidth % 2 === 1) ? (xy.x &lt;&lt; 0) + .5 : (xy.x &lt;&lt; 0);

				ctx.moveTo(gridX, plotAreaCoordinates.y1 &lt;&lt; 0);
				ctx.lineTo(gridX, plotAreaCoordinates.y2 &lt;&lt; 0);

				ctx.stroke();
			}

		}
		else if (this._position === &quot;left&quot; || this._position === &quot;right&quot;) {

			for (var i = 0; i &lt; this._labels.length &amp;&amp; !this._labels[i].stripLine; i++) {

				//if (i === 0 &amp;&amp; this.type === &quot;axisY&quot; &amp;&amp; this.chart.axisX &amp;&amp; this.chart.axisX.lineThickness &amp;&amp; this._labels[i].position === this.viewportMinimum)
				//	continue;

				if (this._labels[i].position &lt; this.viewportMinimum || this._labels[i].position &gt; this.viewportMaximum)
					continue;

				ctx.beginPath();

				xy = this.getPixelCoordinatesOnAxis(this._labels[i].position);

				var gridY = (ctx.lineWidth % 2 === 1) ? (xy.y &lt;&lt; 0) + .5 : (xy.y &lt;&lt; 0);

				ctx.moveTo(plotAreaCoordinates.x1 &lt;&lt; 0, gridY);
				ctx.lineTo(plotAreaCoordinates.x2 &lt;&lt; 0, gridY);

				ctx.stroke();
			}

		}

		ctx.restore();
	}

	Axis.prototype.renderAxisLine = function () {
		//var ctx = this.chart.plotArea.ctx;
		var ctx = this.chart.ctx;
		ctx.save();

		if (this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) {
			if (this.lineThickness) {
				ctx.lineWidth = this.lineThickness;
				ctx.strokeStyle = this.lineColor ? this.lineColor : &quot;black&quot;;

				if (ctx.setLineDash) {
					ctx.setLineDash(getLineDashArray(this.lineDashType, this.lineThickness));
				}

				var lineY = (this.lineThickness % 2 === 1) ? (this.lineCoordinates.y1 &lt;&lt; 0) + .5 : (this.lineCoordinates.y1 &lt;&lt; 0);

				ctx.beginPath();
				ctx.moveTo(this.lineCoordinates.x1, lineY);
				ctx.lineTo(this.lineCoordinates.x2, lineY);
				ctx.stroke();
			}

		} else if (this._position === &quot;left&quot; || this._position === &quot;right&quot;) {
			if (this.lineThickness) {
				ctx.lineWidth = this.lineThickness;
				ctx.strokeStyle = this.lineColor;

				if (ctx.setLineDash) {
					ctx.setLineDash(getLineDashArray(this.lineDashType, this.lineThickness));
				}

				var lineX = (this.lineThickness % 2 === 1) ? (this.lineCoordinates.x1 &lt;&lt; 0) + .5 : (this.lineCoordinates.x1 &lt;&lt; 0);

				ctx.beginPath();
				ctx.moveTo(lineX, this.lineCoordinates.y1);
				ctx.lineTo(lineX, this.lineCoordinates.y2);
				ctx.stroke();
			}
		}

		ctx.restore();
	}

	Axis.prototype.getPixelCoordinatesOnAxis = function (value) {
		var xy = {
		};
		var width = this.lineCoordinates.width;
		var height = this.lineCoordinates.height;

		if (this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) {
			//var pixelPerUnit = width / Math.abs(this.viewportMaximum - this.viewportMinimum);
			var pixelPerUnit = this.conversionParameters.pixelPerUnit;

			//xy.x = this.lineCoordinates.x1 + (pixelPerUnit * (value - this.viewportMinimum));
			xy.x = this.conversionParameters.reference + (pixelPerUnit * (value - this.viewportMinimum));
			xy.y = this.lineCoordinates.y1;
		}
		if (this._position === &quot;left&quot; || this._position === &quot;right&quot;) {
			//var pixelPerUnit = height / Math.abs(this.viewportMaximum - this.viewportMinimum);
			var pixelPerUnit = -this.conversionParameters.pixelPerUnit;

			//xy.y = this.lineCoordinates.y2 - (pixelPerUnit * (value - this.viewportMinimum));
			xy.y = this.conversionParameters.reference - (pixelPerUnit * (value - this.viewportMinimum));
			xy.x = this.lineCoordinates.x2;
		}

		return xy;
	}

	Axis.prototype.convertPixelToValue = function (pixel) {

		if (!pixel)
			return null;

		var value = 0;
		var p = (this._position === &quot;left&quot; || this._position === &quot;right&quot;) ? pixel.y : pixel.x;

		value = this.conversionParameters.minimum + (p - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;

		return value;
	}

	Axis.prototype.setViewPortRange = function (viewportMinimum, viewportMaximum) {

		this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(viewportMinimum, viewportMaximum);
		this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(viewportMinimum, viewportMaximum);

	}

	Axis.prototype.getXValueAt = function (pixel) {
		if (!pixel)
			return null;

		var xval = null;

		if (this._position === &quot;left&quot;) {
			xval = (this.chart.axisX.viewportMaximum - this.chart.axisX.viewportMinimum) / this.chart.axisX.lineCoordinates.height * ((this.chart.axisX.lineCoordinates.y2 - pixel.y)) + this.chart.axisX.viewportMinimum;
		}
		else if (this._position === &quot;bottom&quot;) {
			xval = (this.chart.axisX.viewportMaximum - this.chart.axisX.viewportMinimum) / this.chart.axisX.lineCoordinates.width * (pixel.x - this.chart.axisX.lineCoordinates.x1) + this.chart.axisX.viewportMinimum;
		}

		return xval;
	}

	Axis.prototype.calculateValueToPixelConversionParameters = function (value) {
		this.reversed = false;

		var conversionParameters = {
			pixelPerUnit: null, minimum: null, reference: null
		};

		var width = this.lineCoordinates.width;
		var height = this.lineCoordinates.height;

		conversionParameters.minimum = this.viewportMinimum;

		if (this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) {
			conversionParameters.pixelPerUnit = (this.reversed ? -1 : 1) * width / Math.abs(this.viewportMaximum - this.viewportMinimum);
			conversionParameters.reference = (this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1);
		}

		if (this._position === &quot;left&quot; || this._position === &quot;right&quot;) {
			conversionParameters.pixelPerUnit = (this.reversed ? 1 : -1) * height / Math.abs(this.viewportMaximum - this.viewportMinimum);
			conversionParameters.reference = (this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2);
		}


		this.conversionParameters = conversionParameters;
	}

	Axis.prototype.calculateAxisParameters = function () {

		var freeSpace = this.chart.layoutManager.getFreeSpace();
		var availableWidth = 0;
		var availableHeight = 0;
		var isLessThanTwoDataPoints = false;

		if (this._position === &quot;bottom&quot; || this._position === &quot;top&quot;) {
			this.maxWidth = freeSpace.width;
			this.maxHeight = freeSpace.height;
		} else {
			this.maxWidth = freeSpace.height;
			this.maxHeight = freeSpace.width;
		}

		var noTicks = this.type === &quot;axisX&quot; ? (this.maxWidth &lt; 500 ? 8 : Math.max(6, Math.floor(this.maxWidth / 62))) : Math.max(Math.floor(this.maxWidth / 40), 2);
		var min, max;
		var minDiff;
		var range;
		var rangePadding = 0;


		if (this.viewportMinimum === null || isNaN(this.viewportMinimum))
			this.viewportMinimum = this.minimum;

		if (this.viewportMaximum === null || isNaN(this.viewportMaximum))
			this.viewportMaximum = this.maximum;

		if (this.type === &quot;axisX&quot;) {
			min = (this.viewportMinimum !== null) ? this.viewportMinimum : this.dataInfo.viewPortMin;
			max = (this.viewportMaximum !== null) ? this.viewportMaximum : this.dataInfo.viewPortMax;

			if (max - min === 0) {
				rangePadding = typeof (this._options.interval) === &quot;undefined&quot; ? .4 : this._options.interval;

				max += rangePadding;
				min -= rangePadding;
			}

			if (this.dataInfo.minDiff !== Infinity)
				minDiff = this.dataInfo.minDiff;
			else if (max - min &gt; 1) {
				minDiff = Math.abs(max - min) * .5;
			}
			else {
				minDiff = 1;

				if (this.chart.plotInfo.axisXValueType === &quot;dateTime&quot;)
					isLessThanTwoDataPoints = true;
			}

		} else if (this.type === &quot;axisY&quot;) {

			//min = typeof (this._options.viewportMinimum) === &quot;undefined&quot; || this._options.viewportMinimum === null ? this.dataInfo.viewPortMin : this._options.viewportMinimum;
			//max = typeof (this._options.viewportMaximum) === &quot;undefined&quot; || this._options.viewportMaximum === null ? this.dataInfo.viewPortMax : this._options.viewportMaximum;
			min = (this.viewportMinimum !== null) ? this.viewportMinimum : this.dataInfo.viewPortMin;
			max = (this.viewportMaximum !== null) ? this.viewportMaximum : this.dataInfo.viewPortMax;

			if (!isFinite(min) &amp;&amp; !isFinite(max)) {
				max = typeof (this._options.interval) === &quot;undefined&quot; ? -Infinity : this._options.interval;
				min = 0;
			} else if (!isFinite(min)) {
				min = max;
			} else if (!isFinite(max)) {
				max = min;
			}

			if (min === 0 &amp;&amp; max === 0) {// When all dataPoints are zero
				max += 9;
				min = 0;
			}
			else if (max - min === 0) {// When there is only a single dataPoint or when all dataPoints have same Y Value
				rangePadding = Math.min(Math.abs(Math.abs(max) * .01), 5);
				max += rangePadding;
				min -= rangePadding;
			}
			else if (min &gt; max) {
				rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), 5);

				if (max &gt;= 0)
					min = max - rangePadding;
				else
					max = min + rangePadding;
			}
			else {

				rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), .05);

				if (max !== 0)
					max += rangePadding;
				if (min !== 0)
					min -= rangePadding;
			}

			if (this.dataInfo.minDiff !== Infinity)
				minDiff = this.dataInfo.minDiff;
			else if (max - min &gt; 1) {
				minDiff = Math.abs(max - min) * .5;
			}
			else {
				minDiff = 1;
			}


			//Apply includeZero
			if (this.includeZero &amp;&amp; (this.viewportMinimum === null || isNaN(this.viewportMinimum))) {
				if (min &gt; 0)
					min = 0;
			}

			if (this.includeZero &amp;&amp; (this.viewportMaximum === null || isNaN(this.viewportMaximum))) {
				if (max &lt; 0)
					max = 0;
			}
		}

		range = (isNaN(this.viewportMaximum) || this.viewportMaximum === null ? max : this.viewportMaximum) - (isNaN(this.viewportMinimum) || this.viewportMinimum === null ? min : this.viewportMinimum);

		if (this.type === &quot;axisX&quot; &amp;&amp; this.chart.plotInfo.axisXValueType === &quot;dateTime&quot;) {

			if (!this.intervalType) {

				if (range / (1 * 1) &lt;= noTicks) {
					this.interval = 1;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 2) &lt;= noTicks) {
					this.interval = 2;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 5) &lt;= noTicks) {
					this.interval = 5;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 10) &lt;= noTicks) {
					this.interval = 10;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 20) &lt;= noTicks) {
					this.interval = 20;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 50) &lt;= noTicks) {
					this.interval = 50;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 100) &lt;= noTicks) {
					this.interval = 100;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 200) &lt;= noTicks) {
					this.interval = 200;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 250) &lt;= noTicks) {
					this.interval = 250;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 300) &lt;= noTicks) {
					this.interval = 300;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 400) &lt;= noTicks) {
					this.interval = 400;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (1 * 500) &lt;= noTicks) {
					this.interval = 500;
					this.intervalType = &quot;millisecond&quot;;
				} else if (range / (constants.secondDuration * 1) &lt;= noTicks) {
					this.interval = 1;
					this.intervalType = &quot;second&quot;;
				} else if (range / (constants.secondDuration * 2) &lt;= noTicks) {
					this.interval = 2;
					this.intervalType = &quot;second&quot;;
				} else if (range / (constants.secondDuration * 5) &lt;= noTicks) {
					this.interval = 5;
					this.intervalType = &quot;second&quot;;
				} else if (range / (constants.secondDuration * 10) &lt;= noTicks) {
					this.interval = 10;
					this.intervalType = &quot;second&quot;;
				} else if (range / (constants.secondDuration * 15) &lt;= noTicks) {
					this.interval = 15;
					this.intervalType = &quot;second&quot;;
				} else if (range / (constants.secondDuration * 20) &lt;= noTicks) {
					this.interval = 20;
					this.intervalType = &quot;second&quot;;
				} else if (range / (constants.secondDuration * 30) &lt;= noTicks) {
					this.interval = 30;
					this.intervalType = &quot;second&quot;;
				} else if (range / (constants.minuteDuration * 1) &lt;= noTicks) {
					this.interval = 1;
					this.intervalType = &quot;minute&quot;;
				} else if (range / (constants.minuteDuration * 2) &lt;= noTicks) {
					this.interval = 2;
					this.intervalType = &quot;minute&quot;;
				} else if (range / (constants.minuteDuration * 5) &lt;= noTicks) {
					this.interval = 5;
					this.intervalType = &quot;minute&quot;;
				} else if (range / (constants.minuteDuration * 10) &lt;= noTicks) {
					this.interval = 10;
					this.intervalType = &quot;minute&quot;;
				} else if (range / (constants.minuteDuration * 15) &lt;= noTicks) {
					this.interval = 15;
					this.intervalType = &quot;minute&quot;;
				} else if (range / (constants.minuteDuration * 20) &lt;= noTicks) {
					this.interval = 20;
					this.intervalType = &quot;minute&quot;;
				} else if (range / (constants.minuteDuration * 30) &lt;= noTicks) {
					this.interval = 30;
					this.intervalType = &quot;minute&quot;;
				} else if (range / (constants.hourDuration * 1) &lt;= noTicks) {
					this.interval = 1;
					this.intervalType = &quot;hour&quot;;
				} else if (range / (constants.hourDuration * 2) &lt;= noTicks) {
					this.interval = 2;
					this.intervalType = &quot;hour&quot;;
				} else if (range / (constants.hourDuration * 3) &lt;= noTicks) {
					this.interval = 3;
					this.intervalType = &quot;hour&quot;;
				} else if (range / (constants.hourDuration * 6) &lt;= noTicks) {
					this.interval = 6;
					this.intervalType = &quot;hour&quot;;
				} else if (range / (constants.dayDuration * 1) &lt;= noTicks) {
					this.interval = 1;
					this.intervalType = &quot;day&quot;;
				} else if (range / (constants.dayDuration * 2) &lt;= noTicks) {
					this.interval = 2;
					this.intervalType = &quot;day&quot;;
				} else if (range / (constants.dayDuration * 4) &lt;= noTicks) {
					this.interval = 4;
					this.intervalType = &quot;day&quot;;
				} else if (range / (constants.weekDuration * 1) &lt;= noTicks) {
					this.interval = 1;
					this.intervalType = &quot;week&quot;;
				} else if (range / (constants.weekDuration * 2) &lt;= noTicks) {
					this.interval = 2;
					this.intervalType = &quot;week&quot;;
				} else if (range / (constants.weekDuration * 3) &lt;= noTicks) {
					this.interval = 3;
					this.intervalType = &quot;week&quot;;
				} else if (range / (constants.monthDuration * 1) &lt;= noTicks) {
					this.interval = 1;
					this.intervalType = &quot;month&quot;;
				} else if (range / (constants.monthDuration * 2) &lt;= noTicks) {
					this.interval = 2;
					this.intervalType = &quot;month&quot;;
				} else if (range / (constants.monthDuration * 3) &lt;= noTicks) {
					this.interval = 3;
					this.intervalType = &quot;month&quot;;
				} else if (range / (constants.monthDuration * 6) &lt;= noTicks) {
					this.interval = 6;
					this.intervalType = &quot;month&quot;;
				} else if (range / (constants.yearDuration * 1) &lt;= noTicks) {
					this.interval = 1;
					this.intervalType = &quot;year&quot;;
				} else if (range / (constants.yearDuration * 2) &lt;= noTicks) {
					this.interval = 2;
					this.intervalType = &quot;year&quot;;
				} else if (range / (constants.yearDuration * 4) &lt;= noTicks) {
					this.interval = 4;
					this.intervalType = &quot;year&quot;;
				} else {
					this.interval = Math.floor(Axis.getNiceNumber(range / (noTicks - 1), true) / constants.yearDuration);
					this.intervalType = &quot;year&quot;;
				}

			}

			if (this.viewportMinimum === null || isNaN(this.viewportMinimum))
				this.viewportMinimum = min - minDiff / 2;

			if (this.viewportMaximum === null || isNaN(this.viewportMaximum))
				this.viewportMaximum = max + minDiff / 2;


			if (isLessThanTwoDataPoints) {
				this.autoValueFormatString = &quot;MMM DD YYYY HH:mm&quot;;
			} else if (this.intervalType === &quot;year&quot;) {
				this.autoValueFormatString = &quot;YYYY&quot;;
			} else if (this.intervalType === &quot;month&quot;) {
				this.autoValueFormatString = &quot;MMM YYYY&quot;;
			} else if (this.intervalType === &quot;week&quot;) {
				this.autoValueFormatString = &quot;MMM DD YYYY&quot;;
			} else if (this.intervalType === &quot;day&quot;) {
				this.autoValueFormatString = &quot;MMM DD YYYY&quot;;
			} else if (this.intervalType === &quot;hour&quot;) {
				this.autoValueFormatString = &quot;hh:mm TT&quot;;
			} else if (this.intervalType === &quot;minute&quot;) {
				this.autoValueFormatString = &quot;hh:mm TT&quot;;
			} else if (this.intervalType === &quot;second&quot;) {
				this.autoValueFormatString = &quot;hh:mm:ss TT&quot;;
			} else if (this.intervalType === &quot;millisecond&quot;) {
				this.autoValueFormatString = &quot;fff&#x27;ms&#x27;&quot;;
			}

			if (!this.valueFormatString) {
				this.valueFormatString = this.autoValueFormatString;
			}

		} else {

			this.intervalType = &quot;number&quot;;

			range = Axis.getNiceNumber(range, false);

			if (this._options &amp;&amp; this._options.interval &gt; 0)
				this.interval = this._options.interval;
			else {
				this.interval = Axis.getNiceNumber(range / (noTicks - 1), true);
			}
			//if (this.labelAutoFit) {
			//	this.interval = Axis.getNiceNumber(range / (noTicks - 1), true);
			//	this.interval = this._options.interval ? this._options.interval &lt; this.interval ? this.interval : this._options.interval : this.interval ;
			//}

			if (this.viewportMinimum === null || isNaN(this.viewportMinimum)) {
				if (this.type === &quot;axisX&quot;)
					this.viewportMinimum = min - minDiff / 2;
				else
					this.viewportMinimum = Math.floor(min / this.interval) * this.interval;
			}

			if (this.viewportMaximum === null || isNaN(this.viewportMaximum)) {
				if (this.type === &quot;axisX&quot;)
					this.viewportMaximum = max + minDiff / 2;
				else
					this.viewportMaximum = Math.ceil(max / this.interval) * this.interval;
			}

			if (this.viewportMaximum === 0 &amp;&amp; this.viewportMinimum === 0) {

				if (this._options.viewportMinimum === 0) {
					this.viewportMaximum += 10;
				}
				else if (this._options.viewportMaximum === 0) {
					this.viewportMinimum -= 10;
				}

				if (this._options &amp;&amp; typeof (this._options.interval) === &quot;undefined&quot;) {
					this.interval = Axis.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (noTicks - 1), true);
				}
			}
		}

		//Calculate minimum and maximum if not provided by the user
		if (this.minimum === null || this.maximum === null) {
			if (this.type === &quot;axisX&quot;) {
				min = (this.minimum !== null) ? this.minimum : this.dataInfo.min;
				max = (this.maximum !== null) ? this.maximum : this.dataInfo.max;

				if (max - min === 0) {
					rangePadding = typeof (this._options.interval) === &quot;undefined&quot; ? .4 : this._options.interval;

					max += rangePadding;
					min -= rangePadding;
				}

				if (this.dataInfo.minDiff !== Infinity)
					minDiff = this.dataInfo.minDiff;
				else if (max - min &gt; 1) {
					minDiff = Math.abs(max - min) * .5;
				}
				else {
					minDiff = 1;
				}

			} else if (this.type === &quot;axisY&quot;) {

				min = (this.minimum !== null) ? this.minimum : this.dataInfo.min;
				max = (this.maximum !== null) ? this.maximum : this.dataInfo.max;

				if (!isFinite(min) &amp;&amp; !isFinite(max)) {
					max = typeof (this._options.interval) === &quot;undefined&quot; ? -Infinity : this._options.interval;
					min = 0;
				}
				else
					if (min === 0 &amp;&amp; max === 0) {// When all dataPoints are zero
						max += 9;
						min = 0;
					}
					else if (max - min === 0) {// When there is only a single dataPoint or when all dataPoints have same Y Value
						rangePadding = Math.min(Math.abs(Math.abs(max) * .01), 5);
						max += rangePadding;
						min -= rangePadding;
					}
					else if (min &gt; max) {
						rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), 5);

						if (max &gt;= 0)
							min = max - rangePadding;
						else
							max = min + rangePadding;
					}
					else {

						rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), .05);

						if (max !== 0)
							max += rangePadding;
						if (min !== 0)
							min -= rangePadding;
					}

				if (this.dataInfo.minDiff !== Infinity)
					minDiff = this.dataInfo.minDiff;
				else if (max - min &gt; 1) {
					minDiff = Math.abs(max - min) * .5;
				}
				else {
					minDiff = 1;
				}


				//Apply includeZero
				if (this.includeZero &amp;&amp; (this.minimum === null || isNaN(this.minimum))) {
					if (min &gt; 0)
						min = 0;
				}

				if (this.includeZero &amp;&amp; (this.maximum === null || isNaN(this.maximum))) {
					if (max &lt; 0)
						max = 0;
				}
			}

			range = max - min;

			if (this.type === &quot;axisX&quot; &amp;&amp; this.chart.plotInfo.axisXValueType === &quot;dateTime&quot;) {

				if (this.minimum === null || isNaN(this.minimum))
					this.minimum = min - minDiff / 2;

				if (this.maximum === null || isNaN(this.maximum))
					this.maximum = max + minDiff / 2;

			} else {

				this.intervalType = &quot;number&quot;;

				if (this.minimum === null) {
					if (this.type === &quot;axisX&quot;)
						this.minimum = min - minDiff / 2;
					else
						this.minimum = Math.floor(min / this.interval) * this.interval;

					this.minimum = Math.min(this.minimum, this.sessionVariables.viewportMinimum === null || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum);
				}

				if (this.maximum === null) {
					if (this.type === &quot;axisX&quot;)
						this.maximum = max + minDiff / 2;
					else
						this.maximum = Math.ceil(max / this.interval) * this.interval;

					this.maximum = Math.max(this.maximum, this.sessionVariables.viewportMaximum === null || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum);
				}

				//var nfrac = Math.max(-Math.floor(Math.log(d)/Math.LN10), 0); //number of fractional digits to show


				if (this.maximum === 0 &amp;&amp; this.minimum === 0) {

					if (this._options.minimum === 0) {
						this.maximum += 10;
					}
					else if (this._options.maximum === 0) {
						this.minimum -= 10;
					}
				}
			}
		}

		this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);
		this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);

		if (this.type === &quot;axisX&quot; &amp;&amp; this.chart.plotInfo.axisXValueType === &quot;dateTime&quot;)
			this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval);
		else
			this.intervalStartPosition = Math.floor((this.viewportMinimum + (this.interval * .2)) / this.interval) * this.interval;

		//Set valueFormatString
		if (!this.valueFormatString) {
			this.valueFormatString = &quot;#,##0.##&quot;;

			range = Math.abs(this.viewportMaximum - this.viewportMinimum);

			if (range &lt; 1) {
				var numberOfDecimals = Math.floor(Math.abs(Math.log(range) / Math.LN10)) + 2;

				if (isNaN(numberOfDecimals) || !isFinite(numberOfDecimals))
					numberOfDecimals = 2;

				if (numberOfDecimals &gt; 2) {
					for (var i = 0; i &lt; numberOfDecimals - 2; i++)
						this.valueFormatString += &quot;#&quot;;
				}
			}

		}

		//if (isDebugMode &amp;&amp; window.console) {
		//    window.console.log(this.type + &quot;: Min = &quot; + this.viewportMinimum);
		//    window.console.log(this.type + &quot;: Max = &quot; + this.viewportMaximum);
		//    window.console.log(this.type + &quot;: Interval = &quot; + this.interval);
		//}
	}

	Axis.getNiceNumber = function (x, round) {

		var exp = Math.floor(Math.log(x) / Math.LN10);
		var f = x / Math.pow(10, exp);
		var nf;

		if (round) {
			if (f &lt; 1.5)
				nf = 1;
			else if (f &lt; 3)
				nf = 2;
			else if (f &lt; 7)
				nf = 5;
			else
				nf = 10;
		}
		else {
			if (f &lt;= 1)
				nf = 1;
			else if (f &lt;= 2)
				nf = 2;
			else if (f &lt;= 5)
				nf = 5;
			else nf = 10;
		}

		return Number((nf * Math.pow(10, exp)).toFixed(20));
	}

	Axis.prototype.getLabelStartPoint = function () {

		var intervalInMilliseconds = convertToNumber(this.interval, this.intervalType);
		var minimum = Math.floor((this.viewportMinimum) / intervalInMilliseconds) * intervalInMilliseconds;
		var dateTime = new Date(minimum);

		if (this.intervalType === &quot;millisecond&quot;) {
			//millisecond = dateTime.getMilliSecond();
			//millisecond = Math.floor((millisecond + this.interval) / this.interval) * this.interval;
		}
		else if (this.intervalType === &quot;second&quot;) {
			if (dateTime.getMilliseconds() &gt; 0) {
				dateTime.setSeconds(dateTime.getSeconds() + 1);
				dateTime.setMilliseconds(0);
			}
		}
		else if (this.intervalType === &quot;minute&quot;) {
			if (dateTime.getSeconds() &gt; 0 || dateTime.getMilliseconds() &gt; 0) {
				dateTime.setMinutes(dateTime.getMinutes() + 1);
				dateTime.setSeconds(0);
				dateTime.setMilliseconds(0);
			}
		}
		else if (this.intervalType === &quot;hour&quot;) {
			if (dateTime.getMinutes() &gt; 0 || dateTime.getSeconds() &gt; 0 || dateTime.getMilliseconds() &gt; 0) {
				dateTime.setHours(dateTime.getHours() + 1);
				dateTime.setMinutes(0);
				dateTime.setSeconds(0);
				dateTime.setMilliseconds(0);
			}
		}
		else if (this.intervalType === &quot;day&quot;) {
			if (dateTime.getHours() &gt; 0 || dateTime.getMinutes() &gt; 0 || dateTime.getSeconds() &gt; 0 || dateTime.getMilliseconds() &gt; 0) {
				dateTime.setDate(dateTime.getDate() + 1);
				dateTime.setHours(0);
				dateTime.setMinutes(0);
				dateTime.setSeconds(0);
				dateTime.setMilliseconds(0);
			}
		}
		else if (this.intervalType === &quot;week&quot;) {
			if (dateTime.getDay() &gt; 0 || dateTime.getHours() &gt; 0 || dateTime.getMinutes() &gt; 0 || dateTime.getSeconds() &gt; 0 || dateTime.getMilliseconds() &gt; 0) {
				dateTime.setDate(dateTime.getDate() + (7 - dateTime.getDay()));
				dateTime.setHours(0);
				dateTime.setMinutes(0);
				dateTime.setSeconds(0);
				dateTime.setMilliseconds(0);
			}
		}
		else if (this.intervalType === &quot;month&quot;) {
			if (dateTime.getDate() &gt; 1 || dateTime.getHours() &gt; 0 || dateTime.getMinutes() &gt; 0 || dateTime.getSeconds() &gt; 0 || dateTime.getMilliseconds() &gt; 0) {
				dateTime.setMonth(dateTime.getMonth() + 1);
				dateTime.setDate(1);
				dateTime.setHours(0);
				dateTime.setMinutes(0);
				dateTime.setSeconds(0);
				dateTime.setMilliseconds(0);
			}
		}
		else if (this.intervalType === &quot;year&quot;) {
			if (dateTime.getMonth() &gt; 0 || dateTime.getDate() &gt; 1 || dateTime.getHours() &gt; 0 || dateTime.getMinutes() &gt; 0 || dateTime.getSeconds() &gt; 0 || dateTime.getMilliseconds() &gt; 0) {
				dateTime.setFullYear(dateTime.getFullYear() + 1);
				dateTime.setMonth(0);
				dateTime.setDate(1);
				dateTime.setHours(0);
				dateTime.setMinutes(0);
				dateTime.setSeconds(0);
				dateTime.setMilliseconds(0);
			}
		}

		return dateTime;
	}

	//#endregion Axis

	//#region StripLine

	function StripLine(chart, options, theme, id, axis) {
		StripLine.base.constructor.call(this, &quot;StripLine&quot;, options, theme, axis);


		this.id = id;
		this.chart = chart;
		this.ctx = this.chart.ctx;

		this.label = this.label;

		this._thicknessType = &quot;pixel&quot;;
		if (this.startValue !== null &amp;&amp; this.endValue !== null) {

			this.value = ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2;
			this.thickness = Math.max(this.endValue - this.startValue);
			this._thicknessType = &quot;value&quot;;
		}
	}
	extend(StripLine, CanvasJSObject);

	StripLine.prototype.render = function () {

		this.ctx.save();
		//this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
		//this.ctx.clip();

		var xy = this.parent.getPixelCoordinatesOnAxis(this.value);

		var lineWidth = Math.abs(this._thicknessType === &quot;pixel&quot; ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness);

		if (lineWidth &gt; 0) {
			//var opacity = this.opacity === null ? ( this.showOnTop &amp;&amp; this._thicknessType === &quot;pixel&quot; ? 1 : 1) : this.opacity;
			var opacity = this.opacity === null ? 1 : this.opacity;

			this.ctx.strokeStyle = this.color;
			this.ctx.beginPath();

			var oldGlobalAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = opacity;

			var hexColor = intToHexColorString(this.id);
			var x1, x2, y1, y2;

			this.ctx.lineWidth = lineWidth;


			if (this.ctx.setLineDash) {
				this.ctx.setLineDash(getLineDashArray(this.lineDashType, lineWidth));
			}

			if (this.parent._position === &quot;bottom&quot; || this.parent._position === &quot;top&quot;) {

				var stripX = (this.ctx.lineWidth % 2 === 1) ? (xy.x &lt;&lt; 0) + .5 : (xy.x &lt;&lt; 0);

				x1 = x2 = stripX;
				y1 = this.chart.plotArea.y1;
				y2 = this.chart.plotArea.y2;
			}
			else if (this.parent._position === &quot;left&quot; || this.parent._position === &quot;right&quot;) {
				var stripY = (this.ctx.lineWidth % 2 === 1) ? (xy.y &lt;&lt; 0) + .5 : (xy.y &lt;&lt; 0);

				y1 = y2 = stripY;
				x1 = this.chart.plotArea.x1;
				x2 = this.chart.plotArea.x2;
			}

			this.ctx.moveTo(x1, y1);
			this.ctx.lineTo(x2, y2);
			this.ctx.stroke();

			this.ctx.globalAlpha = oldGlobalAlpha;
		}
		this.ctx.restore();
	};

	//#endregion StripLine

	//#region ToolTip

	function ToolTip(chart, options, theme) {
		ToolTip.base.constructor.call(this, &quot;ToolTip&quot;, options, theme);

		this.chart = chart;
		this.canvas = chart.canvas;
		this.ctx = this.chart.ctx;
		this.currentSeriesIndex = -1;
		this.currentDataPointIndex = -1;
		this._timerId = 0;
		this._prevX = NaN;
		this._prevY = NaN;

		this._initialize();
	}
	extend(ToolTip, CanvasJSObject);

	ToolTip.prototype._initialize = function () {

		if (this.enabled) {
			this.container = document.createElement(&quot;div&quot;);
			this.container.setAttribute(&quot;class&quot;, &quot;canvasjs-chart-tooltip&quot;);
			this.container.style.position = &quot;absolute&quot;;
			this.container.style.height = &quot;auto&quot;;
			this.container.style.boxShadow = &quot;1px 1px 2px 2px rgba(0,0,0,0.1)&quot;;
			this.container.style.zIndex = &quot;1000&quot;;
			//this.container.style.pointerEvents = &quot;none&quot;;
			this.container.style.display = &quot;none&quot;;
			//this.container.style.whiteSpace = &quot;no-wrap&quot;;

			var toolTipHtml = &quot;&lt;div style=\&quot; width: auto;&quot;;
			toolTipHtml += &quot;height: auto;&quot;;
			toolTipHtml += &quot;min-width: 50px;&quot;;
			toolTipHtml += &quot;line-height: auto;&quot;;
			toolTipHtml += &quot;margin: 0px 0px 0px 0px;&quot;;
			toolTipHtml += &quot;padding: 5px;&quot;;
			toolTipHtml += &quot;font-family: Calibri, Arial, Georgia, serif;&quot;;
			toolTipHtml += &quot;font-weight: normal;&quot;;
			toolTipHtml += &quot;font-style: &quot; + (isCanvasSupported ? &quot;italic;&quot; : &quot;normal;&quot;);
			toolTipHtml += &quot;font-size: 14px;&quot;;
			toolTipHtml += &quot;color: #000000;&quot;;
			toolTipHtml += &quot;text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);&quot;;
			toolTipHtml += &quot;text-align: left;&quot;;
			toolTipHtml += &quot;border: 2px solid gray;&quot;;

			//Older browsers like IE8- don&#x27;t support alpha values
			toolTipHtml += isCanvasSupported ? &quot;background: rgba(255,255,255,.9);&quot; : &quot;background: rgb(255,255,255);&quot;;

			toolTipHtml += &quot;text-indent: 0px;&quot;;
			toolTipHtml += &quot;white-space: nowrap;&quot;;
			//toolTipHtml += &quot;pointer-events:none;&quot;;
			toolTipHtml += &quot;border-radius: 5px;&quot;;

			//Disable Text Selection
			toolTipHtml += &quot;-moz-user-select:none;&quot;;
			toolTipHtml += &quot;-khtml-user-select: none;&quot;;
			toolTipHtml += &quot;-webkit-user-select: none;&quot;;
			toolTipHtml += &quot;-ms-user-select: none;&quot;;
			toolTipHtml += &quot;user-select: none;&quot;;

			//toolTipHtml += &quot;opacity: 0;&quot;;
			//toolTipHtml += &quot;filter: progid: DXImageTransform.Microsoft.gradient(GradientType = 0, startColorstr = &#x27;#4cffffff&#x27;, endColorstr = &#x27;#4cffffff&#x27;);&quot;;

			if (!isCanvasSupported) {
				//toolTipHtml += &quot;-ms-filter:&#x27;progid:DXImageTransform.Microsoft.Alpha(Opacity=90)&#x27;&quot;;
				//-ms-filter: &quot;progid:DXImageTransform.Microsoft.Shadow(Strength=4, Direction=135, Color=&#x27;#000000&#x27;)&quot;;
				/* For IE 5.5 - 7 */
				toolTipHtml += &quot;filter: alpha(opacity = 90);&quot;;
				toolTipHtml += &quot;filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color=&#x27;#666666&#x27;);&quot;;
			}

			toolTipHtml += &quot;} \&quot;&gt; Sample Tooltip&lt;/div&gt;&quot;;

			this.container.innerHTML = toolTipHtml;
			this.contentDiv = this.container.firstChild;


			this.container.style.borderRadius = this.contentDiv.style.borderRadius;
			this.chart._canvasJSContainer.appendChild(this.container);
		}
	}

	ToolTip.prototype.mouseMoveHandler = function (x, y) {

		if (!(this._lastUpdated &amp;&amp; (new Date().getTime() - this._lastUpdated) &lt; 40)) {
			this._lastUpdated = new Date().getTime();
			this._updateToolTip(x, y);
		}
	}

	ToolTip.prototype._updateToolTip = function (mouseX, mouseY) {
		//return;

		if (this.chart.disableToolTip) // Disabled during animation, etc
			return;

		if (typeof (mouseX) === &quot;undefined&quot; || typeof (mouseY) === &quot;undefined&quot;) {
			if (isNaN(this._prevX) || isNaN(this._prevY))
				return;
			else {
				mouseX = this._prevX;
				mouseY = this._prevY;
			}
		} else {
			this._prevX = mouseX;
			this._prevY = mouseY;
		}


		var dataPoint = null;
		var dataSeries = null;
		var toolTipContent = &quot;&quot;;
		var entries = [];
		var toolTipRight;
		var toolTipBottom;
		var x = 0;

		if (this.shared &amp;&amp; this.enabled &amp;&amp; this.chart.plotInfo.axisPlacement !== &quot;none&quot;) {
			// &amp;&amp; this.chart.plotInfo.axisPlacement !== &quot;none&quot;
			if (this.chart.plotInfo.axisPlacement === &quot;xySwapped&quot;) {
				x = (this.chart.axisX.viewportMaximum - this.chart.axisX.viewportMinimum) / this.chart.axisX.lineCoordinates.height * ((this.chart.axisX.lineCoordinates.y2 - mouseY)) + this.chart.axisX.viewportMinimum;
			}
			else {
				x = (this.chart.axisX.viewportMaximum - this.chart.axisX.viewportMinimum) / this.chart.axisX.lineCoordinates.width * (mouseX - this.chart.axisX.lineCoordinates.x1) + this.chart.axisX.viewportMinimum;
			}

			var nearbyEntries = [];

			for (var i = 0; i &lt; this.chart.data.length; i++) {
				var entry = this.chart.data[i].getDataPointAtX(x, true);

				if (entry &amp;&amp; entry.index &gt;= 0) {
					entry.dataSeries = this.chart.data[i];

					if (entry.dataPoint.y !== null)
						nearbyEntries.push(entry);
				}
			}

			if (nearbyEntries.length === 0)
				return;

			nearbyEntries.sort(function (entry1, entry2) {
				return entry1.distance - entry2.distance;
			});


			var closest = nearbyEntries[0];

			for (i = 0; i &lt; nearbyEntries.length; i++) {

				if (nearbyEntries[i].dataPoint.x.valueOf() === closest.dataPoint.x.valueOf())
					entries.push(nearbyEntries[i]);
			}

			nearbyEntries = null;

		} else {

			var dataPointInfo = this.chart.getDataPointAtXY(mouseX, mouseY, true);
			//dataPointInfo = null;

			if (dataPointInfo) {
				this.currentDataPointIndex = dataPointInfo.dataPointIndex;
				this.currentSeriesIndex = dataPointInfo.dataSeries.index;
			} else if (isCanvasSupported) {

				var id = getObjectId(mouseX, mouseY, this.chart._eventManager.ghostCtx);
				if (id &gt; 0 &amp;&amp; typeof this.chart._eventManager.objectMap[id] !== &quot;undefined&quot;) {//DataPoint/DataSeries event
					var eventObject = this.chart._eventManager.objectMap[id];

					if (eventObject.objectType === &quot;legendItem&quot;)
						return;

					//if (this.currentSeriesIndex === eventObject.dataSeriesIndex &amp;&amp; this.currentDataPointIndex === eventObject.dataPointIndex)
					//  return;
					//else {
					this.currentSeriesIndex = eventObject.dataSeriesIndex;
					this.currentDataPointIndex = eventObject.dataPointIndex &gt;= 0 ? eventObject.dataPointIndex : -1;
					//}

					//window.console.log(&quot;id: &quot; + id + &quot;; hex: &quot; + intToHexColorString(id));
				} else
					this.currentDataPointIndex = -1;

			} else
				this.currentDataPointIndex = -1;


			if (this.currentSeriesIndex &gt;= 0) {

				dataSeries = this.chart.data[this.currentSeriesIndex];

				var entry = {
				};

				if (this.currentDataPointIndex &gt;= 0) {
					dataPoint = dataSeries.dataPoints[this.currentDataPointIndex];

					entry.dataSeries = dataSeries;
					entry.dataPoint = dataPoint;
					entry.index = this.currentDataPointIndex;
					entry.distance = Math.abs(dataPoint.x - x);
				} else if (this.enabled &amp;&amp; (dataSeries.type === &quot;line&quot; || dataSeries.type === &quot;stepLine&quot; || dataSeries.type === &quot;spline&quot; || dataSeries.type === &quot;area&quot; || dataSeries.type === &quot;stepArea&quot;
						|| dataSeries.type === &quot;splineArea&quot; || dataSeries.type === &quot;stackedArea&quot; || dataSeries.type === &quot;stackedArea100&quot;
						|| dataSeries.type === &quot;rangeArea&quot; || dataSeries.type === &quot;rangeSplineArea&quot;
						|| dataSeries.type === &quot;candlestick&quot; || dataSeries.type === &quot;ohlc&quot;)) {

					//var x = (this.chart.axisX.viewportMaximum - this.chart.axisX.viewportMinimum) / this.chart.axisX.lineCoordinates.width * (mouseX - this.chart.axisX.lineCoordinates.x1) + this.chart.axisX.viewportMinimum.valueOf();
					var x = dataSeries.axisX.conversionParameters.minimum + (mouseX - dataSeries.axisX.conversionParameters.reference) / dataSeries.axisX.conversionParameters.pixelPerUnit;


					entry = dataSeries.getDataPointAtX(x, true);
					entry.dataSeries = dataSeries;
					this.currentDataPointIndex = entry.index;
					dataPoint = entry.dataPoint;
				} else {
					//this.hide();
					return;
				}

				if (!isNullOrUndefined(entry.dataPoint.y)) {
					if (entry.dataSeries.axisY) {
						if (entry.dataPoint.y.length &gt; 0) {
							var unboundToViewport = 0;
							for (var i = 0; i &lt; entry.dataPoint.y.length; i++)
								if (entry.dataPoint.y[i] &lt; entry.dataSeries.axisY.viewportMinimum)
									unboundToViewport--;
								else if (entry.dataPoint.y[i] &gt; entry.dataSeries.axisY.viewportMaximum)
									unboundToViewport++;
							if (unboundToViewport &lt; entry.dataPoint.y.length &amp;&amp; unboundToViewport &gt; -entry.dataPoint.y.length)
								entries.push(entry);
						} else {
							if (dataSeries.type === &quot;column&quot; || dataSeries.type === &quot;bar&quot;) {
								if (entry.dataPoint.y &lt; 0 /*use entry.dataPoint.y &lt; offset when it will be introduced*/) {
									if (entry.dataSeries.axisY.viewportMinimum &lt; 0 &amp;&amp; entry.dataSeries.axisY.viewportMaximum &gt;= entry.dataPoint.y)
										entries.push(entry);
								}
								else if (entry.dataSeries.axisY.viewportMinimum &lt;= entry.dataPoint.y &amp;&amp; entry.dataSeries.axisY.viewportMaximum &gt;= 0) // If entry.dataPoint.y &gt;= 0
									entries.push(entry);
							}
							else if (dataSeries.type === &quot;bubble&quot;) {
								var radius = this.chart._eventManager.objectMap[dataSeries.dataPointIds[entry.index]].size / 2;
								if (entry.dataPoint.y &gt;= entry.dataSeries.axisY.viewportMinimum - radius &amp;&amp; entry.dataPoint.y &lt;= entry.dataSeries.axisY.viewportMaximum + radius)
									entries.push(entry);
							}
							else if (entry.dataSeries.type.indexOf(&quot;100&quot;) &gt;= 0 || dataSeries.type === &quot;stackedColumn&quot; || dataSeries.type === &quot;stackedBar&quot; || (entry.dataPoint.y &gt;= entry.dataSeries.axisY.viewportMinimum &amp;&amp; entry.dataPoint.y &lt;= entry.dataSeries.axisY.viewportMaximum))
								entries.push(entry);
						}
					} else
						entries.push(entry);
				}

			}
		}


		if (entries.length &gt; 0) {

			this.highlightObjects(entries);

			if (this.enabled) {

				var toolTipInnerHtml = &quot;&quot;;

				toolTipInnerHtml = this.getToolTipInnerHTML({ entries: entries });

				if (toolTipInnerHtml !== null) {
					this.contentDiv.innerHTML = toolTipInnerHtml;

					this.contentDiv.innerHTML = toolTipInnerHtml;

					var previouslyHidden = false;
					if (this.container.style.display === &quot;none&quot;) {
						previouslyHidden = true;
						this.container.style.display = &quot;block&quot;;
					}

					try {
						this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : isCanvasSupported ? &quot;rgba(255,255,255,.9)&quot; : &quot;rgb(255,255,255)&quot;;

						this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.borderColor ? this.borderColor : entries[0].dataPoint.color ? entries[0].dataPoint.color : entries[0].dataSeries.color ? entries[0].dataSeries.color : entries[0].dataSeries._colorSet[entries[0].index % entries[0].dataSeries._colorSet.length];

						this.contentDiv.style.borderWidth = (this.borderThickness || this.borderThickness === 0) ? this.borderThickness + &quot;px&quot; : 2 + &quot;px&quot;;

						this.contentDiv.style.borderRadius = (this.cornerRadius || this.cornerRadius === 0) ? this.cornerRadius + &quot;px&quot; : 5 + &quot;px&quot;;
						this.container.style.borderRadius = this.contentDiv.style.borderRadius;


						this.contentDiv.style.fontSize = (this.fontSize || this.fontSize === 0) ? this.fontSize + &quot;px&quot; : 14 + &quot;px&quot;;
						this.contentDiv.style.color = this.fontColor ? this.fontColor : &quot;#000000&quot;;
						this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : &quot;Calibri, Arial, Georgia, serif;&quot;;
						this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : &quot;normal&quot;;
						this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : isCanvasSupported ? &quot;italic&quot; : &quot;normal&quot;;

					} catch (e) {
					}
					var toolTipLeft;
					if (entries[0].dataSeries.type === &quot;pie&quot; || entries[0].dataSeries.type === &quot;doughnut&quot; || entries[0].dataSeries.type === &quot;funnel&quot; || entries[0].dataSeries.type === &quot;bar&quot; || entries[0].dataSeries.type === &quot;rangeBar&quot; || entries[0].dataSeries.type === &quot;stackedBar&quot; || entries[0].dataSeries.type === &quot;stackedBar100&quot;) {
						toolTipLeft = mouseX - 10 - this.container.clientWidth;
					} else {
						//toolTipLeft = (((this.chart.axisX.lineCoordinates.width / Math.abs(this.chart.axisX.viewportMaximum - this.chart.axisX.viewportMinimum)) * Math.abs(entries[0].dataPoint.x - this.chart.axisX.viewportMinimum)) + this.chart.axisX.lineCoordinates.x1 + .5) - this.container.clientWidth &lt;&lt; 0;
						toolTipLeft = entries[0].dataSeries.axisX.conversionParameters.reference + entries[0].dataSeries.axisX.conversionParameters.pixelPerUnit * (entries[0].dataPoint.x - entries[0].dataSeries.axisX.conversionParameters.minimum) - this.container.clientWidth &lt;&lt; 0;
						toolTipLeft -= 10;
					}


					if (toolTipLeft &lt; 0) {
						toolTipLeft += this.container.clientWidth + 20;
					}

					if (toolTipLeft + this.container.clientWidth &gt; Math.max(this.chart._container.clientWidth, this.chart.width))
						toolTipLeft = Math.max(0, Math.max(this.chart._container.clientWidth, this.chart.width) - this.container.clientWidth);

					toolTipLeft += &quot;px&quot;;

					if (entries.length === 1 &amp;&amp; !this.shared &amp;&amp; (entries[0].dataSeries.type === &quot;line&quot; || entries[0].dataSeries.type === &quot;stepLine&quot; || entries[0].dataSeries.type === &quot;spline&quot; || entries[0].dataSeries.type === &quot;area&quot; || entries[0].dataSeries.type === &quot;stepArea&quot; || entries[0].dataSeries.type === &quot;splineArea&quot; || entries[0].dataSeries.type === &quot;stackedArea&quot; || entries[0].dataSeries.type === &quot;stackedArea100&quot;)) {
						//toolTipBottom = (entries[0].dataSeries.axisY.lineCoordinates.y2 - entries[0].dataSeries.axisY.lineCoordinates.height / Math.abs(entries[0].dataSeries.axisY.maximum - entries[0].dataSeries.axisY.viewportMinimum) * Math.abs(entries[0].dataPoint.y - entries[0].dataSeries.axisY.viewportMinimum) + .5) &lt;&lt; 0;
						toolTipBottom = entries[0].dataSeries.axisY.conversionParameters.reference + entries[0].dataSeries.axisY.conversionParameters.pixelPerUnit * (entries[0].dataPoint.y - entries[0].dataSeries.axisY.viewportMinimum) + .5 &lt;&lt; 0;
					} else if (entries[0].dataSeries.type === &quot;bar&quot; || entries[0].dataSeries.type === &quot;rangeBar&quot; || entries[0].dataSeries.type === &quot;stackedBar&quot; || entries[0].dataSeries.type === &quot;stackedBar100&quot;) {
						//toolTipBottom = (entries[0].dataSeries.axisX.lineCoordinates.y2 - entries[0].dataSeries.axisX.lineCoordinates.height / Math.abs(entries[0].dataSeries.axisX.maximum - entries[0].dataSeries.axisX.viewportMinimum) * Math.abs(entries[0].dataPoint.x - entries[0].dataSeries.axisX.viewportMinimum) + .5) &lt;&lt; 0;
						toolTipBottom = entries[0].dataSeries.axisX.conversionParameters.reference + entries[0].dataSeries.axisX.conversionParameters.pixelPerUnit * (entries[0].dataPoint.x - entries[0].dataSeries.axisX.viewportMinimum) + .5 &lt;&lt; 0;
					}
					else {
						toolTipBottom = mouseY;
					}

					toolTipBottom = (-toolTipBottom + 10);

					if (toolTipBottom + this.container.clientHeight + 5 &gt; 0) {
						toolTipBottom -= toolTipBottom + this.container.clientHeight + 5 - 0
					}

					toolTipBottom += &quot;px&quot;;

					//this.container.style.right = toolTipRight;
					this.container.style.left = toolTipLeft;
					this.container.style.bottom = toolTipBottom;

					if (!this.animationEnabled || previouslyHidden) {
						this.disableAnimation();
					}
					else
						this.enableAnimation();
				} else {
					this.hide(false);
				}

			}

			//if (isDebugMode)
			//  console.log(&quot;searchX: &quot; + x + &quot; x: &quot; + searchResult.dataPoint.x + &quot;; y: &quot; + searchResult.dataPoint.y + &quot;; distance: &quot; + searchResult.distance + &quot;; steps: &quot; + steps);
		}
	}


	ToolTip.prototype.highlightObjects = function (entries) {
		//if (!this.enabled)
		//	return;

		//this.chart.overlaidCanvasCtx.clearRect(0, 0, this.chart.overlaidCanvas.width, this.chart.overlaidCanvas.height);
		var overlaidCanvasCtx = this.chart.overlaidCanvasCtx;
		this.chart.resetOverlayedCanvas();

		overlaidCanvasCtx.clearRect(0, 0, this.chart.width, this.chart.height);
		overlaidCanvasCtx.save();


		var plotArea = this.chart.plotArea;
		var offset = 0;
		overlaidCanvasCtx.beginPath();
		overlaidCanvasCtx.rect(plotArea.x1, plotArea.y1, plotArea.x2 - plotArea.x1, plotArea.y2 - plotArea.y1);
		overlaidCanvasCtx.clip();


		for (var i = 0; i &lt; entries.length; i++) {

			var entry = entries[i];

			var eventObject = this.chart._eventManager.objectMap[entry.dataSeries.dataPointIds[entry.index]];

			if (!eventObject || !eventObject.objectType || eventObject.objectType !== &quot;dataPoint&quot;)
				continue;

			var dataSeries = this.chart.data[eventObject.dataSeriesIndex];
			var dataPoint = dataSeries.dataPoints[eventObject.dataPointIndex];
			var index = eventObject.dataPointIndex;

			if (dataPoint.highlightEnabled !== false &amp;&amp; (dataSeries.highlightEnabled === true || dataPoint.highlightEnabled === true)) {

				if (dataSeries.type === &quot;line&quot; || dataSeries.type === &quot;stepLine&quot; || dataSeries.type === &quot;spline&quot; || dataSeries.type === &quot;scatter&quot;
					|| dataSeries.type === &quot;area&quot; || dataSeries.type === &quot;stepArea&quot; || dataSeries.type === &quot;splineArea&quot;
					|| dataSeries.type === &quot;stackedArea&quot; || dataSeries.type === &quot;stackedArea100&quot;
					|| dataSeries.type === &quot;rangeArea&quot; || dataSeries.type === &quot;rangeSplineArea&quot;) {
					var markerProps = dataSeries.getMarkerProperties(index, eventObject.x1, eventObject.y1, this.chart.overlaidCanvasCtx);
					markerProps.size = Math.max(markerProps.size * 1.5 &lt;&lt; 0, 10);

					markerProps.borderColor = markerProps.borderColor || &quot;#FFFFFF&quot;;
					markerProps.borderThickness = markerProps.borderThickness || Math.ceil(markerProps.size * .1);

					//overlaidCanvasCtx.globalAlpha = .8;
					RenderHelper.drawMarkers([markerProps]);
					//overlaidCanvasCtx.globalAlpha = .8;

					if (typeof (eventObject.y2) !== &quot;undefined&quot;) {

						var markerProps = dataSeries.getMarkerProperties(index, eventObject.x1, eventObject.y2, this.chart.overlaidCanvasCtx);
						markerProps.size = Math.max(markerProps.size * 1.5 &lt;&lt; 0, 10);

						markerProps.borderColor = markerProps.borderColor || &quot;#FFFFFF&quot;;
						markerProps.borderThickness = markerProps.borderThickness || Math.ceil(markerProps.size * .1);

						//overlaidCanvasCtx.globalAlpha = .8;
						RenderHelper.drawMarkers([markerProps]);
						//overlaidCanvasCtx.globalAlpha = .8;
					}
				} else if (dataSeries.type === &quot;bubble&quot;) {
					var markerProps = dataSeries.getMarkerProperties(index, eventObject.x1, eventObject.y1, this.chart.overlaidCanvasCtx);
					markerProps.size = eventObject.size;
					markerProps.color = &quot;white&quot;;
					markerProps.borderColor = &quot;white&quot;;
					//markerProps.borderThickness = 2;
					overlaidCanvasCtx.globalAlpha = .3;
					RenderHelper.drawMarkers([markerProps]);
					overlaidCanvasCtx.globalAlpha = 1;
				} else if (dataSeries.type === &quot;column&quot; || dataSeries.type === &quot;stackedColumn&quot; || dataSeries.type === &quot;stackedColumn100&quot;
					|| dataSeries.type === &quot;bar&quot; || dataSeries.type === &quot;rangeBar&quot; || dataSeries.type === &quot;stackedBar&quot; || dataSeries.type === &quot;stackedBar100&quot;
					|| dataSeries.type === &quot;rangeColumn&quot;) {
					drawRect(overlaidCanvasCtx, eventObject.x1, eventObject.y1, eventObject.x2, eventObject.y2, &quot;white&quot;, 0, null, false, false, false, false, .3);
				}
				else if (dataSeries.type === &quot;pie&quot; || dataSeries.type === &quot;doughnut&quot;) {
					drawSegment(overlaidCanvasCtx, eventObject.center, eventObject.radius, &quot;white&quot;, dataSeries.type, eventObject.startAngle, eventObject.endAngle, .3, eventObject.percentInnerRadius);
				} else if (dataSeries.type === &quot;candlestick&quot;) {

					overlaidCanvasCtx.globalAlpha = 1;
					overlaidCanvasCtx.strokeStyle = eventObject.color;
					overlaidCanvasCtx.lineWidth = eventObject.borderThickness * 2;
					offset = (overlaidCanvasCtx.lineWidth) % 2 === 0 ? 0 : .5;

					overlaidCanvasCtx.beginPath();
					overlaidCanvasCtx.moveTo(eventObject.x3 - offset, eventObject.y2);
					overlaidCanvasCtx.lineTo(eventObject.x3 - offset, Math.min(eventObject.y1, eventObject.y4));
					overlaidCanvasCtx.stroke();

					overlaidCanvasCtx.beginPath();
					overlaidCanvasCtx.moveTo(eventObject.x3 - offset, Math.max(eventObject.y1, eventObject.y4));
					overlaidCanvasCtx.lineTo(eventObject.x3 - offset, eventObject.y3);
					overlaidCanvasCtx.stroke();

					drawRect(overlaidCanvasCtx, eventObject.x1, Math.min(eventObject.y1, eventObject.y4), eventObject.x2, Math.max(eventObject.y1, eventObject.y4), &quot;transparent&quot;, eventObject.borderThickness * 2, eventObject.color, false, false, false, false);
					overlaidCanvasCtx.globalAlpha = 1;

				} else if (dataSeries.type === &quot;ohlc&quot;) {
					overlaidCanvasCtx.globalAlpha = 1;

					overlaidCanvasCtx.strokeStyle = eventObject.color;
					overlaidCanvasCtx.lineWidth = eventObject.borderThickness * 2;

					offset = (overlaidCanvasCtx.lineWidth) % 2 === 0 ? 0 : .5;

					overlaidCanvasCtx.beginPath();
					overlaidCanvasCtx.moveTo(eventObject.x3 - offset, eventObject.y2);
					overlaidCanvasCtx.lineTo(eventObject.x3 - offset, eventObject.y3);
					overlaidCanvasCtx.stroke();

					overlaidCanvasCtx.beginPath();
					overlaidCanvasCtx.moveTo(eventObject.x3, eventObject.y1);
					overlaidCanvasCtx.lineTo(eventObject.x1, eventObject.y1);
					overlaidCanvasCtx.stroke();

					overlaidCanvasCtx.beginPath();
					overlaidCanvasCtx.moveTo(eventObject.x3, eventObject.y4);
					overlaidCanvasCtx.lineTo(eventObject.x2, eventObject.y4);
					overlaidCanvasCtx.stroke();

					overlaidCanvasCtx.globalAlpha = 1;

				}
			}
		}

		overlaidCanvasCtx.restore();
		overlaidCanvasCtx.globalAlpha = 1;
		overlaidCanvasCtx.beginPath();

		return;
	}

	ToolTip.prototype.getToolTipInnerHTML = function (e) {
		var entries = e.entries;
		var toolTipInnerHtml = null;
		var dataSeries = null;
		var dataPoint = null;
		var index = 0;
		var color = null;
		var toolTipContent = &quot;&quot;;

		var isToolTipDefinedInData = true;
		for (var i = 0; i &lt; entries.length; i++) {
			if (entries[i].dataSeries.toolTipContent || entries[i].dataPoint.toolTipContent) {
				isToolTipDefinedInData = false;
				break;
			}
		}

		if (isToolTipDefinedInData &amp;&amp; ((this.content &amp;&amp; typeof (this.content) === &quot;function&quot;) || this.contentFormatter)) {

			var param = {
				chart: this.chart._publicChartReference, toolTip: this._options, entries: entries
			};
			toolTipInnerHtml = this.contentFormatter ? this.contentFormatter(param) : this.content(param);

		} else {

			if (this.shared &amp;&amp; this.chart.plotInfo.axisPlacement !== &quot;none&quot;) {

				var toolTipInnerHtmlPrefix = &quot;&quot;;

				for (var i = 0; i &lt; entries.length; i++) {
					dataSeries = entries[i].dataSeries;
					dataPoint = entries[i].dataPoint;
					index = entries[i].index;

					toolTipContent = &quot;&quot;;

					if (i === 0 &amp;&amp; isToolTipDefinedInData &amp;&amp; !this.content) {
						toolTipInnerHtmlPrefix += typeof (this.chart.axisX.labels[dataPoint.x]) !== &quot;undefined&quot; ? this.chart.axisX.labels[dataPoint.x] : &quot;{x}&quot;;
						toolTipInnerHtmlPrefix += &quot;&lt;/br&gt;&quot;;
						toolTipInnerHtmlPrefix = this.chart.replaceKeywordsWithValue(toolTipInnerHtmlPrefix, dataPoint, dataSeries, index);
					}

					//Allows disabling of toolTip for individual dataPoints/dataSeries
					if (dataPoint.toolTipContent === null || (typeof (dataPoint.toolTipContent) === &quot;undefined&quot; &amp;&amp; dataSeries._options.toolTipContent === null))
						continue;


					if (dataSeries.type === &quot;line&quot; || dataSeries.type === &quot;stepLine&quot; || dataSeries.type === &quot;spline&quot; || dataSeries.type === &quot;area&quot; || dataSeries.type === &quot;stepArea&quot; || dataSeries.type === &quot;splineArea&quot; || dataSeries.type === &quot;column&quot; || dataSeries.type === &quot;bar&quot; || dataSeries.type === &quot;scatter&quot;
					|| dataSeries.type === &quot;stackedColumn&quot; || dataSeries.type === &quot;stackedColumn100&quot; || dataSeries.type === &quot;stackedBar&quot; || dataSeries.type === &quot;stackedBar100&quot;
					|| dataSeries.type === &quot;stackedArea&quot; || dataSeries.type === &quot;stackedArea100&quot;) {
						toolTipContent += dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content &amp;&amp; typeof (this.content) !== &quot;function&quot; ? this.content : &quot;&lt;span style=&#x27;\&quot;&quot; + (this.fontColor ? &quot;&quot; : &quot;&#x27;color:{color};&#x27;&quot;) + &quot;\&quot;&#x27;&gt;{name}:&lt;/span&gt;&amp;nbsp;&amp;nbsp;{y}&quot;;
					}
					else if (dataSeries.type === &quot;bubble&quot;) {
						toolTipContent += dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content &amp;&amp; typeof (this.content) !== &quot;function&quot; ? this.content : &quot;&lt;span style=&#x27;\&quot;&quot; + (this.fontColor ? &quot;&quot; : &quot;&#x27;color:{color};&#x27;&quot;) + &quot;\&quot;&#x27;&gt;{name}:&lt;/span&gt;&amp;nbsp;&amp;nbsp;{y}, &amp;nbsp;&amp;nbsp;{z}&quot;;
					} else if (dataSeries.type === &quot;rangeColumn&quot; || dataSeries.type === &quot;rangeBar&quot; || dataSeries.type === &quot;rangeArea&quot; || dataSeries.type === &quot;rangeSplineArea&quot;) {
						toolTipContent += dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content &amp;&amp; typeof (this.content) !== &quot;function&quot; ? this.content : &quot;&lt;span style=&#x27;\&quot;&quot; + (this.fontColor ? &quot;&quot; : &quot;&#x27;color:{color};&#x27;&quot;) + &quot;\&quot;&#x27;&gt;{name}:&lt;/span&gt;&amp;nbsp;&amp;nbsp;{y[0]},&amp;nbsp;{y[1]}&quot;;
					} else if (dataSeries.type === &quot;candlestick&quot; || dataSeries.type === &quot;ohlc&quot;) {
						toolTipContent += dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content &amp;&amp; typeof (this.content) !== &quot;function&quot; ? this.content : &quot;&lt;span style=&#x27;\&quot;&quot; + (this.fontColor ? &quot;&quot; : &quot;&#x27;color:{color};&#x27;&quot;) + &quot;\&quot;&#x27;&gt;{name}:&lt;/span&gt;&quot;
										+ &quot;&lt;br/&gt;Open: &amp;nbsp;&amp;nbsp;{y[0]}&quot;
										+ &quot;&lt;br/&gt;High: &amp;nbsp;&amp;nbsp;&amp;nbsp;{y[1]}&quot;
										+ &quot;&lt;br/&gt;Low:&amp;nbsp;&amp;nbsp;&amp;nbsp;{y[2]}&quot;
										+ &quot;&lt;br/&gt;Close: &amp;nbsp;&amp;nbsp;{y[3]}&quot;;
					}

					if (toolTipInnerHtml === null)
						toolTipInnerHtml = &quot;&quot;;


					if (this.reversed === true) {

						toolTipInnerHtml = this.chart.replaceKeywordsWithValue(toolTipContent, dataPoint, dataSeries, index) + toolTipInnerHtml;

						if (i &lt; entries.length - 1)
							toolTipInnerHtml = &quot;&lt;/br&gt;&quot; + toolTipInnerHtml;

					} else {

						toolTipInnerHtml += this.chart.replaceKeywordsWithValue(toolTipContent, dataPoint, dataSeries, index);

						if (i &lt; entries.length - 1)
							toolTipInnerHtml += &quot;&lt;/br&gt;&quot;;

					}

				}

				if (toolTipInnerHtml !== null)
					toolTipInnerHtml = toolTipInnerHtmlPrefix + toolTipInnerHtml;

			} else {

				dataSeries = entries[0].dataSeries;
				dataPoint = entries[0].dataPoint;
				index = entries[0].index;

				//Allows disabling of toolTip for individual dataPoints/dataSeries
				if (dataPoint.toolTipContent === null || (typeof (dataPoint.toolTipContent) === &quot;undefined&quot; &amp;&amp; dataSeries._options.toolTipContent === null))
					return null;


				if (dataSeries.type === &quot;line&quot; || dataSeries.type === &quot;stepLine&quot; || dataSeries.type === &quot;spline&quot; || dataSeries.type === &quot;area&quot; || dataSeries.type === &quot;stepArea&quot; || dataSeries.type === &quot;splineArea&quot; || dataSeries.type === &quot;column&quot; || dataSeries.type === &quot;bar&quot; || dataSeries.type === &quot;scatter&quot;
					|| dataSeries.type === &quot;stackedColumn&quot; || dataSeries.type === &quot;stackedColumn100&quot; || dataSeries.type === &quot;stackedBar&quot; || dataSeries.type === &quot;stackedBar100&quot;
					|| dataSeries.type === &quot;stackedArea&quot; || dataSeries.type === &quot;stackedArea100&quot;) {
					toolTipContent = dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content &amp;&amp; typeof (this.content) !== &quot;function&quot; ? this.content : &quot;&lt;span style=&#x27;\&quot;&quot; + (this.fontColor ? &quot;&quot; : &quot;&#x27;color:{color};&#x27;&quot;) + &quot;\&quot;&#x27;&gt;&quot; + (dataPoint.label ? &quot;{label}&quot; : &quot;{x}&quot;) + &quot;:&lt;/span&gt;&amp;nbsp;&amp;nbsp;{y}&quot;;
				} else if (dataSeries.type === &quot;bubble&quot;) {
					toolTipContent = dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content &amp;&amp; typeof (this.content) !== &quot;function&quot; ? this.content : &quot;&lt;span style=&#x27;\&quot;&quot; + (this.fontColor ? &quot;&quot; : &quot;&#x27;color:{color};&#x27;&quot;) + &quot;\&quot;&#x27;&gt;&quot; + (dataPoint.label ? &quot;{label}&quot; : &quot;{x}&quot;) + &quot;:&lt;/span&gt;&amp;nbsp;&amp;nbsp;{y}, &amp;nbsp;&amp;nbsp;{z}&quot;;
				} else if (dataSeries.type === &quot;pie&quot; || dataSeries.type === &quot;doughnut&quot; || dataSeries.type === &quot;funnel&quot;) {
					toolTipContent = dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content &amp;&amp; typeof (this.content) !== &quot;function&quot; ? this.content : &quot;&lt;span style=&#x27;\&quot;&quot; + (this.fontColor ? &quot;&quot; : &quot;&#x27;color:{color};&#x27;&quot;) + &quot;\&quot;&#x27;&gt;&quot; + (dataPoint.name ? &quot;{name}:&lt;/span&gt;&amp;nbsp;&amp;nbsp;&quot; : dataPoint.label ? &quot;{label}:&lt;/span&gt;&amp;nbsp;&amp;nbsp;&quot; : &quot;&lt;/span&gt;&quot;) + &quot;{y}&quot;;
				} else if (dataSeries.type === &quot;rangeColumn&quot; || dataSeries.type === &quot;rangeBar&quot; || dataSeries.type === &quot;rangeArea&quot; || dataSeries.type === &quot;rangeSplineArea&quot;) {
					toolTipContent = dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content &amp;&amp; typeof (this.content) !== &quot;function&quot; ? this.content : &quot;&lt;span style=&#x27;\&quot;&quot; + (this.fontColor ? &quot;&quot; : &quot;&#x27;color:{color};&#x27;&quot;) + &quot;\&quot;&#x27;&gt;&quot; + (dataPoint.label ? &quot;{label}&quot; : &quot;{x}&quot;) + &quot; :&lt;/span&gt;&amp;nbsp;&amp;nbsp;{y[0]}, &amp;nbsp;{y[1]}&quot;;
				} else if (dataSeries.type === &quot;candlestick&quot; || dataSeries.type === &quot;ohlc&quot;) {
					toolTipContent = dataPoint.toolTipContent ? dataPoint.toolTipContent : dataSeries.toolTipContent ? dataSeries.toolTipContent : this.content &amp;&amp; typeof (this.content) !== &quot;function&quot; ? this.content : &quot;&lt;span style=&#x27;\&quot;&quot; + (this.fontColor ? &quot;&quot; : &quot;&#x27;color:{color};&#x27;&quot;) + &quot;\&quot;&#x27;&gt;&quot; + (dataPoint.label ? &quot;{label}&quot; : &quot;{x}&quot;) + &quot;&lt;/span&gt;&quot;
						+ &quot;&lt;br/&gt;Open: &amp;nbsp;&amp;nbsp;{y[0]}&quot;
						+ &quot;&lt;br/&gt;High: &amp;nbsp;&amp;nbsp;&amp;nbsp;{y[1]}&quot;
						+ &quot;&lt;br/&gt;Low: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{y[2]}&quot;
						+ &quot;&lt;br/&gt;Close: &amp;nbsp;&amp;nbsp;{y[3]}&quot;;
				}

				if (toolTipInnerHtml === null)
					toolTipInnerHtml = &quot;&quot;;

				toolTipInnerHtml += this.chart.replaceKeywordsWithValue(toolTipContent, dataPoint, dataSeries, index);
			}
		}

		return toolTipInnerHtml;
	}

	ToolTip.prototype.enableAnimation = function () {
		if (this.container.style.WebkitTransition)
			return;

		this.container.style.WebkitTransition = &quot;left .2s ease-out, bottom .2s ease-out&quot;;
		this.container.style.MozTransition = &quot;left .2s ease-out, bottom .2s ease-out&quot;;
		this.container.style.MsTransition = &quot;left .2s ease-out, bottom .2s ease-out&quot;;
		this.container.style.transition = &quot;left .2s ease-out, bottom .2s ease-out&quot;;
	}

	ToolTip.prototype.disableAnimation = function () {
		if (!this.container.style.WebkitTransition)
			return;

		this.container.style.WebkitTransition = &quot;&quot;;
		this.container.style.MozTransition = &quot;&quot;;
		this.container.style.MsTransition = &quot;&quot;;
		this.container.style.transition = &quot;&quot;;
	}

	ToolTip.prototype.hide = function (resetOverlayedCanvas) {
		if (!this.enabled)
			return;

		resetOverlayedCanvas = typeof (resetOverlayedCanvas) === &quot;undefined&quot; ? true : resetOverlayedCanvas;

		this.container.style.display = &quot;none&quot;;
		this.currentSeriesIndex = -1;
		this._prevX = NaN;
		this._prevY = NaN;
		//this.chart.overlaidCanvasCtx.clearRect(0, 0, this.chart.overlaidCanvas.width, this.chart.overlaidCanvas.height);
		if (resetOverlayedCanvas)
			this.chart.resetOverlayedCanvas();
	}

	Chart.prototype.getPercentAndTotal = function (ds, dp) {

		var dpX = null;
		var total = null;
		var percent = null;

		if (ds.type.indexOf(&quot;stacked&quot;) &gt;= 0) {
			total = 0;
			dpX = dp.x.getTime ? dp.x.getTime() : dp.x;
			if (dpX in ds.plotUnit.yTotals) {
				total = ds.plotUnit.yTotals[dpX];

				if (!isNaN(dp.y)) {
					if (total === 0)
						percent = 0;
					else
						percent = (dp.y / total) * 100;
				}
				else
					percent = 0;
			}
		} else if (ds.type === &quot;pie&quot; || ds.type === &quot;doughnut&quot;) {
			total = 0;
			for (i = 0; i &lt; ds.dataPoints.length; i++) {

				if (!isNaN(ds.dataPoints[i].y))
					total += ds.dataPoints[i].y;
			}

			if (!isNaN(dp.y))
				percent = (dp.y / total) * 100;
			else
				percent = 0;
		}

		return {
			percent: percent, total: total
		};
	}

	Chart.prototype.replaceKeywordsWithValue = function (str, dp, ds, dpIndex, indexKeywordValue) {
		//var regex = /\{\s*[a-zA-Z]+\s*\}|&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;/g;
		var regex = /\{.*?\}|&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;/g;
		var chart = this;
		indexKeywordValue = typeof (indexKeywordValue) === &quot;undefined&quot; ? 0 : indexKeywordValue;

		if ((ds.type.indexOf(&quot;stacked&quot;) &gt;= 0 || (ds.type === &quot;pie&quot; || ds.type === &quot;doughnut&quot;)) &amp;&amp; (str.indexOf(&quot;#percent&quot;) &gt;= 0 || str.indexOf(&quot;#total&quot;) &gt;= 0)) {
			var percent = &quot;#percent&quot;;
			var total = &quot;#total&quot;;
			var dpX = null;

			var percentAndTotal = this.getPercentAndTotal(ds, dp);

			total = isNaN(percentAndTotal.total) ? total : percentAndTotal.total;
			percent = isNaN(percentAndTotal.percent) ? percent : percentAndTotal.percent;

			do {
				var percentFormatString = &quot;&quot;;
				if (ds.percentFormatString)
					percentFormatString = ds.percentFormatString;
				else {
					percentFormatString = &quot;#,##0.&quot;;
					var numberOfDecimals = Math.max(Math.ceil(Math.log(1 / Math.abs(percent)) / Math.LN10), 2);

					if (isNaN(numberOfDecimals) || !isFinite(numberOfDecimals))
						numberOfDecimals = 2;

					for (var n = 0; n &lt; numberOfDecimals; n++) {
						percentFormatString += &quot;#&quot;;
					}
				}

				str = str.replace(&quot;#percent&quot;, numberFormat(percent, percentFormatString, chart._cultureInfo));
				str = str.replace(&quot;#total&quot;, numberFormat(total, ds.yValueFormatString ? ds.yValueFormatString : &quot;#,##0.########&quot;));
			} while (str.indexOf(&quot;#percent&quot;) &gt;= 0 || str.indexOf(&quot;#total&quot;) &gt;= 0);
		}


		var fcn = function ($0) {
			if (($0[0] === &quot;\&quot;&quot; &amp;&amp; $0[$0.length - 1] === &quot;\&quot;&quot;) || ($0[0] === &quot;\&#x27;&quot; &amp;&amp; $0[$0.length - 1] === &quot;\&#x27;&quot;))
				return $0.slice(1, $0.length - 1);

			var key = trimString($0.slice(1, $0.length - 1));
			key = key.replace(&quot;#index&quot;, indexKeywordValue);

			var index = null;

			try {
				var match = key.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
				if (match &amp;&amp; match.length &gt; 0) {
					index = trimString(match[2]);
					key = trimString(match[1]);
				}
			} catch (e) {
			};


			var obj = null;

			if (key === &quot;color&quot;) {
				return dp.color ? dp.color : ds.color ? ds.color : ds._colorSet[dpIndex % ds._colorSet.length];
			}

			if (dp.hasOwnProperty(key))
				obj = dp;
			else if (ds.hasOwnProperty(key))
				obj = ds;
			else return &quot;&quot;;

			var value = obj[key];
			if (index !== null)
				value = value[index];

			if (key === &quot;x&quot;) {
				if (chart.plotInfo.axisXValueType === &quot;dateTime&quot; || ds.xValueType === &quot;dateTime&quot; || (dp.x &amp;&amp; dp.x.getTime))
					return dateFormat(value, dp.xValueFormatString ? dp.xValueFormatString : ds.xValueFormatString ? ds.xValueFormatString : chart.axisX &amp;&amp; chart.axisX.autoValueFormatString ? chart.axisX.autoValueFormatString : &quot;DD MMM YY&quot;, chart._cultureInfo);
				else
					return numberFormat(value, dp.xValueFormatString ? dp.xValueFormatString : ds.xValueFormatString ? ds.xValueFormatString : &quot;#,##0.########&quot;, chart._cultureInfo);
			} else if (key === &quot;y&quot;)
				return numberFormat(value, dp.yValueFormatString ? dp.yValueFormatString : ds.yValueFormatString ? ds.yValueFormatString : &quot;#,##0.########&quot;, chart._cultureInfo);
			else if (key === &quot;z&quot;)
				return numberFormat(value, dp.zValueFormatString ? dp.zValueFormatString : ds.zValueFormatString ? ds.zValueFormatString : &quot;#,##0.########&quot;, chart._cultureInfo);
			else
				return value;
		}

		return str.replace(regex, fcn);
	}


	//#endregion ToolTip

	//#region Event Manager

	function EventManager(chart) {
		this.chart = chart;
		this.lastObjectId = 0;
		var _this = this;
		this.objectMap = [];
		this.rectangularRegionEventSubscriptions = [];
		this.previousDataPointEventObject = null;
		//this.previousDataSeriesEventObject = null;

		this.ghostCanvas = createCanvas(this.chart.width, this.chart.height);
		//this.ghostCanvas.width = this.chart.width;
		//this.ghostCanvas.height = this.chart.height;

		this.ghostCtx = this.ghostCanvas.getContext(&quot;2d&quot;);

		var eventHandler = function (ev) {
			_this.mouseEventHandler.call(_this, ev);
		};

		this.mouseoveredObjectMaps = [];
		//this.chart.canvas.addEventListener(&quot;mouseover&quot;, eventHandler);
		//this.chart.canvas.addEventListener(&quot;mousemove&quot;, eventHandler);
		//this.chart.canvas.addEventListener(&quot;mouseout&quot;, eventHandler);
		//this.chart.canvas.addEventListener(&quot;click&quot;, eventHandler);
	}

	EventManager.prototype.reset = function () {
		this.lastObjectId = 0;
		this.objectMap = [];
		this.rectangularRegionEventSubscriptions = [];
		this.previousDataPointEventObject = null;

		this.eventObjects = [];
		//this.ghostCanvas.width = this.chart.width;
		//this.ghostCanvas.height = this.chart.height;

		if (isCanvasSupported) {
			this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height);
			this.ghostCtx.beginPath();
		}
	}

	EventManager.prototype.getNewObjectTrackingId = function () {
		return ++this.lastObjectId;
	}

	EventManager.prototype.mouseEventHandler = function (ev) {

		if (ev.type !== &quot;mousemove&quot; &amp;&amp; ev.type !== &quot;click&quot;)
			return;

		var eventObjectMaps = [];
		var xy = getMouseCoordinates(ev);
		var id = null;

		//var dataPointInfo = this.chart.getDataPointAtXY(xy.x, xy.y, false);

		//if (dataPointInfo) {
		//	id = dataPointInfo.dataSeries.dataPointIds[dataPointInfo.dataPointIndex];
		//} else if (isCanvasSupported) {//IE9+
		//	id = getObjectId(xy.x, xy.y, this.ghostCtx);
		//}
		id = this.chart.getObjectAtXY(xy.x, xy.y, false);

		if (id &amp;&amp; typeof (this.objectMap[id]) !== &quot;undefined&quot;) {

			var eventObjectMap = this.objectMap[id];

			if (eventObjectMap.objectType === &quot;dataPoint&quot;) {
				var dataSeries = this.chart.data[eventObjectMap.dataSeriesIndex];
				var dataPoint = dataSeries.dataPoints[eventObjectMap.dataPointIndex];
				var dataPointIndex = eventObjectMap.dataPointIndex;

				//Event Parameter should not contain reference to dataSeries directly. But to its options.
				eventObjectMap.eventParameter = {
					x: xy.x, y: xy.y, dataPoint: dataPoint,
					dataSeries: dataSeries._options, dataPointIndex: dataPointIndex, dataSeriesIndex: dataSeries.index,
					chart: this.chart._publicChartReference
				};
				eventObjectMap.eventContext = {
					context: dataPoint, userContext: dataPoint, mouseover: &quot;mouseover&quot;, mousemove: &quot;mousemove&quot;, mouseout: &quot;mouseout&quot;, click: &quot;click&quot;
				};
				eventObjectMaps.push(eventObjectMap);

				//Add Dataseries too because mouse event on dataPoint also means there is an event on dataSeries. DataSeries is not present on ghost canvas
				eventObjectMap = this.objectMap[dataSeries.id];

				//Event Parameter should not contain reference to dataSeries directly. But to its options.
				eventObjectMap.eventParameter = {
					x: xy.x, y: xy.y,
					dataPoint: dataPoint, dataSeries: dataSeries._options, dataPointIndex: dataPointIndex, dataSeriesIndex: dataSeries.index,
					chart: this.chart._publicChartReference
				};

				eventObjectMap.eventContext = {
					context: dataSeries, userContext: dataSeries._options, mouseover: &quot;mouseover&quot;, mousemove: &quot;mousemove&quot;, mouseout: &quot;mouseout&quot;, click: &quot;click&quot;
				};
				eventObjectMaps.push(this.objectMap[dataSeries.id]);
			}
				//else if (eventObjectMap.objectType === &quot;stripLine&quot;) {

				//	//Event Parameter should not contain reference to stripLine directly. But to its options.
				//	eventObjectMap.eventParameter = { x: xy.x, y: xy.y, stripLine: eventObjectMap.stripLine._options, axis: eventObjectMap.axis._options, stripLineIndex: eventObjectMap.stripLineIndex };
				//	eventObjectMap.eventContext = { context: eventObjectMap.stripLine, userContext: eventObjectMap.stripLine._options, mouseover: &quot;mouseover&quot;, mousemove: &quot;mousemove&quot;, mouseout: &quot;mouseout&quot;, click: &quot;click&quot; };

				//	eventObjectMaps.push(eventObjectMap);
				//}
			else if (eventObjectMap.objectType === &quot;legendItem&quot;) {

				var dataSeries = this.chart.data[eventObjectMap.dataSeriesIndex];
				var dataPoint = eventObjectMap.dataPointIndex !== null ? dataSeries.dataPoints[eventObjectMap.dataPointIndex] : null;

				//Event Parameter should not contain reference to DataSeries directly. But to its options.
				eventObjectMap.eventParameter = {
					x: xy.x, y: xy.y,
					dataSeries: dataSeries._options, dataPoint: dataPoint, dataPointIndex: eventObjectMap.dataPointIndex, dataSeriesIndex: eventObjectMap.dataSeriesIndex,
					chart: this.chart._publicChartReference
				};
				eventObjectMap.eventContext = {
					context: this.chart.legend, userContext: this.chart.legend._options, mouseover: &quot;itemmouseover&quot;, mousemove: &quot;itemmousemove&quot;, mouseout: &quot;itemmouseout&quot;, click: &quot;itemclick&quot;
				};
				eventObjectMaps.push(eventObjectMap);
			}
		}

		//Fire mouseout if existing mouseovered objects are not present in the objectmap.
		var mouseOutObjectMapsExcluded = [];
		for (var i = 0; i &lt; this.mouseoveredObjectMaps.length; i++) {
			var mouseOut = true;

			for (var j = 0; j &lt; eventObjectMaps.length; j++) {
				if (eventObjectMaps[j].id === this.mouseoveredObjectMaps[i].id) {
					mouseOut = false;
					break;
				}
			}

			if (mouseOut) {
				this.fireEvent(this.mouseoveredObjectMaps[i], &quot;mouseout&quot;, ev);
			} else {
				mouseOutObjectMapsExcluded.push(this.mouseoveredObjectMaps[i]);
			}
		}

		this.mouseoveredObjectMaps = mouseOutObjectMapsExcluded;

		//Process new eventObectMaps
		//If they already don&#x27;t exist, add them and fire mouseover
		//If ev.type is mousemove, then just fire mousemove
		//If ev.type is click, then fire two events - click followed by mousemove
		for (var i = 0; i &lt; eventObjectMaps.length; i++) {

			var existing = false;

			for (var j = 0; j &lt; this.mouseoveredObjectMaps.length; j++) {
				if (eventObjectMaps[i].id === this.mouseoveredObjectMaps[j].id) {
					existing = true;
					break;
				}
			}

			if (!existing) {
				this.fireEvent(eventObjectMaps[i], &quot;mouseover&quot;, ev);
				this.mouseoveredObjectMaps.push(eventObjectMaps[i]);
			}

			if (ev.type === &quot;click&quot;) {
				this.fireEvent(eventObjectMaps[i], &quot;click&quot;, ev);
			} else if (ev.type === &quot;mousemove&quot;) {
				this.fireEvent(eventObjectMaps[i], &quot;mousemove&quot;, ev);
			}
		}
	}

	EventManager.prototype.fireEvent = function (eventObjectMap, eventType, ev) {

		if (!eventObjectMap || !eventType)
			return;

		var eventParameter = eventObjectMap.eventParameter;
		var eventContext = eventObjectMap.eventContext;
		//var context = eventObjectMap.eventContext.context;
		var userContext = eventObjectMap.eventContext.userContext

		if (userContext &amp;&amp; eventContext &amp;&amp; userContext[eventContext[eventType]])
			userContext[eventContext[eventType]].call(userContext, eventParameter);

		if (eventType !== &quot;mouseout&quot;) {
			if (userContext.cursor &amp;&amp; userContext.cursor !== ev.target.style.cursor) {
				ev.target.style.cursor = userContext.cursor;
			}
		} else {
			ev.target.style.cursor = this.chart._defaultCursor;
			delete eventObjectMap.eventParameter; // reference no longer required.
			delete eventObjectMap.eventContext; // reference no longer required.
		}

		//This is just a quick fix. Need to find a better way of calling internal event handlers.
		if (eventType === &quot;click&quot; &amp;&amp; eventObjectMap.objectType === &quot;dataPoint&quot; &amp;&amp; this.chart.pieDoughnutClickHandler) {
			this.chart.pieDoughnutClickHandler.call(this.chart.data[eventObjectMap.dataSeriesIndex], eventParameter);
		}
	}

	//#endregion Event Manager

	//#region Class CultureInfo

	function CultureInfo(culture) {

		var cultureInfo;

		if (culture &amp;&amp; cultures[culture])
			cultureInfo = cultures[culture];

		CultureInfo.base.constructor.call(this, &quot;CultureInfo&quot;, cultureInfo);
	}

	extend(CultureInfo, CanvasJSObject);

	//#endregion Class CultureInfo

	//#region Animator


	function Animator(chart) {

		this.chart = chart;
		this.ctx = this.chart.plotArea.ctx;
		this.animations = [];
		this.animationRequestId = null;
	}

	//Animator.prototype.animate = function (duration, base, dest, source, animationCallback, onComplete) {
	Animator.prototype.animate = function (startDelay, duration, animationCallback, onComplete, easingFunction) {
		var _this = this;

		this.chart.isAnimating = true;
		easingFunction = easingFunction || AnimationHelper.easing.linear;

		if (animationCallback) {

			this.animations.push({
				startTime: (new Date()).getTime() + (startDelay ? startDelay : 0),
				duration: duration,
				animationCallback: animationCallback,
				onComplete: onComplete
			});
		}

		var remainingAnimations = [];

		while (this.animations.length &gt; 0) {

			var animation = this.animations.shift();
			var now = (new Date()).getTime();
			var fractionComplete = 0;
			//var fractionComplete = Math.min(((new Date()).getTime() - animation.startTime) / animation.duration, 1);

			if (animation.startTime &lt;= now) {
				fractionComplete = easingFunction(Math.min((now - animation.startTime), animation.duration), 0, 1, animation.duration);
				//var fractionComplete = AnimationHelper.easing.easeOutQuad(Math.min(((new Date()).getTime() - animation.startTime), animation.duration), 0, 1, animation.duration);

				fractionComplete = Math.min(fractionComplete, 1);

				if (isNaN(fractionComplete) || !isFinite(fractionComplete))
					fractionComplete = 1;
			}

			if (fractionComplete &lt; 1) {
				remainingAnimations.push(animation);
			}

			animation.animationCallback(fractionComplete);

			if (fractionComplete &gt;= 1 &amp;&amp; animation.onComplete)
				animation.onComplete();
		}

		this.animations = remainingAnimations;

		if (this.animations.length &gt; 0) {
			this.animationRequestId = this.chart.requestAnimFrame.call(window, function () {
				_this.animate.call(_this);
			});
		} else {
			this.chart.isAnimating = false;
		}

	}

	Animator.prototype.cancelAllAnimations = function () {

		this.animations = [];

		if (this.animationRequestId) {
			this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId);
		}

		this.animationRequestId = null;
		this.chart.isAnimating = false;
	}

	var AnimationHelper = {
		yScaleAnimation: function (fractionComplete, animationInfo) {
			if (fractionComplete === 0)
				return;

			var ctx = animationInfo.dest;
			var sourceCanvas = animationInfo.source.canvas;
			var base = animationInfo.animationBase;

			var offsetY = (base - base * fractionComplete);

			ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, offsetY, ctx.canvas.width / devicePixelBackingStoreRatio, fractionComplete * ctx.canvas.height / devicePixelBackingStoreRatio);
		},
		xScaleAnimation: function (fractionComplete, animationInfo) {
			if (fractionComplete === 0)
				return;

			var ctx = animationInfo.dest;
			var sourceCanvas = animationInfo.source.canvas;
			var base = animationInfo.animationBase;

			var offsetX = (base - base * fractionComplete);

			ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, offsetX, 0, fractionComplete * ctx.canvas.width / devicePixelBackingStoreRatio, ctx.canvas.height / devicePixelBackingStoreRatio);
		},
		xClipAnimation: function (fractionComplete, animationInfo) {

			if (fractionComplete === 0)
				return;

			var ctx = animationInfo.dest;
			var sourceCanvas = animationInfo.source.canvas;

			ctx.save();

			if (fractionComplete &gt; 0)
				ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width * fractionComplete, sourceCanvas.height, 0, 0, sourceCanvas.width * fractionComplete / devicePixelBackingStoreRatio, sourceCanvas.height / devicePixelBackingStoreRatio);

			ctx.restore();
		},
		fadeInAnimation: function (fractionComplete, animationInfo) {

			if (fractionComplete === 0)
				return;

			var ctx = animationInfo.dest;
			var sourceCanvas = animationInfo.source.canvas;

			ctx.save();

			ctx.globalAlpha = fractionComplete;

			ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, 0, ctx.canvas.width / devicePixelBackingStoreRatio, ctx.canvas.height / devicePixelBackingStoreRatio);

			ctx.restore();
		},
		easing: {
			linear: function (t, b, c, d) {
				return c * t / d + b;
			},
			easeOutQuad: function (t, b, c, d) {
				return -c * (t /= d) * (t - 2) + b;
			},
			easeOutQuart: function (t, b, c, d) {
				return -c * ((t = t / d - 1) * t * t * t - 1) + b;
			},
			easeInQuad: function (t, b, c, d) {
				return c * (t /= d) * t + b;
			},
			easeInQuart: function (t, b, c, d) {
				return c * (t /= d) * t * t * t + b;
			}
		}
	}

	//#endregion Animator

	//#region Render Helper

	var RenderHelper = {
		drawMarker: function (x, y, ctx, markerType, markerSize, markerColor, markerBorderColor, markerBorderThickness) {

			if (!ctx)
				return;

			var alpha = 1;

			ctx.fillStyle = markerColor ? markerColor : &quot;#000000&quot;;
			ctx.strokeStyle = markerBorderColor ? markerBorderColor : &quot;#000000&quot;;
			ctx.lineWidth = markerBorderThickness ? markerBorderThickness : 0;


			if (markerType === &quot;circle&quot;) {

				ctx.moveTo(x, y);
				ctx.beginPath();
				//return;

				ctx.arc(x, y, markerSize / 2, 0, Math.PI * 2, false);

				if (markerColor)
					ctx.fill();

				if (markerBorderThickness) {

					if (!markerBorderColor) {
						alpha = ctx.globalAlpha;
						ctx.globalAlpha = .15;
						ctx.strokeStyle = &quot;black&quot;;
						ctx.stroke();
						ctx.globalAlpha = alpha;
					} else
						ctx.stroke();

				}
			}
			else if (markerType === &quot;square&quot;) {

				//ctx.moveTo(x - markerSize / 2, y - markerSize / 2);
				ctx.beginPath();
				ctx.rect(x - markerSize / 2, y - markerSize / 2, markerSize, markerSize);

				if (markerColor)
					ctx.fill();

				if (markerBorderThickness) {

					if (!markerBorderColor) {
						alpha = ctx.globalAlpha;
						ctx.globalAlpha = .15;
						ctx.strokeStyle = &quot;black&quot;;
						ctx.stroke();
						ctx.globalAlpha = alpha;
					} else
						ctx.stroke();

				}
			} else if (markerType === &quot;triangle&quot;) {

				ctx.beginPath();
				ctx.moveTo(x - markerSize / 2, y + markerSize / 2);
				ctx.lineTo(x + markerSize / 2, y + markerSize / 2);
				ctx.lineTo(x, y - markerSize / 2);
				ctx.closePath();

				if (markerColor)
					ctx.fill();

				if (markerBorderThickness) {

					if (!markerBorderColor) {
						alpha = ctx.globalAlpha;
						ctx.globalAlpha = .15;
						ctx.strokeStyle = &quot;black&quot;;
						ctx.stroke();
						ctx.globalAlpha = alpha;
					} else
						ctx.stroke();

				}
				ctx.beginPath();
			} else if (markerType === &quot;cross&quot;) {

				ctx.strokeStyle = markerColor;
				markerBorderThickness = markerSize / 4;
				ctx.lineWidth = markerBorderThickness;

				ctx.beginPath();
				ctx.moveTo(x - markerSize / 2, y - markerSize / 2);
				ctx.lineTo(x + markerSize / 2, y + markerSize / 2);
				ctx.stroke();

				ctx.moveTo(x + markerSize / 2, y - markerSize / 2);
				ctx.lineTo(x - markerSize / 2, y + markerSize / 2);
				ctx.stroke();

			}


		},
		drawMarkers: function (markers) {
			for (var i = 0; i &lt; markers.length; i++) {
				var marker = markers[i];

				RenderHelper.drawMarker(marker.x, marker.y, marker.ctx, marker.type, marker.size, marker.color, marker.borderColor, marker.borderThickness);
			}
		}
		//,
		//draw1pxLine: function (x1, y1, x2, y2, color, ctx) {
		//	ctx.beginPath();
		//	ctx.drawRect(x1, y1, x2 - x1, y2 - y1);
		//	ctx.stroke();
		//}
	}

	//#endregion Render Helper

	//#endregion Class Definitions

	//#region Public API
	var CanvasJS = {

		Chart: function (containerId, options) {
			var _chart = new Chart(containerId, options, this);

			this.render = function () {
				_chart.render(this.options)
			};
			//console.log(_chart);
			this.options = _chart._options;
		},
		addColorSet: function (name, colorSet) {
			colorSets[name] = colorSet;
		},
		addCultureInfo: function (name, cultureInfo) {
			cultures[name] = cultureInfo;
		},
		formatNumber: function (number, formatString, culture) {
			culture = culture || &quot;en&quot;;
			formatString = formatString || &quot;#,##0.##&quot;;

			if (!cultures[culture])
				throw &quot;Unknown Culture Name&quot;;
			else {
				return numberFormat(number, formatString, new CultureInfo(culture));
			}
		},
		formatDate: function (date, formatString, culture) {
			culture = culture || &quot;en&quot;;
			formatString = formatString || &quot;DD MMM YYYY&quot;;

			if (!cultures[culture])
				throw &quot;Unknown Culture Name&quot;;
			else {
				return dateFormat(date, formatString, new CultureInfo(culture));
			}
		}

	}

	CanvasJS.Chart.version = &quot;v1.8.1 GA&quot;;
	window.CanvasJS = CanvasJS;
	//#endregion Public API

})();
</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/js/tabs.js"></script>
</body>
</html>
